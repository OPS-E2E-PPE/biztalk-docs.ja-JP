---
title: ビジネス ルール エンジン (BRE) のパフォーマンスを最適化する |Microsoft ドキュメント
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: c271b059-174d-4e8b-88b5-c3f408a97f1f
caps.latest.revision: 4
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 14c3adf32ac06d80c1aab8f870d82156470097a5
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
ms.locfileid: "22298930"
---
# <a name="optimizing-business-rule-engine-bre-performance"></a><span data-ttu-id="3b2b3-102">ビジネス ルール エンジン (BRE) のパフォーマンスを最適化します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-102">Optimizing Business Rule Engine (BRE) Performance</span></span>
<span data-ttu-id="3b2b3-103">BizTalk Server ソリューションでビジネス ルール エンジン (BRE) を実装する場合は、次の要因を検討してください。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-103">The following factors should be considered when implementing the Business Rule Engine (BRE) in a BizTalk Server solution:</span></span>  
  
## <a name="fact-types"></a><span data-ttu-id="3b2b3-104">ファクトの種類</span><span class="sxs-lookup"><span data-stu-id="3b2b3-104">Fact types</span></span>  
 <span data-ttu-id="3b2b3-105">ルール エンジンでは、アクセス .NET ファクトを時間と比較したアクセスの XML およびデータベースのファクトにかかる少ない時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-105">The rule engine takes less time to access .NET facts compared to the time it takes to access XML and database facts.</span></span> <span data-ttu-id="3b2b3-106">ポリシーで .NET、XML、またはデータベース ファクトを使用する選択肢があればは、パフォーマンス向上のための .NET のファクトの使用を検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-106">If you have a choice of using either .NET or XML or database facts in a policy, you should consider using .NET facts for improved performance.</span></span>  
  
## <a name="data-table-vs-data-connection"></a><span data-ttu-id="3b2b3-107">データ接続とデータ テーブル</span><span class="sxs-lookup"><span data-stu-id="3b2b3-107">Data table vs. data connection</span></span>  
 <span data-ttu-id="3b2b3-108">データ セットのサイズが小さい場合 (< 10 またはため)、 **TypedDataTable**バインドよりも優れたパフォーマンスを提供する、 **DataConnection**バインドします。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-108">When the size of the data set is small (< 10 or so), the **TypedDataTable** binding provides better performance than the **DataConnection** binding.</span></span> <span data-ttu-id="3b2b3-109">ただし、 **DataConnection**バインド パフォーマンスが向上よりも、 **TypedDataTable**データ セットが大きいときにバインディング (より大きいか等しい 10 行を約)。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-109">However, the **DataConnection** binding performs better than the **TypedDataTable** binding when the data set is large (greater than or equal to 10 rows approximately).</span></span> <span data-ttu-id="3b2b3-110">そのためを使用するかどうかを決定する必要があります、 **DataConnection**バインドまたは**TypedDataTable**データ セットの推定サイズに基づいて、バインドします。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-110">Therefore, you should decide whether to use the **DataConnection** binding or **TypedDataTable** binding based on the estimated size of the data set.</span></span>  
  
## <a name="fact-retrievers"></a><span data-ttu-id="3b2b3-111">ファクト取得コンポーネント</span><span class="sxs-lookup"><span data-stu-id="3b2b3-111">Fact retrievers</span></span>  
 <span data-ttu-id="3b2b3-112">ファクト取得コンポーネントでは、通常は、ポリシーが実行される前に、ルール エンジンへの長期的および緩やかに変化するファクトを指定に使用する標準的なメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-112">A fact retriever implements standard methods which are typically used to supply long-term and slowly changing facts to the rule engine before a policy is executed.</span></span> <span data-ttu-id="3b2b3-113">エンジンはこれらのファクトをキャッシュして、複数の実行サイクルで使用します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-113">The engine caches these facts and uses them over multiple execution cycles.</span></span> <span data-ttu-id="3b2b3-114">静的やほぼ静的なファクトたびに、ルール エンジンを呼び出していることを送信するには、代わりに、最初に、ファクトを送信し、必要な場合にのみメモリ内のファクトを更新するファクト取得コンポーネントを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-114">Instead of submitting a static or fairly static fact each time that you invoke the rule engine, you should create a fact retriever that submits the fact for the first time, and then updates the fact in memory only when necessary.</span></span>  
  
## <a name="rule-priority"></a><span data-ttu-id="3b2b3-115">ルールの優先順位</span><span class="sxs-lookup"><span data-stu-id="3b2b3-115">Rule priority</span></span>  
 <span data-ttu-id="3b2b3-116">いずれかの側の範囲はルールの優先度設定**0**、高い優先順位を持つ大きな数字を使用します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-116">The priority setting for a rule can range on either side of **0**, with larger numbers having higher priority.</span></span> <span data-ttu-id="3b2b3-117">アクションは、最高の優先度から最も低い優先順位の順に実行されます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-117">Actions are executed in order from the highest priority to lowest priority.</span></span> <span data-ttu-id="3b2b3-118">ポリシーが使用して順行連鎖の動作を実装するときに**Assert/update**チェーンの呼び出しは、優先順位設定を使用して最適化できます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-118">When the policy implements forward-chaining behavior by using **Assert/Update** calls, the chaining can be optimized by using the priority setting.</span></span> <span data-ttu-id="3b2b3-119">たとえば、あると想定**Rule2**によって設定された値に依存している**Rule1**です。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-119">For example, assume that **Rule2** has a dependency on a value set by **Rule1**.</span></span> <span data-ttu-id="3b2b3-120">提供**Rule1**優先順位が高いことを意味**Rule2**後にのみ実行**Rule1**が起動し、値を更新します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-120">Giving **Rule1** a higher priority means that **Rule2** will only execute after **Rule1** fires and updates the value.</span></span> <span data-ttu-id="3b2b3-121">逆に場合、 **Rule2**が高い優先順位を指定するには、その可能性がありますに 1 回発生して、後にもう一度**Rule1**が起動し、ファクトを更新する**Rule2**条件を使用しています。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-121">Conversely, if **Rule2** were given a higher priority, it could fire once, and then fire again after **Rule1** fires and update the fact that **Rule2** is using a condition.</span></span> <span data-ttu-id="3b2b3-122">これにより、正しい結果が提供することがあります、与える**Rule1**このシナリオでは優先順位が高いがより優れたパフォーマンスを実現します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-122">While this may provide a correct result, giving **Rule1** a higher priority in this scenario will provide better performance.</span></span>  
  
## <a name="update-calls"></a><span data-ttu-id="3b2b3-123">更新プログラムの呼び出し</span><span class="sxs-lookup"><span data-stu-id="3b2b3-123">Update calls</span></span>  
 <span data-ttu-id="3b2b3-124">Update 関数はにより更新されたファクトを使用して、再評価するすべてのルールです。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-124">The Update function causes all the rules using the updated facts to be reevaluated.</span></span> <span data-ttu-id="3b2b3-125">Update 関数の呼び出しは、ファクトを更新するときに、大規模な一連のルールが再評価される場合に特に高価なできます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-125">Update function calls can be expensive especially if a large set of rules is reevaluated when updating facts.</span></span> <span data-ttu-id="3b2b3-126">この動作を回避する場合があります。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-126">There are situations where this behavior can be avoided.</span></span> <span data-ttu-id="3b2b3-127">たとえば、次の規則があるとします。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-127">For example, consider the following rules.</span></span>  
  
 <span data-ttu-id="3b2b3-128">**Rule1:**</span><span class="sxs-lookup"><span data-stu-id="3b2b3-128">**Rule1:**</span></span>  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 <span data-ttu-id="3b2b3-129">**Rule2:**</span><span class="sxs-lookup"><span data-stu-id="3b2b3-129">**Rule2:**</span></span>  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 <span data-ttu-id="3b2b3-130">ポリシーの使用の残りのルール**StatusObj.Flag**条件。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-130">All remaining rules of the policy use **StatusObj.Flag** in their conditions.</span></span> <span data-ttu-id="3b2b3-131">したがって、**更新**で呼び出されると、 **StatusObj**オブジェクトのすべてのルールが再評価されます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-131">Therefore, when **Update** is called on the **StatusObj** object, all rules will be reevaluated.</span></span> <span data-ttu-id="3b2b3-132">どのような値、**量**フィールドは、すべてのルールを除く**Rule1**または**Rule2**を 2 回評価される前に 1 回、**更新**を呼び出す後に 1 回、**更新**呼び出します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-132">Whatever the value of the **Amount** field is, all rules except **Rule1** or **Rule2** are evaluated twice, once before the **Update** call and once after the **Update** call.</span></span>  
  
 <span data-ttu-id="3b2b3-133">関連付けられたを軽減するオーバーヘッドをする可能性がありますの値を設定、**フラグ**フィールドを**false**のみを使用して、ポリシーを呼び出す前に**Rule1**フラグを設定するためのポリシーで.</span><span class="sxs-lookup"><span data-stu-id="3b2b3-133">To mitigate the associated overhead, you could set the value of the **flag** field to **false** prior to invoking the policy and then use only **Rule1** in the policy to set the flag.</span></span> <span data-ttu-id="3b2b3-134">この場合、**更新**場合にのみが呼び出されますの値、**量**フィールドが 5 より大きいと**更新**場合、関数は呼び出されませんの値**金額**が 5 未満です。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-134">In this case, **Update** would be called only if the value of the **Amount** field is greater than 5, and the **Update** function is not called if the value of **Amount** is less than or equal to 5.</span></span> <span data-ttu-id="3b2b3-135">そのため、すべてのルールを除く**Rule1**または**Rule2**が評価される場合にのみ 2 回の値、**量**フィールドが 5 より大きい。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-135">Therefore, all the rules except **Rule1** or **Rule2** are evaluated twice only if the value of the **Amount** field is greater than 5.</span></span>  
  
## <a name="usage-of-logical-or-operators"></a><span data-ttu-id="3b2b3-136">論理 OR 演算子の使用法</span><span class="sxs-lookup"><span data-stu-id="3b2b3-136">Usage of logical OR operators</span></span>  
 <span data-ttu-id="3b2b3-137">条件でますます多くの論理 OR 演算子を使用する順列が追加、ルール エンジンの分析ネットワークを展開します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-137">Using an increasing number of logical OR operators in conditions creates additional permutations that expand the analysis network of the rule engine.</span></span> <span data-ttu-id="3b2b3-138">パフォーマンスの観点から、論理 OR 演算子を含まないアトミック ルールに条件を分割することをお勧めしています。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-138">From a performance standpoint, you are better off splitting the conditions into atomic rules that do not contain logical OR operators.</span></span>  
  
## <a name="caching-settings"></a><span data-ttu-id="3b2b3-139">キャッシュの設定</span><span class="sxs-lookup"><span data-stu-id="3b2b3-139">Caching settings</span></span>  
 <span data-ttu-id="3b2b3-140">ルール エンジンでは、2 つのキャッシュを使用します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-140">The Rule Engine uses two caches.</span></span> <span data-ttu-id="3b2b3-141">最初の 1 つは更新サービスによって使用され、2 つ目は、各 BizTalk プロセスで使用されます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-141">The first one is used by the update service and the second one is used by each BizTalk process.</span></span> <span data-ttu-id="3b2b3-142">ポリシーを使用すると、最初に、BizTalk プロセスは、更新サービスからのポリシー情報を要求します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-142">The first time a policy is used, the BizTalk process requests the policy information from the update service.</span></span> <span data-ttu-id="3b2b3-143">更新サービスは、ルール エンジン データベースからポリシー情報を取得、それをキャッシュおよび BizTalk プロセスに情報を返します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-143">The update service retrieves the policy information from the rule engine database, caches it and returns the information to the BizTalk process.</span></span> <span data-ttu-id="3b2b3-144">BizTalk プロセスは、その情報に基づいてポリシー オブジェクトを作成し、関連付けられているルール エンジン インスタンスには、ポリシーの実行が完了すると、ポリシー オブジェクトをキャッシュに格納します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-144">The BizTalk process creates a policy object based on that information and stores the policy object in a cache when the associated rule engine instance completes execution of the policy.</span></span> <span data-ttu-id="3b2b3-145">同じポリシーが再度呼び出されると、1 つが利用可能な場合、BizTalk プロセス ポリシー オブジェクトをキャッシュから再利用します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-145">When the same policy is invoked again, the BizTalk process reuses the policy object from the cache if one is available.</span></span> <span data-ttu-id="3b2b3-146">同様に、BizTalk プロセスは、更新サービスからのポリシーに関する情報を要求している場合、更新サービスは、キャッシュ内のポリシー情報を使用可能になる場合。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-146">Similarly, if the BizTalk process requests information about a policy from update service, the update service looks for the policy information in its cache if it is available.</span></span> <span data-ttu-id="3b2b3-147">60 秒ごとに、更新サービスも確認加えられていないかどうか、データベース内のポリシーを更新します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-147">Every 60 seconds, the update service also checks if there have been any updates to the policy in the database.</span></span> <span data-ttu-id="3b2b3-148">更新プログラムがある場合は、更新サービスは、情報を取得し、更新された情報をキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-148">If there are any updates, the update service retrieves the information and caches the updated information.</span></span>  
  
 <span data-ttu-id="3b2b3-149">これらのキャッシュに関連するルール エンジンの 3 つのチューニング パラメーターがある: **CacheEntries**、 **CacheTimeout**、および**PollingInterval**です。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-149">There are three tuning parameters for the rule engine related to these caches: **CacheEntries**, **CacheTimeout**, and **PollingInterval**.</span></span> <span data-ttu-id="3b2b3-150">これらのパラメーターの値は、レジストリまたは構成ファイルで指定できます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-150">You can specify the values for these parameters either in the registry or in a configuration file.</span></span> <span data-ttu-id="3b2b3-151">値、 **CacheEntries**パラメーターは、キャッシュ内のエントリの最大数で、既定で 32 の値に設定されています。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-151">The value of the **CacheEntries** parameter is the maximum number of entries in the cache and is set to a value of 32 by default.</span></span> <span data-ttu-id="3b2b3-152">値を大きくことも、 **CacheEntries**パラメーターを特定のシナリオでパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-152">You may want to increase the value of the **CacheEntries** parameter to improve performance in certain scenarios.</span></span> <span data-ttu-id="3b2b3-153">たとえば、繰り返し; 40 個のポリシーを使用しています。値を大きくことも、 **CacheEntries**パフォーマンスを向上させるために 40 のパラメーターです。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-153">For example, say you are using 40 policies repeatedly; you could to increase the value of the **CacheEntries** parameter to 40 to improve performance.</span></span> <span data-ttu-id="3b2b3-154">更新サービス キャッシュの詳細の最大メモリの 40 のポリシーを維持するためにこのようにするとします。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-154">This would allow the update service to maintain cache details of up to 40 policies in memory.</span></span>  
  
 <span data-ttu-id="3b2b3-155">値**CacheTimeout**更新サービス キャッシュにエントリを保持しておく秒単位で時間です。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-155">The value of **CacheTimeout** is the time in seconds that an entry is maintained in the update service cache.</span></span> <span data-ttu-id="3b2b3-156">言い換えると、 **CacheTimeout**ポリシーが参照されていることがなく、キャッシュに保持されたために、値がどのくらいの時間、キャッシュ エントリを参照します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-156">In other words, the **CacheTimeout** value refers to how long a cache entry for a policy is maintained in the cache without being referenced.</span></span> <span data-ttu-id="3b2b3-157">既定値の**CacheTimeout**パラメーターは、3600 (秒単位) または 1 時間です。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-157">The default value of **CacheTimeout** parameter is 3600 seconds, or 1 hour.</span></span> <span data-ttu-id="3b2b3-158">キャッシュ エントリが 1 時間以内に参照されていない場合、エントリが削除されることを示します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-158">It means that if the cache entry is not referenced within an hour, the entry is deleted.</span></span> <span data-ttu-id="3b2b3-159">場合によっては、値を大きくと役に立つ場合があります、 **CacheTimeout**パフォーマンスを向上させるためにパラメーター。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-159">In some cases, it may be beneficial to increase the value of the **CacheTimeout** parameter to improve performance.</span></span> <span data-ttu-id="3b2b3-160">たとえば、2 時間ごと、ポリシーが呼び出される場合、ポリシー実行のパフォーマンスは向上を増やすことで、 **CacheTimeout**パラメーター値を 2 時間よりも大きくします。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-160">For example, if a policy is invoked every two hours, performance of the policy execution would be improved by increasing the **CacheTimeout** parameter to a value higher than two hours.</span></span>  
  
 <span data-ttu-id="3b2b3-161">**PollingInterval**ルール エンジンのパラメーターは、ルール エンジン データベースの更新プログラムをチェックする、更新サービスを秒単位で時間を定義します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-161">The **PollingInterval** parameter of the rule engine defines the time in seconds for the update service to check the rule engine database for updates.</span></span> <span data-ttu-id="3b2b3-162">既定値、 **PollingInterval**パラメーターは、60 秒です。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-162">The default value for the **PollingInterval** parameter is 60 seconds.</span></span> <span data-ttu-id="3b2b3-163">ポリシーがすべての更新はや、ほとんどの更新がわかっている場合は、パフォーマンスを向上させるために高い値をこのパラメーターを変更できます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-163">If you know that the policies do not get updated at all or are updated rarely, you could change this parameter to a higher value to improve performance.</span></span>  
  
## <a name="sideeffects-property"></a><span data-ttu-id="3b2b3-164">SideEffects プロパティ</span><span class="sxs-lookup"><span data-stu-id="3b2b3-164">SideEffects property</span></span>  
 <span data-ttu-id="3b2b3-165">**ClassMemberBinding**、 **DatabaseColumnBinding**、および**XmlDocumentFieldBinding**クラスという名前のプロパティがある**SideEffects**.</span><span class="sxs-lookup"><span data-stu-id="3b2b3-165">The **ClassMemberBinding**, **DatabaseColumnBinding**, and **XmlDocumentFieldBinding** classes have a property named **SideEffects**.</span></span> <span data-ttu-id="3b2b3-166">このプロパティは、バインドされるフィールド、メンバー、または列の値をキャッシュするかどうかを決定します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-166">This property determines whether the value of the bound field, member, or column is cached.</span></span> <span data-ttu-id="3b2b3-167">既定値、 **SideEffects**プロパティに、 **DatabaseColumnBinding**と**XmlDocumentFieldBinding**クラスは**false**.</span><span class="sxs-lookup"><span data-stu-id="3b2b3-167">The default value of the **SideEffects** property in the **DatabaseColumnBinding** and **XmlDocumentFieldBinding** classes is **false**.</span></span> <span data-ttu-id="3b2b3-168">既定値、 **SideEffects**プロパティに、 **ClassMemberBinding**クラスは**true**です。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-168">The default value of the **SideEffects** property in the **ClassMemberBinding** class is **true**.</span></span> <span data-ttu-id="3b2b3-169">したがって、XML ドキュメントのフィールドまたはデータベース テーブルの列がポリシー内で 2 回目以降にアクセスされたときには、その値がキャッシュから取得されます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-169">Therefore, when a field of an XML document or a column of a database table is accessed for the second time or later within the policy, its value is retrieved from the cache.</span></span> <span data-ttu-id="3b2b3-170">一方、.NET オブジェクトのメンバーが 2 回目以降にアクセスされたときには、値がキャッシュからではなく .NET オブジェクトから取得されます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-170">However, when a member of a .NET object is accessed for the second time or later, the value is retrieved from the .NET object, and not from the cache.</span></span> <span data-ttu-id="3b2b3-171">設定、 **SideEffects** .NET のプロパティ**ClassMemberBinding**に**false**からキャッシュから取得したフィールドの値であるために、パフォーマンスが向上します2 回目以降。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-171">Setting the **SideEffects** property of a .NET **ClassMemberBinding** to **false** will improve performance because the value of the field is retrieved from the cache from the second time onwards.</span></span> <span data-ttu-id="3b2b3-172">この設定は、プログラムでしか行うことができません。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-172">You can only do this programmatically.</span></span> <span data-ttu-id="3b2b3-173">ビジネス ルール作成ツールは公開しません、 **SideEffects**プロパティです。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-173">The Business Rule Composer tool does not expose the **SideEffects** property.</span></span>  
  
## <a name="instances-and-selectivity"></a><span data-ttu-id="3b2b3-174">Instances と selectivity</span><span class="sxs-lookup"><span data-stu-id="3b2b3-174">Instances and selectivity</span></span>  
 <span data-ttu-id="3b2b3-175">**XmlDocumentBinding**、 **ClassBinding**、および**DatabaseBinding**クラスは、次の 2 つのプロパティを持つ:**インスタンス**と**Selectivity**です。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-175">The **XmlDocumentBinding**, **ClassBinding**, and **DatabaseBinding** classes have two properties: **Instances** and **Selectivity**.</span></span> <span data-ttu-id="3b2b3-176">インスタンスの値は、作業メモリ内のクラスのインスタンスの予期される数です。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-176">The value of Instances is the expected number of instances of the class in working memory.</span></span> <span data-ttu-id="3b2b3-177">値**Selectivity**ルールの条件が正常に送信されるクラスのインスタンスの割合を指定します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-177">The value of **Selectivity** is the percentage of the class instances that will successfully pass the rule conditions.</span></span> <span data-ttu-id="3b2b3-178">ルール エンジンは、これらの値を使用して、まず最小限のインスタンスが条件の評価に使用され、その後で残りのインスタンスが使用されるように、条件の評価を最適化します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-178">The rule engine uses these values to optimize the condition evaluation so that the fewest possible instances are used in condition evaluations first and then the remaining instances are used.</span></span> <span data-ttu-id="3b2b3-179">オブジェクトのインスタンスの数の知識があれば、設定、**インスタンス**プロパティにその値をパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-179">If you have prior knowledge of the number of instances of the object, setting the **Instances** property to that value would improve performance.</span></span> <span data-ttu-id="3b2b3-180">同様に、これらのオブジェクト、条件を渡すことの割合の知識があれば、設定、 **Selectivity**プロパティにその値をパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-180">Similarly, if you have prior knowledge of the percentage of these objects passing the conditions, setting the **Selectivity** property to that value would improve performance.</span></span> <span data-ttu-id="3b2b3-181">これらのパラメーターの値は、プログラムでのみ設定できます。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-181">You can only set values for these parameters programmatically.</span></span> <span data-ttu-id="3b2b3-182">ビジネス ルール作成ツールでは、これらのパラメーターが公開されません。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-182">The Business Rule Composer tool does not expose them.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3b2b3-183">参照</span><span class="sxs-lookup"><span data-stu-id="3b2b3-183">See Also</span></span>  
 [<span data-ttu-id="3b2b3-184">BizTalk Server のパフォーマンスを最適化します。</span><span class="sxs-lookup"><span data-stu-id="3b2b3-184">Optimizing BizTalk Server Performance</span></span>](../technical-guides/optimizing-biztalk-server-performance.md)