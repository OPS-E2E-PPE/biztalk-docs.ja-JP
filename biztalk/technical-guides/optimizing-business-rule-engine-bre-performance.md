---
title: ビジネス ルール エンジン (BRE) のパフォーマンスを最適化する |Microsoft ドキュメント
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: c271b059-174d-4e8b-88b5-c3f408a97f1f
caps.latest.revision: 4
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 14c3adf32ac06d80c1aab8f870d82156470097a5
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
ms.locfileid: "22298930"
---
# <a name="optimizing-business-rule-engine-bre-performance"></a>ビジネス ルール エンジン (BRE) のパフォーマンスを最適化します。
BizTalk Server ソリューションでビジネス ルール エンジン (BRE) を実装する場合は、次の要因を検討してください。  
  
## <a name="fact-types"></a>ファクトの種類  
 ルール エンジンでは、アクセス .NET ファクトを時間と比較したアクセスの XML およびデータベースのファクトにかかる少ない時間がかかります。 ポリシーで .NET、XML、またはデータベース ファクトを使用する選択肢があればは、パフォーマンス向上のための .NET のファクトの使用を検討する必要があります。  
  
## <a name="data-table-vs-data-connection"></a>データ接続とデータ テーブル  
 データ セットのサイズが小さい場合 (< 10 またはため)、 **TypedDataTable**バインドよりも優れたパフォーマンスを提供する、 **DataConnection**バインドします。 ただし、 **DataConnection**バインド パフォーマンスが向上よりも、 **TypedDataTable**データ セットが大きいときにバインディング (より大きいか等しい 10 行を約)。 そのためを使用するかどうかを決定する必要があります、 **DataConnection**バインドまたは**TypedDataTable**データ セットの推定サイズに基づいて、バインドします。  
  
## <a name="fact-retrievers"></a>ファクト取得コンポーネント  
 ファクト取得コンポーネントでは、通常は、ポリシーが実行される前に、ルール エンジンへの長期的および緩やかに変化するファクトを指定に使用する標準的なメソッドを実装します。 エンジンはこれらのファクトをキャッシュして、複数の実行サイクルで使用します。 静的やほぼ静的なファクトたびに、ルール エンジンを呼び出していることを送信するには、代わりに、最初に、ファクトを送信し、必要な場合にのみメモリ内のファクトを更新するファクト取得コンポーネントを作成する必要があります。  
  
## <a name="rule-priority"></a>ルールの優先順位  
 いずれかの側の範囲はルールの優先度設定**0**、高い優先順位を持つ大きな数字を使用します。 アクションは、最高の優先度から最も低い優先順位の順に実行されます。 ポリシーが使用して順行連鎖の動作を実装するときに**Assert/update**チェーンの呼び出しは、優先順位設定を使用して最適化できます。 たとえば、あると想定**Rule2**によって設定された値に依存している**Rule1**です。 提供**Rule1**優先順位が高いことを意味**Rule2**後にのみ実行**Rule1**が起動し、値を更新します。 逆に場合、 **Rule2**が高い優先順位を指定するには、その可能性がありますに 1 回発生して、後にもう一度**Rule1**が起動し、ファクトを更新する**Rule2**条件を使用しています。 これにより、正しい結果が提供することがあります、与える**Rule1**このシナリオでは優先順位が高いがより優れたパフォーマンスを実現します。  
  
## <a name="update-calls"></a>更新プログラムの呼び出し  
 Update 関数はにより更新されたファクトを使用して、再評価するすべてのルールです。 Update 関数の呼び出しは、ファクトを更新するときに、大規模な一連のルールが再評価される場合に特に高価なできます。 この動作を回避する場合があります。 たとえば、次の規則があるとします。  
  
 **Rule1:**  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 **Rule2:**  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 ポリシーの使用の残りのルール**StatusObj.Flag**条件。 したがって、**更新**で呼び出されると、 **StatusObj**オブジェクトのすべてのルールが再評価されます。 どのような値、**量**フィールドは、すべてのルールを除く**Rule1**または**Rule2**を 2 回評価される前に 1 回、**更新**を呼び出す後に 1 回、**更新**呼び出します。  
  
 関連付けられたを軽減するオーバーヘッドをする可能性がありますの値を設定、**フラグ**フィールドを**false**のみを使用して、ポリシーを呼び出す前に**Rule1**フラグを設定するためのポリシーで. この場合、**更新**場合にのみが呼び出されますの値、**量**フィールドが 5 より大きいと**更新**場合、関数は呼び出されませんの値**金額**が 5 未満です。 そのため、すべてのルールを除く**Rule1**または**Rule2**が評価される場合にのみ 2 回の値、**量**フィールドが 5 より大きい。  
  
## <a name="usage-of-logical-or-operators"></a>論理 OR 演算子の使用法  
 条件でますます多くの論理 OR 演算子を使用する順列が追加、ルール エンジンの分析ネットワークを展開します。 パフォーマンスの観点から、論理 OR 演算子を含まないアトミック ルールに条件を分割することをお勧めしています。  
  
## <a name="caching-settings"></a>キャッシュの設定  
 ルール エンジンでは、2 つのキャッシュを使用します。 最初の 1 つは更新サービスによって使用され、2 つ目は、各 BizTalk プロセスで使用されます。 ポリシーを使用すると、最初に、BizTalk プロセスは、更新サービスからのポリシー情報を要求します。 更新サービスは、ルール エンジン データベースからポリシー情報を取得、それをキャッシュおよび BizTalk プロセスに情報を返します。 BizTalk プロセスは、その情報に基づいてポリシー オブジェクトを作成し、関連付けられているルール エンジン インスタンスには、ポリシーの実行が完了すると、ポリシー オブジェクトをキャッシュに格納します。 同じポリシーが再度呼び出されると、1 つが利用可能な場合、BizTalk プロセス ポリシー オブジェクトをキャッシュから再利用します。 同様に、BizTalk プロセスは、更新サービスからのポリシーに関する情報を要求している場合、更新サービスは、キャッシュ内のポリシー情報を使用可能になる場合。 60 秒ごとに、更新サービスも確認加えられていないかどうか、データベース内のポリシーを更新します。 更新プログラムがある場合は、更新サービスは、情報を取得し、更新された情報をキャッシュします。  
  
 これらのキャッシュに関連するルール エンジンの 3 つのチューニング パラメーターがある: **CacheEntries**、 **CacheTimeout**、および**PollingInterval**です。 これらのパラメーターの値は、レジストリまたは構成ファイルで指定できます。 値、 **CacheEntries**パラメーターは、キャッシュ内のエントリの最大数で、既定で 32 の値に設定されています。 値を大きくことも、 **CacheEntries**パラメーターを特定のシナリオでパフォーマンスが向上します。 たとえば、繰り返し; 40 個のポリシーを使用しています。値を大きくことも、 **CacheEntries**パフォーマンスを向上させるために 40 のパラメーターです。 更新サービス キャッシュの詳細の最大メモリの 40 のポリシーを維持するためにこのようにするとします。  
  
 値**CacheTimeout**更新サービス キャッシュにエントリを保持しておく秒単位で時間です。 言い換えると、 **CacheTimeout**ポリシーが参照されていることがなく、キャッシュに保持されたために、値がどのくらいの時間、キャッシュ エントリを参照します。 既定値の**CacheTimeout**パラメーターは、3600 (秒単位) または 1 時間です。 キャッシュ エントリが 1 時間以内に参照されていない場合、エントリが削除されることを示します。 場合によっては、値を大きくと役に立つ場合があります、 **CacheTimeout**パフォーマンスを向上させるためにパラメーター。 たとえば、2 時間ごと、ポリシーが呼び出される場合、ポリシー実行のパフォーマンスは向上を増やすことで、 **CacheTimeout**パラメーター値を 2 時間よりも大きくします。  
  
 **PollingInterval**ルール エンジンのパラメーターは、ルール エンジン データベースの更新プログラムをチェックする、更新サービスを秒単位で時間を定義します。 既定値、 **PollingInterval**パラメーターは、60 秒です。 ポリシーがすべての更新はや、ほとんどの更新がわかっている場合は、パフォーマンスを向上させるために高い値をこのパラメーターを変更できます。  
  
## <a name="sideeffects-property"></a>SideEffects プロパティ  
 **ClassMemberBinding**、 **DatabaseColumnBinding**、および**XmlDocumentFieldBinding**クラスという名前のプロパティがある**SideEffects**. このプロパティは、バインドされるフィールド、メンバー、または列の値をキャッシュするかどうかを決定します。 既定値、 **SideEffects**プロパティに、 **DatabaseColumnBinding**と**XmlDocumentFieldBinding**クラスは**false**. 既定値、 **SideEffects**プロパティに、 **ClassMemberBinding**クラスは**true**です。 したがって、XML ドキュメントのフィールドまたはデータベース テーブルの列がポリシー内で 2 回目以降にアクセスされたときには、その値がキャッシュから取得されます。 一方、.NET オブジェクトのメンバーが 2 回目以降にアクセスされたときには、値がキャッシュからではなく .NET オブジェクトから取得されます。 設定、 **SideEffects** .NET のプロパティ**ClassMemberBinding**に**false**からキャッシュから取得したフィールドの値であるために、パフォーマンスが向上します2 回目以降。 この設定は、プログラムでしか行うことができません。 ビジネス ルール作成ツールは公開しません、 **SideEffects**プロパティです。  
  
## <a name="instances-and-selectivity"></a>Instances と selectivity  
 **XmlDocumentBinding**、 **ClassBinding**、および**DatabaseBinding**クラスは、次の 2 つのプロパティを持つ:**インスタンス**と**Selectivity**です。 インスタンスの値は、作業メモリ内のクラスのインスタンスの予期される数です。 値**Selectivity**ルールの条件が正常に送信されるクラスのインスタンスの割合を指定します。 ルール エンジンは、これらの値を使用して、まず最小限のインスタンスが条件の評価に使用され、その後で残りのインスタンスが使用されるように、条件の評価を最適化します。 オブジェクトのインスタンスの数の知識があれば、設定、**インスタンス**プロパティにその値をパフォーマンスが向上します。 同様に、これらのオブジェクト、条件を渡すことの割合の知識があれば、設定、 **Selectivity**プロパティにその値をパフォーマンスが向上します。 これらのパラメーターの値は、プログラムでのみ設定できます。 ビジネス ルール作成ツールでは、これらのパラメーターが公開されません。  
  
## <a name="see-also"></a>参照  
 [BizTalk Server のパフォーマンスを最適化します。](../technical-guides/optimizing-biztalk-server-performance.md)