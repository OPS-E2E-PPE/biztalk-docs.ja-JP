---
title: パイプライン コンポーネントのスキーマの解決 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- pipelines, schema resolution
- pipeline components, schema resolution
- schemas, pipeline components
ms.assetid: 35a79a6f-788b-4ca1-8483-36dcba5ae580
caps.latest.revision: 14
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 9eebb3e1cb4c33d49bacb1353ada164932dae003
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65396921"
---
# <a name="schema-resolution-in-pipeline-components"></a>パイプライン コンポーネントのスキーマの解決
パイプラインの逆アセンブラーおよびアセンブラー コンポーネントでは、XSD スキーマを使用して、メッセージを処理します。 スキーマには、昇格させたプロパティ、識別フィールド、フラット ファイル メッセージでは、注釈、および XML エンベロープの注釈の一覧などの情報が含まれます。  
  
 標準の逆アセンブラーおよびアセンブラー コンポーネントは、スキーマの型名とメッセージ型を使用して展開されたスキーマの取得をサポートします。 一部のコンポーネントは、スキーマの種類でのみ他のユーザー (たとえば、フラット ファイル逆アセンブラー) を取得中に、スキーマの型名と、メッセージの種類の両方を使用して取得します。  
  
 XML メッセージを取得するパイプライン コンポーネントは、メッセージのルート要素および名前空間を調べて、メッセージの種類を判別します。 たとえば、次の XML のメッセージの種類は "<http://MyDocument.org#MyDocument>" 。  
  
```  
<ns0:MyDocument xmlns:ns0="http://MyDocument.org">  
  
</ns0:MyDocument>  
```  
  
 スキーマが定義された名前空間を持たない場合、メッセージの種類は、"\<**rootNode**\>"。 たとえば、上記の XML が名前空間を持たない場合、メッセージの種類は、"MyDocument"をなります。  
  
 標準のパイプライン コンポーネントでは、メッセージの種類を使用して、データベースから適切なスキーマを取得します。 既定の XML の受信し、送信パイプラインが常に動的にメッセージの種類を使用して、読み込むスキーマを検出時に、メッセージから XML コンテンツ (ただし、パイプライン コンポーネントは認識されないメッセージを許可する設定) を決定します。 XML 逆アセンブラーは、このメカニズムでは; を使用してメッセージ エンベロープを削除できます。ただし、XML アセンブラーを使用するエンベロープ スキーマを知らなくても、送信メッセージのエンベロープを作成できません。  
  
 パイプライン デザイナーから、XML アセンブラーの構成のプロパティでエンベロープ スキーマを指定します。  
  
## <a name="how-schemas-are-resolved"></a>スキーマの解決方法  
 XmlDisassembler で直接スキーマが指定されていないと仮定すると、スキーマは、次のように解決されます。  
  
1. 最初に、展開されたスキーマで修飾されていない検索されるルート ノード名と名前空間を使用して (たとえば、 http://MyNamespace#MyRoot)します。 一意の一致には、スキーマが見つかった場合は解決されます。 複数の一致が見られますが、バージョン番号のみが異なる 1 つだけがアクティブな場合は、そのバージョンを使用し、スキーマは解決されます。 同じスキーマが複数のアプリケーションでアクティブな場合は、複数のアクティブなスキーマが検出され、検索は次のステップ 2 に進みます。  
  
2. 手順 1 の複数の一致を解決できない場合は、検索は、アセンブリで、パイプラインの実行によって修飾されます。 一意のスキーマが同じアセンブリ内で見つかった場合、パイプラインを実行し、スキーマは解決されます。  
  
3. ない場合でも、一致するスキーマを解決するのには、パブリッシャーが使用されます。 検索は、ルート ノード、名前空間、および公開キー トークンを使用して絞り込まれます。 この検索を使用して一意のスキーマが見つかった場合、スキーマは解決されます。  
  
4. スキーマを解決できません。 注目する一意のスキーマが見つからない場合、エラーが返されます。  
  
   スキーマの解決には、SQL Server 照合順序の大文字小文字の区別の影響を含むその他の考慮事項を参照してください。 [Namespace 管理](../core/namespace-management.md)します。  
  
   XML アセンブラーまたはヘッダーとトレーラーをフラット ファイル アセンブラーのエンベロープを作成するには、次のいずれかを行うことができます。  
  
- カスタム送信パイプラインを作成し、構成プロパティで、XML アセンブラーのエンベロープのスキーマを指定します。 これについては、パイプライン デザイナーからを行います。  
  
- BizTalk Server 管理コンソールでは、送信ポートで送信パイプライン プロパティに XMLTransmit を指定します。 パイプラインのプロパティを構成し、EnvelopeDocSpecNames プロパティのエンベロープのスキーマを指定する省略記号をクリックします。  
  
  展開する場合、同じスキーマの複数のバージョンは意図的にまたは誤って (サイド バイ サイドで配置の例では、または複数のシナリオには一意のメッセージの種類がないかどうか) 用のデータベースで、メッセージの種類によるスキーマ解決は機能しません。 メッセージの種類によるスキーマ解決が失敗した場合は、「スキーマのあいまいさ」エラーがイベント ログに追加されます。 メッセージの種類によるスキーマ解決が成功したことを確認するには、次のいずれかの操作を行います。  
  
- カスタム パイプラインと同じ BizTalk プロジェクト内のスキーマを定義します。  
  
- パイプラインを含むアセンブリと同じキーで、スキーマを使用したアセンブリに署名します。  
  
- (メッセージ型の名前は一意である BizTalk 管理データベース) のパイプライン コンポーネントで、スキーマを明示的に指定します。  
  
> [!IMPORTANT]
>  あいまいさの解決の制限により、同じパイプライン コンポーネント アセンブリ内のスキーマを含める必要がありますいない、同じアセンブリ内のスキーマは、メッセージの種類を共有する場合代わりに、パイプライン コンポーネント アセンブリの外部スキーマを参照します。 あいまいさの解決は機能しませんスキーマとパイプライン コンポーネントが、同じアセンブリでは、カスタム パイプラインのパイプライン コンポーネントのスキーマの種類名が明示的に指定されている場合でも。  
  
> [!NOTE]
>  使用するカスタム パイプライン コンポーネント**IPipelineContext**展開されたスキーマを取得する必要があります、実行時に、コンポーネントのスキーマの種類名が指定しない場合にのみ、スキーマの種類ごとにスキーマを取得し、メッセージの種類のみでスキーマを取得場合は、コンポーネントの実行時に、スキーマの種類の情報を使用できません。  
  
## <a name="see-also"></a>参照  
 [パイプライン コンポーネント](../core/pipeline-components.md)