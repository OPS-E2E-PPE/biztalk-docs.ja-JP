---
title: "アダプターのデザインに関するヒント |Microsoft ドキュメント"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 0bb60988-4e48-4654-9cf4-512dd7c97239
caps.latest.revision: "9"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 93c59efc2ae811827cd0cb1cf4763485b675f4ea
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
---
# <a name="tips-for-designing-your-adapter"></a>アダプターのデザインに関するヒント
ここでは、アダプターをデザインする間にアダプターの開発者が習得したヒントについて説明します。  
  
## <a name="handler-properties-should-be-strings-if-used-as-default-configurations"></a>既定の構成として使用する場合はハンドラー プロパティを文字列にする  
 既定値として XSD 生成ハンドラー プロパティ シートでプロパティを使用するは便利なよう、**場所**プロパティのため値が設定されていない場合**場所**ランタイムに自動的にハンドラーで設定された値を使用します。 ところが、この方法の利便性を損なういくつかの問題点があります。  
  
 問題の原因は、ランタイムに対して提示される値がオーバーライドされるかどうかが不明であることです。 通常は、値に対して NULL の概念を定義しておき、その値に対してテストを実行します。 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] で XSD ベースのプロパティ シートを使用するときの問題は、NULL は文字列でのみサポートされるということです。 この NULL テストを使用することによってアダプターに既定の設定値を指定し、アダプターの設定の種類を文字列型に制限しようとした場合も、ユーザー インターフェイスが不適切に表示される可能性があります。  
  
 XSD 生成プロパティ シートのみをサポートして、NULL に戻すプロパティの設定をこの時点では、プロパティを右クリックして、**交わした?**コンテキスト メニューが表示され、プロパティを NULL に設定することができます。 プロパティが NULL であるかどうかについての視覚的なフィードバックはありません。  
  
## <a name="considerations-for-implementing-schema-generation-wizards"></a>スキーマ生成ウィザードを実装する際の考慮事項  
 プログラマは、厳密に型指定されたオブジェクト モデルに逆らう形でコードを作成します。 コードで XML を操作するのは、最初のうちは作業しづらく、エラーの発生を招くことがあります。 ただし、コツや .NET Framework によって提供されているサポートを適切に使用することによって、劇的に簡単になることがあります。  
  
#### <a name="do-not-create-xml-documents-with-string-concatenation"></a>文字列連結を使用して XML ドキュメントを作成しない  
 XML に関連する間違いのうち、最も不適切なものの 1 つが、文字列連結とメモリ内の print ステートメントから生成を試みることです。 この処理では、CPU の時間とメモリが大量に消費されます。 最も小さい XML スニペットが対象であっても、XmlWriter またはドキュメント オブジェクト モデル (DOM) のようなツールを使用する方が簡単です。 XmlWriter を使用している場合は、ライターがドキュメントの状態を喪失するため、生の書き込み機能を使用しないでください。  
  
 実行時は、DOM に関連するメモリの高消費量の問題があるため、XML DOM よりも XmlWriter を使用することをお勧めします。 ただし、構成時またはデザイン時には、ほとんどの場合、これは問題になりません。 DOM を使用することによって簡単に XPATH クエリを使用できるようになり、それが便利な追加ツールになる可能性があります。  
  
#### <a name="consider-defining-the-skeleton-of-your-xml-document-as-a-resource"></a>XML ドキュメントのスケルトンをリソースとして定義する際の考慮事項  
 デザイン ツールから大きなサイズの XML ドキュメントを生成し、その生成したドキュメントが常に同じ基本的な構造に従っている場合、スケルトン XML ファイルの全体をプロジェクトのリソースとして配置し、編集が必要なときに変更できるようにすることを検討してください。  
  
 コードを DOM に読み込み、XPATH を使用して追加先とするノードを選択することによって、ドキュメントの骨組みに必要な肉付けを追加します。 この例では、Web サービス記述言語 (WSDL) ファイルを作成します。 ウィザードによって、スケルトンの WSDL ファイルがリソースに保存され、生成された XML スキーマ定義 (XSD) の子の部分が追加されます。 このウィザードでは selectNode と xpath を使用して、正しい親が検索されます。 これはユーザー インターフェイスのコードなので、パフォーマンスは問題にならず、結果として得られる実装は、無駄なく、堅牢で、保守が可能なものになります。  
  
## <a name="consider-placing-processing-steps-in-the-biztalk-pipeline"></a>BizTalk パイプラインで処理手順を配置する際の考慮事項  
 一般的に、Microsoft でビルドされたアダプターは、メッセージ形式をベースにした処理をアダプターから BizTalk パイプラインに移動します。 たとえば、構造化されたものの XML ではないデータ ソースに対するアダプターがその一例です。  
  
 この例では、アダプターはデータだけを取得し、BizTalk パイプラインはそれを解析して XML で該当するものに変換するために使用されます。 利点は、パイプライン コンポーネント自体がアーキテクチャの再利用可能な部分になることです。  
  
## <a name="make-adapter-behavior-configurable"></a>アダプターの動作を構成可能にする  
 MQSeries アダプター ベータ プログラムで得られた教訓の 1 つは、すべてのお客様が同じ動作に満足していたわけではないということでした。 これは、エラーの処理と順序付けについて考える場合に、特に当てはまります。 これに対する解決策は、アダプターの動作を構成可能にすることでした。 アダプターが順序付けをサポートするかどうか、エラーが保留キューに移動されるかどうか、またはエラーによってアダプターが処理を中止してアダプター自体が無効にされるかどうかを指定できます。 このような動作を構成可能にすることによって、複雑なオーケストレーションまたは同じ結果を得るために [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] の外部スクリプトを書く必要がある場合に、お客様の処理を大幅に簡略化できます。  
  
## <a name="support-correlation-with-message-queues"></a>メッセージ キューとの関連付けのサポート  
 多くのメッセージ プラットフォームは、アプリケーション レベルの要求 - 応答シナリオに対応するため、メッセージ ヘッダーの関連付け ID の概念をサポートしています。 たとえば、MQSeries、MSMQ、SQL Service Broker などです。 外部メッセージング システムの要求 - 応答パターンを、[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] の送信 - 応答アダプターにマップするのは便利なように見えます。 ところが、このような考え方は、トランザクションがアクティブな場所が原因で通用しません。 具体的には、外部のメッセージング システムへの送信は、キューの他の末尾のデータを認識する前に、トランザクションのコミットが必要です。 受信も別のトランザクションである必要があります。  
  
 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] での解決策は次のようになります。  
  
-   オーケストレーションで関連付けセットを使用します。  
  
-   2 つの個別のポートを構成する: 送信と受信のいずれかのいずれか  
  
 単純な例では、アダプターによってメッセージに関連付けられている関連付け ID が、オーケストレーションによって指定されます。 これは、メッセージのコンテキスト プロパティとしてアダプターに渡されます。 複雑な場合は、シナリオの外部のメッセージング システム ID を割り当てることの呼び出し ここでは、応答メッセージをオーケストレーションに送信ポートから渡されることができます。 この応答メッセージは、単に ID を戻すだけであり、実際のメッセージ応答ではありません。  
  
> [!NOTE]
>  オーケストレーション エンジンには、メッセージに対する実際の応答が送信からの ID 応答よりも優先される可能性があるような競合状態があります。 この競合状態は、オーケストレーション自体によって処理する必要があります。