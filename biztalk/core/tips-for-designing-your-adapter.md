---
title: アダプターのデザインに関するヒント |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 0bb60988-4e48-4654-9cf4-512dd7c97239
caps.latest.revision: 9
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 306cb2ae9aeca57804a57f0dfa8c1de1bfd0025d
ms.sourcegitcommit: 266308ec5c6a9d8d80ff298ee6051b4843c5d626
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/27/2018
ms.locfileid: "36982683"
---
# <a name="tips-for-designing-your-adapter"></a><span data-ttu-id="b67ed-102">アダプターのデザインに関するヒント</span><span class="sxs-lookup"><span data-stu-id="b67ed-102">Tips for Designing Your Adapter</span></span>
<span data-ttu-id="b67ed-103">ここでは、アダプターをデザインする間にアダプターの開発者が習得したヒントについて説明します。</span><span class="sxs-lookup"><span data-stu-id="b67ed-103">This section contains hints and tips that adapter developers have learned while designing adapters.</span></span>  
  
## <a name="handler-properties-should-be-strings-if-used-as-default-configurations"></a><span data-ttu-id="b67ed-104">既定の構成として使用する場合はハンドラー プロパティを文字列にする</span><span class="sxs-lookup"><span data-stu-id="b67ed-104">Handler Properties Should Be Strings if Used as Default Configurations</span></span>  
 <span data-ttu-id="b67ed-105">既定値として、XSD 生成ハンドラー プロパティ シートでプロパティを使用する魅力的なようですが**場所**プロパティのため、値が設定されていない場合**場所**ランタイム自動的にハンドラーで設定された値を使用します。</span><span class="sxs-lookup"><span data-stu-id="b67ed-105">It seems attractive to use the properties on the XSD-generated handler property sheet as defaults for their **Location** properties because if the value is not set in **Location** the runtime automatically uses the value set in the handler.</span></span> <span data-ttu-id="b67ed-106">ところが、この方法の利便性を損なういくつかの問題点があります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-106">But there are several issues that make this less useful.</span></span>  
  
 <span data-ttu-id="b67ed-107">問題の原因は、ランタイムに対して提示される値がオーバーライドされるかどうかが不明であることです。</span><span class="sxs-lookup"><span data-stu-id="b67ed-107">The problem comes with not knowing whether the value presented to the runtime is to be overridden or not.</span></span> <span data-ttu-id="b67ed-108">通常は、値に対して NULL の概念を定義しておき、その値に対してテストを実行します。</span><span class="sxs-lookup"><span data-stu-id="b67ed-108">The typical way of doing this is to have some notion of NULL defined for values and then run a test against that value.</span></span> <span data-ttu-id="b67ed-109">[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] で XSD ベースのプロパティ シートを使用するときの問題は、NULL は文字列でのみサポートされるということです。</span><span class="sxs-lookup"><span data-stu-id="b67ed-109">The problem when using the XSD-based property sheets in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is that NULL is only supported for strings.</span></span> <span data-ttu-id="b67ed-110">この NULL テストを使用することによってアダプターに既定の設定値を指定し、アダプターの設定の種類を文字列型に制限しようとした場合も、ユーザー インターフェイスが不適切に表示される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-110">Even if you want your adapter to have default settings through the use of this NULL test and are willing to restrict the adapter to string types, it is still exposed to a very odd piece of user interface.</span></span>  
  
 <span data-ttu-id="b67ed-111">XSD 生成プロパティ シートは、この時点では、プロパティを右クリックしてに null の場合、プロパティの設定をサポートするのみ、**交わした?** コンテキスト メニューが表示され、プロパティを NULL に設定することができます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-111">The XSD-generated property sheets only support the setting of a property back to NULL by right-clicking the property, at which point a **nullify?** context menu appears and the property can be set to NULL.</span></span> <span data-ttu-id="b67ed-112">プロパティが NULL であるかどうかについての視覚的なフィードバックはありません。</span><span class="sxs-lookup"><span data-stu-id="b67ed-112">There is no visual feedback as to whether a property is NULL.</span></span>  
  
## <a name="considerations-for-implementing-schema-generation-wizards"></a><span data-ttu-id="b67ed-113">スキーマ生成ウィザードを実装する際の考慮事項</span><span class="sxs-lookup"><span data-stu-id="b67ed-113">Considerations for Implementing Schema Generation Wizards</span></span>  
 <span data-ttu-id="b67ed-114">プログラマは、厳密に型指定されたオブジェクト モデルに逆らう形でコードを作成します。</span><span class="sxs-lookup"><span data-stu-id="b67ed-114">Programmers like to code against strongly typed object models.</span></span> <span data-ttu-id="b67ed-115">コードで XML を操作するのは、最初のうちは作業しづらく、エラーの発生を招くことがあります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-115">Manipulating XML in code can at first seem awkward and prone to error.</span></span> <span data-ttu-id="b67ed-116">ただし、コツや .NET Framework によって提供されているサポートを適切に使用することによって、劇的に簡単になることがあります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-116">But some tricks and smart use of the support offered by the .NET Framework can dramatically simplify matters.</span></span>  
  
#### <a name="do-not-create-xml-documents-with-string-concatenation"></a><span data-ttu-id="b67ed-117">文字列連結を使用して XML ドキュメントを作成しない</span><span class="sxs-lookup"><span data-stu-id="b67ed-117">Do not create XML documents with string concatenation</span></span>  
 <span data-ttu-id="b67ed-118">XML に関連する間違いのうち、最も不適切なものの 1 つが、文字列連結とメモリ内の print ステートメントから生成を試みることです。</span><span class="sxs-lookup"><span data-stu-id="b67ed-118">One of the worst mistakes to make with XML is to try and generate it from string concatenation and print statements in memory.</span></span> <span data-ttu-id="b67ed-119">この処理では、CPU の時間とメモリが大量に消費されます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-119">This consumes large amounts of CPU time and memory.</span></span> <span data-ttu-id="b67ed-120">最も小さい XML スニペットが対象であっても、XmlWriter またはドキュメント オブジェクト モデル (DOM) のようなツールを使用する方が簡単です。</span><span class="sxs-lookup"><span data-stu-id="b67ed-120">Even for the most trivial XML snippet, it is easier to use a tool like XmlWriter or the Document Object Model (DOM).</span></span> <span data-ttu-id="b67ed-121">XmlWriter を使用している場合は、ライターがドキュメントの状態を喪失するため、生の書き込み機能を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="b67ed-121">If you are using XmlWriter, do not use the raw write capability, because the writer loses the state of the document.</span></span>  
  
 <span data-ttu-id="b67ed-122">実行時は、DOM に関連するメモリの高消費量の問題があるため、XML DOM よりも XmlWriter を使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="b67ed-122">At run time, XmlWriter is preferred over the XML DOM because of high memory consumption issues associated with the DOM.</span></span> <span data-ttu-id="b67ed-123">ただし、構成時またはデザイン時には、ほとんどの場合、これは問題になりません。</span><span class="sxs-lookup"><span data-stu-id="b67ed-123">However, at configuration or design time this will most likely not be an issue.</span></span> <span data-ttu-id="b67ed-124">DOM を使用することによって簡単に XPATH クエリを使用できるようになり、それが便利な追加ツールになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-124">Using the DOM facilitates the use of XPATH queries, which can be a useful additional tool.</span></span>  
  
#### <a name="consider-defining-the-skeleton-of-your-xml-document-as-a-resource"></a><span data-ttu-id="b67ed-125">XML ドキュメントのスケルトンをリソースとして定義する際の考慮事項</span><span class="sxs-lookup"><span data-stu-id="b67ed-125">Consider defining the skeleton of your XML document as a resource</span></span>  
 <span data-ttu-id="b67ed-126">デザイン ツールから大きなサイズの XML ドキュメントを生成し、その生成したドキュメントが常に同じ基本的な構造に従っている場合、スケルトン XML ファイルの全体をプロジェクトのリソースとして配置し、編集が必要なときに変更できるようにすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="b67ed-126">If you are generating a large XML document from a design tool and that generated document always follows the same basic structure, consider placing the whole skeletal XML file as a resource in the project to allow making changes when you need to edit it.</span></span>  
  
 <span data-ttu-id="b67ed-127">コードを DOM に読み込み、XPATH を使用して追加先とするノードを選択することによって、ドキュメントの骨組みに必要な肉付けを追加します。</span><span class="sxs-lookup"><span data-stu-id="b67ed-127">Load the code into a DOM and then add the necessary flesh to the bones of the document by using XPATH to pick out the node you want to add it to.</span></span> <span data-ttu-id="b67ed-128">この例では、Web サービス記述言語 (WSDL) ファイルを作成します。</span><span class="sxs-lookup"><span data-stu-id="b67ed-128">In this case, you are creating a Web Services Description Language (WSDL) file.</span></span> <span data-ttu-id="b67ed-129">ウィザードによって、スケルトンの WSDL ファイルがリソースに保存され、生成された XML スキーマ定義 (XSD) の子の部分が追加されます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-129">The wizard stores the skeletal WSDL file in a resource and adds the generated XML Schema Definition (XSD) child parts.</span></span> <span data-ttu-id="b67ed-130">このウィザードでは selectNode と xpath を使用して、正しい親が検索されます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-130">It uses selectNode with an xpath to find the right parent.</span></span> <span data-ttu-id="b67ed-131">これはユーザー インターフェイスのコードなので、パフォーマンスは問題にならず、結果として得られる実装は、無駄なく、堅牢で、保守が可能なものになります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-131">This is user interface code, so performance is not an issue, and the resulting implementation is clean, robust, and maintainable.</span></span>  
  
## <a name="consider-placing-processing-steps-in-the-biztalk-pipeline"></a><span data-ttu-id="b67ed-132">BizTalk パイプラインで処理手順を配置する際の考慮事項</span><span class="sxs-lookup"><span data-stu-id="b67ed-132">Consider Placing Processing Steps in the BizTalk Pipeline</span></span>  
 <span data-ttu-id="b67ed-133">一般的に、Microsoft でビルドされたアダプターは、メッセージ形式をベースにした処理をアダプターから BizTalk パイプラインに移動します。</span><span class="sxs-lookup"><span data-stu-id="b67ed-133">In general the adapters built at Microsoft move message format-based processing out of the adapter and into the BizTalk pipeline.</span></span> <span data-ttu-id="b67ed-134">たとえば、構造化されたものの XML ではないデータ ソースに対するアダプターがその一例です。</span><span class="sxs-lookup"><span data-stu-id="b67ed-134">A good example is an adapter to a structured but non-XML data source.</span></span>  
  
 <span data-ttu-id="b67ed-135">この例では、アダプターはデータだけを取得し、BizTalk パイプラインはそれを解析して XML で該当するものに変換するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-135">In this case, the adapter only gets the data and the BizTalk pipeline is used to parse it and convert it into an XML equivalent.</span></span> <span data-ttu-id="b67ed-136">利点は、パイプライン コンポーネント自体がアーキテクチャの再利用可能な部分になることです。</span><span class="sxs-lookup"><span data-stu-id="b67ed-136">The benefit is that the pipeline component itself becomes a reusable piece of the architecture.</span></span>  
  
## <a name="make-adapter-behavior-configurable"></a><span data-ttu-id="b67ed-137">アダプターの動作を構成可能にする</span><span class="sxs-lookup"><span data-stu-id="b67ed-137">Make Adapter Behavior Configurable</span></span>  
 <span data-ttu-id="b67ed-138">MQSeries アダプター ベータ プログラムで得られた教訓の 1 つは、すべてのお客様が同じ動作に満足していたわけではないということでした。</span><span class="sxs-lookup"><span data-stu-id="b67ed-138">One of the lessons learned from the MQSeries adapter beta program was that not all customers were happy with the same behavior.</span></span> <span data-ttu-id="b67ed-139">これは、エラーの処理と順序付けについて考える場合に、特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-139">This was especially true when it came to handling errors and ordering.</span></span> <span data-ttu-id="b67ed-140">これに対する解決策は、アダプターの動作を構成可能にすることでした。</span><span class="sxs-lookup"><span data-stu-id="b67ed-140">The solution was to make the behavior configurable.</span></span> <span data-ttu-id="b67ed-141">アダプターが順序付けをサポートするかどうか、エラーが保留キューに移動されるかどうか、またはエラーによってアダプターが処理を中止してアダプター自体が無効にされるかどうかを指定できます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-141">You can specify whether the adapter is to support ordering, whether failures are moved to the Suspended queue, or whether they cause the adapter to stop processing and disable itself.</span></span> <span data-ttu-id="b67ed-142">このような動作を構成可能にすることによって、複雑なオーケストレーションまたは同じ結果を得るために [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] の外部スクリプトを書く必要がある場合に、お客様の処理を大幅に簡略化できます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-142">Making such behaviors configurable can significantly simplify customers' lives when they would need to write complex orchestrations or scripts external to [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] to achieve the same result.</span></span>  
  
## <a name="support-correlation-with-message-queues"></a><span data-ttu-id="b67ed-143">メッセージ キューとの関連付けのサポート</span><span class="sxs-lookup"><span data-stu-id="b67ed-143">Support Correlation with Message Queues</span></span>  
 <span data-ttu-id="b67ed-144">多くのメッセージ プラットフォームは、アプリケーション レベルの要求 - 応答シナリオに対応するため、メッセージ ヘッダーの関連付け ID の概念をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b67ed-144">Many messaging platforms support the notion of a correlation ID in the message header to support an application-level request-response scenario.</span></span> <span data-ttu-id="b67ed-145">たとえば、MQSeries、MSMQ、SQL Service Broker などです。</span><span class="sxs-lookup"><span data-stu-id="b67ed-145">Examples include MQSeries, MSMQ, and SQL Service Broker.</span></span> <span data-ttu-id="b67ed-146">外部メッセージング システムの要求 - 応答パターンを、[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] の送信 - 応答アダプターにマップするのは便利なように見えます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-146">It would seem attractive to map the request-response pattern of the external messaging system to a send-response adapter in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)].</span></span> <span data-ttu-id="b67ed-147">ところが、このような考え方は、トランザクションがアクティブな場所が原因で通用しません。</span><span class="sxs-lookup"><span data-stu-id="b67ed-147">However this does not make sense because of where the transactions live.</span></span> <span data-ttu-id="b67ed-148">具体的には、外部のメッセージング システムへの送信は、その他のキューの最後のデータを認識する前に、トランザクションのコミットが必要です。</span><span class="sxs-lookup"><span data-stu-id="b67ed-148">Specifically, a send to the external messaging system requires a transactional commit before the other end of the queue sees the data.</span></span> <span data-ttu-id="b67ed-149">受信も別のトランザクションである必要があります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-149">The receive must also be a separate transaction.</span></span>  
  
 <span data-ttu-id="b67ed-150">[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] での解決策は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-150">The solution in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is to:</span></span>  
  
- <span data-ttu-id="b67ed-151">オーケストレーションで関連付けセットを使用します。</span><span class="sxs-lookup"><span data-stu-id="b67ed-151">Use correlation sets in orchestration</span></span>  
  
- <span data-ttu-id="b67ed-152">2 つの個別のポートを構成します送信と受信のいずれかのいずれか。</span><span class="sxs-lookup"><span data-stu-id="b67ed-152">Configure two separate ports: one for the send and one for the receive</span></span>  
  
  <span data-ttu-id="b67ed-153">単純な例では、アダプターによってメッセージに関連付けられている関連付け ID が、オーケストレーションによって指定されます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-153">In a simple case the orchestration specifies the correlation ID that is associated with the message by the adapter.</span></span> <span data-ttu-id="b67ed-154">これは、メッセージのコンテキスト プロパティとしてアダプターに渡されます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-154">This is passed to the adapter as a context property on the message.</span></span> <span data-ttu-id="b67ed-155">複雑な場合は、シナリオは、外部のメッセージング システム ID を割り当てることの呼び出し</span><span class="sxs-lookup"><span data-stu-id="b67ed-155">In a more complex case, the scenario calls for the external messaging system to allocate the ID.</span></span> <span data-ttu-id="b67ed-156">この場合、応答メッセージをオーケストレーションに送信ポートから渡さすることができます。</span><span class="sxs-lookup"><span data-stu-id="b67ed-156">In this case it can be passed back from the send port to the orchestration with a response message.</span></span> <span data-ttu-id="b67ed-157">この応答メッセージは、単に ID を戻すだけであり、実際のメッセージ応答ではありません。</span><span class="sxs-lookup"><span data-stu-id="b67ed-157">This response message is just to pass back the ID and is not the true message response.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b67ed-158">オーケストレーション エンジンには、メッセージに対する実際の応答が送信からの ID 応答よりも優先される可能性があるような競合状態があります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-158">There is a race condition in the orchestration engine such that the true response to the message could win against the ID response from the send.</span></span> <span data-ttu-id="b67ed-159">この競合状態は、オーケストレーション自体によって処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b67ed-159">This race condition must be handled in the orchestration itself.</span></span>