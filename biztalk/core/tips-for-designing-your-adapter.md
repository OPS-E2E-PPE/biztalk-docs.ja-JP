---
title: アダプターのデザインに関するヒント |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 0bb60988-4e48-4654-9cf4-512dd7c97239
caps.latest.revision: 9
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: d7bbbde2d18aa2c51b3e5331b9028abb0b0332ce
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65399489"
---
# <a name="tips-for-designing-your-adapter"></a><span data-ttu-id="ded25-102">アダプターのデザインに関するヒント</span><span class="sxs-lookup"><span data-stu-id="ded25-102">Tips for Designing Your Adapter</span></span>
<span data-ttu-id="ded25-103">このセクションには、アダプター開発者はアダプターのデザイン中に学んだヒントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="ded25-103">This section contains hints and tips that adapter developers have learned while designing adapters.</span></span>  
  
## <a name="handler-properties-should-be-strings-if-used-as-default-configurations"></a><span data-ttu-id="ded25-104">既定の構成として使用する場合、ハンドラーのプロパティは文字列には</span><span class="sxs-lookup"><span data-stu-id="ded25-104">Handler Properties Should Be Strings if Used as Default Configurations</span></span>  
 <span data-ttu-id="ded25-105">既定値として、XSD 生成ハンドラー プロパティ シートでプロパティを使用する魅力的なようですが**場所**プロパティのため、値が設定されていない場合**場所**ランタイム自動的にハンドラーで設定された値を使用します。</span><span class="sxs-lookup"><span data-stu-id="ded25-105">It seems attractive to use the properties on the XSD-generated handler property sheet as defaults for their **Location** properties because if the value is not set in **Location** the runtime automatically uses the value set in the handler.</span></span> <span data-ttu-id="ded25-106">このいくつかの問題があるに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="ded25-106">But there are several issues that make this less useful.</span></span>  
  
 <span data-ttu-id="ded25-107">この問題をランタイムに提供する値がオーバーライドされるかどうかを把握していないが付属します。</span><span class="sxs-lookup"><span data-stu-id="ded25-107">The problem comes with not knowing whether the value presented to the runtime is to be overridden or not.</span></span> <span data-ttu-id="ded25-108">これを行う一般的な方法は、NULL 値の定義のいくつかの概念があり、その値に対してテストを実行します。</span><span class="sxs-lookup"><span data-stu-id="ded25-108">The typical way of doing this is to have some notion of NULL defined for values and then run a test against that value.</span></span> <span data-ttu-id="ded25-109">XSD ベースのプロパティを使用するときの問題のシート[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]は文字列の NULL がのみサポートされていること。</span><span class="sxs-lookup"><span data-stu-id="ded25-109">The problem when using the XSD-based property sheets in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is that NULL is only supported for strings.</span></span> <span data-ttu-id="ded25-110">この NULL を使用して設定をテストし、文字列型へのアダプターを制限するには既定値を使用して、アダプターをする場合でも、非常に奇妙なユーザー インターフェイスにも公開されます。</span><span class="sxs-lookup"><span data-stu-id="ded25-110">Even if you want your adapter to have default settings through the use of this NULL test and are willing to restrict the adapter to string types, it is still exposed to a very odd piece of user interface.</span></span>  
  
 <span data-ttu-id="ded25-111">XSD 生成プロパティ シートは、この時点では、プロパティを右クリックしてに null の場合、プロパティの設定をサポートするのみ、**交わした?** コンテキスト メニューが表示され、プロパティを NULL に設定することができます。</span><span class="sxs-lookup"><span data-stu-id="ded25-111">The XSD-generated property sheets only support the setting of a property back to NULL by right-clicking the property, at which point a **nullify?** context menu appears and the property can be set to NULL.</span></span> <span data-ttu-id="ded25-112">プロパティが NULL であるかどうか不明視覚的なフィードバックはありません。</span><span class="sxs-lookup"><span data-stu-id="ded25-112">There is no visual feedback as to whether a property is NULL.</span></span>  
  
## <a name="considerations-for-implementing-schema-generation-wizards"></a><span data-ttu-id="ded25-113">スキーマ生成ウィザードの実装に関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="ded25-113">Considerations for Implementing Schema Generation Wizards</span></span>  
 <span data-ttu-id="ded25-114">プログラマは、厳密に型指定されたオブジェクト モデルに対するコードなど。</span><span class="sxs-lookup"><span data-stu-id="ded25-114">Programmers like to code against strongly typed object models.</span></span> <span data-ttu-id="ded25-115">XML を操作するコードで最初に思われ、づらく、間違いが生じやすい。</span><span class="sxs-lookup"><span data-stu-id="ded25-115">Manipulating XML in code can at first seem awkward and prone to error.</span></span> <span data-ttu-id="ded25-116">ただし、コツや .NET Framework で提供されるサポートのスマートな使い方は大幅に簡素化が重要です。</span><span class="sxs-lookup"><span data-stu-id="ded25-116">But some tricks and smart use of the support offered by the .NET Framework can dramatically simplify matters.</span></span>  
  
#### <a name="do-not-create-xml-documents-with-string-concatenation"></a><span data-ttu-id="ded25-117">文字列の連結で XML ドキュメントを作成できません。</span><span class="sxs-lookup"><span data-stu-id="ded25-117">Do not create XML documents with string concatenation</span></span>  
 <span data-ttu-id="ded25-118">Xml に最悪の間違いの 1 つは文字列の連結から生成することを試みるし、メモリ内の print ステートメント。</span><span class="sxs-lookup"><span data-stu-id="ded25-118">One of the worst mistakes to make with XML is to try and generate it from string concatenation and print statements in memory.</span></span> <span data-ttu-id="ded25-119">これにより、大量の CPU 時間とメモリが消費されます。</span><span class="sxs-lookup"><span data-stu-id="ded25-119">This consumes large amounts of CPU time and memory.</span></span> <span data-ttu-id="ded25-120">ごく些細なものの XML スニペットの場合でも XmlWriter またはドキュメント オブジェクト モデル (DOM) などのツールを使いやすくなります。</span><span class="sxs-lookup"><span data-stu-id="ded25-120">Even for the most trivial XML snippet, it is easier to use a tool like XmlWriter or the Document Object Model (DOM).</span></span> <span data-ttu-id="ded25-121">XmlWriter を使用している場合は、ライターがドキュメントの状態を失うので、未加工ボリューム書き込み機能を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="ded25-121">If you are using XmlWriter, do not use the raw write capability, because the writer loses the state of the document.</span></span>  
  
 <span data-ttu-id="ded25-122">実行時に、XmlWriter をお勧め XML DOM に対して高いメモリ消費の問題が DOM に関連付けられているため</span><span class="sxs-lookup"><span data-stu-id="ded25-122">At run time, XmlWriter is preferred over the XML DOM because of high memory consumption issues associated with the DOM.</span></span> <span data-ttu-id="ded25-123">ただし、構成または設計時にこれはほとんどの場合になりません問題。</span><span class="sxs-lookup"><span data-stu-id="ded25-123">However, at configuration or design time this will most likely not be an issue.</span></span> <span data-ttu-id="ded25-124">DOM を使用して、XPATH クエリは、便利な追加ツールは、の使用が容易になります。</span><span class="sxs-lookup"><span data-stu-id="ded25-124">Using the DOM facilitates the use of XPATH queries, which can be a useful additional tool.</span></span>  
  
#### <a name="consider-defining-the-skeleton-of-your-xml-document-as-a-resource"></a><span data-ttu-id="ded25-125">XML ドキュメントのスケルトンをリソースとして定義することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="ded25-125">Consider defining the skeleton of your XML document as a resource</span></span>  
 <span data-ttu-id="ded25-126">デザイン ツールから大きな XML ドキュメントを生成すると、その生成されたドキュメントが常に同じ基本的な構造に従って、それを編集する必要があるときに変更できるようにするプロジェクトではリソースとしてまったくスケルトン XML ファイルを配置することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="ded25-126">If you are generating a large XML document from a design tool and that generated document always follows the same basic structure, consider placing the whole skeletal XML file as a resource in the project to allow making changes when you need to edit it.</span></span>  
  
 <span data-ttu-id="ded25-127">コードを DOM に読み込むしに追加するノードを選択する XPATH を使用して、ドキュメントの骨組みに必要な肉付けを追加します。</span><span class="sxs-lookup"><span data-stu-id="ded25-127">Load the code into a DOM and then add the necessary flesh to the bones of the document by using XPATH to pick out the node you want to add it to.</span></span> <span data-ttu-id="ded25-128">この場合は、Web サービス記述言語 (WSDL) ファイルを作成します。</span><span class="sxs-lookup"><span data-stu-id="ded25-128">In this case, you are creating a Web Services Description Language (WSDL) file.</span></span> <span data-ttu-id="ded25-129">ウィザードでは、リソースのスケルトンの WSDL ファイルを格納し、生成された XML スキーマ定義 (XSD) の子パーツを追加します。</span><span class="sxs-lookup"><span data-stu-id="ded25-129">The wizard stores the skeletal WSDL file in a resource and adds the generated XML Schema Definition (XSD) child parts.</span></span> <span data-ttu-id="ded25-130">Xpath で適切な親を検索 selectNode を使用します。</span><span class="sxs-lookup"><span data-stu-id="ded25-130">It uses selectNode with an xpath to find the right parent.</span></span> <span data-ttu-id="ded25-131">これは、パフォーマンスが問題ではないと、結果として得られる実装は、クリーン、堅牢性、および保守しやすいように、ユーザー インターフェイスのコードです。</span><span class="sxs-lookup"><span data-stu-id="ded25-131">This is user interface code, so performance is not an issue, and the resulting implementation is clean, robust, and maintainable.</span></span>  
  
## <a name="consider-placing-processing-steps-in-the-biztalk-pipeline"></a><span data-ttu-id="ded25-132">BizTalk パイプラインで処理手順を配置することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="ded25-132">Consider Placing Processing Steps in the BizTalk Pipeline</span></span>  
 <span data-ttu-id="ded25-133">一般に Microsoft でビルドされたアダプターはメッセージ形式に基づく処理し、アダプターから BizTalk パイプラインに移動します。</span><span class="sxs-lookup"><span data-stu-id="ded25-133">In general the adapters built at Microsoft move message format-based processing out of the adapter and into the BizTalk pipeline.</span></span> <span data-ttu-id="ded25-134">良い例では、構造化されたが、XML 以外のデータ ソースには、アダプターです。</span><span class="sxs-lookup"><span data-stu-id="ded25-134">A good example is an adapter to a structured but non-XML data source.</span></span>  
  
 <span data-ttu-id="ded25-135">ここでは、アダプターがのみにデータを取得し、BizTalk パイプラインは、解析して、同等の XML に変換するために使用します。</span><span class="sxs-lookup"><span data-stu-id="ded25-135">In this case, the adapter only gets the data and the BizTalk pipeline is used to parse it and convert it into an XML equivalent.</span></span> <span data-ttu-id="ded25-136">利点は、パイプライン コンポーネント自体になるアーキテクチャの再利用可能な部分です。</span><span class="sxs-lookup"><span data-stu-id="ded25-136">The benefit is that the pipeline component itself becomes a reusable piece of the architecture.</span></span>  
  
## <a name="make-adapter-behavior-configurable"></a><span data-ttu-id="ded25-137">アダプターの動作を構成します。</span><span class="sxs-lookup"><span data-stu-id="ded25-137">Make Adapter Behavior Configurable</span></span>  
 <span data-ttu-id="ded25-138">MQSeries アダプター ベータ プログラムから学習した教訓の 1 つは、すべてのお客様が同じ動作に満足ことでした。</span><span class="sxs-lookup"><span data-stu-id="ded25-138">One of the lessons learned from the MQSeries adapter beta program was that not all customers were happy with the same behavior.</span></span> <span data-ttu-id="ded25-139">これは、エラーを処理して、順序付けについて考える場合に特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="ded25-139">This was especially true when it came to handling errors and ordering.</span></span> <span data-ttu-id="ded25-140">ソリューションは、構成可能な動作をすることでした。</span><span class="sxs-lookup"><span data-stu-id="ded25-140">The solution was to make the behavior configurable.</span></span> <span data-ttu-id="ded25-141">アダプターは、エラーは、保留キューに移動するかどうか、または処理を停止および自体を無効にするアダプターが発生するかどうかに、順序付けをサポートするかどうかを指定することができます。</span><span class="sxs-lookup"><span data-stu-id="ded25-141">You can specify whether the adapter is to support ordering, whether failures are moved to the Suspended queue, or whether they cause the adapter to stop processing and disable itself.</span></span> <span data-ttu-id="ded25-142">このような動作を構成可能なことが大幅に簡略化できます顧客の生活がどれほどは複雑なオーケストレーションまたは外部スクリプトを記述する必要がある場合[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]同じ結果を実現します。</span><span class="sxs-lookup"><span data-stu-id="ded25-142">Making such behaviors configurable can significantly simplify customers' lives when they would need to write complex orchestrations or scripts external to [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] to achieve the same result.</span></span>  
  
## <a name="support-correlation-with-message-queues"></a><span data-ttu-id="ded25-143">メッセージ キューとの相関関係をサポートします。</span><span class="sxs-lookup"><span data-stu-id="ded25-143">Support Correlation with Message Queues</span></span>  
 <span data-ttu-id="ded25-144">多くのメッセージング プラットフォームでは、アプリケーション レベルの要求-応答シナリオをサポートするためにメッセージ ヘッダーに相関 ID の概念がサポートします。</span><span class="sxs-lookup"><span data-stu-id="ded25-144">Many messaging platforms support the notion of a correlation ID in the message header to support an application-level request-response scenario.</span></span> <span data-ttu-id="ded25-145">例には、MQSeries、MSMQ、および SQL Service Broker が含まれます。</span><span class="sxs-lookup"><span data-stu-id="ded25-145">Examples include MQSeries, MSMQ, and SQL Service Broker.</span></span> <span data-ttu-id="ded25-146">外部メッセージング システムの要求-応答パターンに送信-応答アダプターにマップする魅力的なように思わ[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]します。</span><span class="sxs-lookup"><span data-stu-id="ded25-146">It would seem attractive to map the request-response pattern of the external messaging system to a send-response adapter in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)].</span></span> <span data-ttu-id="ded25-147">ただし、トランザクションがアクティブな場所により検出されることはありません。</span><span class="sxs-lookup"><span data-stu-id="ded25-147">However this does not make sense because of where the transactions live.</span></span> <span data-ttu-id="ded25-148">具体的には、外部のメッセージング システムへの送信は、その他のキューの最後のデータを認識する前に、トランザクションのコミットが必要です。</span><span class="sxs-lookup"><span data-stu-id="ded25-148">Specifically, a send to the external messaging system requires a transactional commit before the other end of the queue sees the data.</span></span> <span data-ttu-id="ded25-149">受信の個別のトランザクションである必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded25-149">The receive must also be a separate transaction.</span></span>  
  
 <span data-ttu-id="ded25-150">ソリューションは、[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]には。</span><span class="sxs-lookup"><span data-stu-id="ded25-150">The solution in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is to:</span></span>  
  
- <span data-ttu-id="ded25-151">オーケストレーションで関連付けセットを使用します。</span><span class="sxs-lookup"><span data-stu-id="ded25-151">Use correlation sets in orchestration</span></span>  
  
- <span data-ttu-id="ded25-152">2 つの個別のポートを構成します送信と受信のいずれかのいずれか。</span><span class="sxs-lookup"><span data-stu-id="ded25-152">Configure two separate ports: one for the send and one for the receive</span></span>  
  
  <span data-ttu-id="ded25-153">単純なケースでは、オーケストレーションは、アダプターによってメッセージに関連付けられている相関 ID を指定します。</span><span class="sxs-lookup"><span data-stu-id="ded25-153">In a simple case the orchestration specifies the correlation ID that is associated with the message by the adapter.</span></span> <span data-ttu-id="ded25-154">メッセージ コンテキスト プロパティとしてアダプターに渡されます。</span><span class="sxs-lookup"><span data-stu-id="ded25-154">This is passed to the adapter as a context property on the message.</span></span> <span data-ttu-id="ded25-155">複雑な場合は、シナリオは、外部のメッセージング システム ID を割り当てることの呼び出し</span><span class="sxs-lookup"><span data-stu-id="ded25-155">In a more complex case, the scenario calls for the external messaging system to allocate the ID.</span></span> <span data-ttu-id="ded25-156">この場合、応答メッセージをオーケストレーションに送信ポートから渡さすることができます。</span><span class="sxs-lookup"><span data-stu-id="ded25-156">In this case it can be passed back from the send port to the orchestration with a response message.</span></span> <span data-ttu-id="ded25-157">この応答メッセージだけに渡す ID は、実際のメッセージ応答。</span><span class="sxs-lookup"><span data-stu-id="ded25-157">This response message is just to pass back the ID and is not the true message response.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ded25-158">競合状態があるオーケストレーション エンジンで実際の応答メッセージには、送信からの ID 応答に対して獲得こともできるようにします。</span><span class="sxs-lookup"><span data-stu-id="ded25-158">There is a race condition in the orchestration engine such that the true response to the message could win against the ID response from the send.</span></span> <span data-ttu-id="ded25-159">この競合状態は、オーケストレーション自体で処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded25-159">This race condition must be handled in the orchestration itself.</span></span>