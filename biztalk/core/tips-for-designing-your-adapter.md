---
title: アダプターのデザインに関するヒント |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 0bb60988-4e48-4654-9cf4-512dd7c97239
caps.latest.revision: 9
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: d7bbbde2d18aa2c51b3e5331b9028abb0b0332ce
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65399489"
---
# <a name="tips-for-designing-your-adapter"></a>アダプターのデザインに関するヒント
このセクションには、アダプター開発者はアダプターのデザイン中に学んだヒントが含まれています。  
  
## <a name="handler-properties-should-be-strings-if-used-as-default-configurations"></a>既定の構成として使用する場合、ハンドラーのプロパティは文字列には  
 既定値として、XSD 生成ハンドラー プロパティ シートでプロパティを使用する魅力的なようですが**場所**プロパティのため、値が設定されていない場合**場所**ランタイム自動的にハンドラーで設定された値を使用します。 このいくつかの問題があるに役立ちます。  
  
 この問題をランタイムに提供する値がオーバーライドされるかどうかを把握していないが付属します。 これを行う一般的な方法は、NULL 値の定義のいくつかの概念があり、その値に対してテストを実行します。 XSD ベースのプロパティを使用するときの問題のシート[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]は文字列の NULL がのみサポートされていること。 この NULL を使用して設定をテストし、文字列型へのアダプターを制限するには既定値を使用して、アダプターをする場合でも、非常に奇妙なユーザー インターフェイスにも公開されます。  
  
 XSD 生成プロパティ シートは、この時点では、プロパティを右クリックしてに null の場合、プロパティの設定をサポートするのみ、**交わした?** コンテキスト メニューが表示され、プロパティを NULL に設定することができます。 プロパティが NULL であるかどうか不明視覚的なフィードバックはありません。  
  
## <a name="considerations-for-implementing-schema-generation-wizards"></a>スキーマ生成ウィザードの実装に関する考慮事項  
 プログラマは、厳密に型指定されたオブジェクト モデルに対するコードなど。 XML を操作するコードで最初に思われ、づらく、間違いが生じやすい。 ただし、コツや .NET Framework で提供されるサポートのスマートな使い方は大幅に簡素化が重要です。  
  
#### <a name="do-not-create-xml-documents-with-string-concatenation"></a>文字列の連結で XML ドキュメントを作成できません。  
 Xml に最悪の間違いの 1 つは文字列の連結から生成することを試みるし、メモリ内の print ステートメント。 これにより、大量の CPU 時間とメモリが消費されます。 ごく些細なものの XML スニペットの場合でも XmlWriter またはドキュメント オブジェクト モデル (DOM) などのツールを使いやすくなります。 XmlWriter を使用している場合は、ライターがドキュメントの状態を失うので、未加工ボリューム書き込み機能を使用しないでください。  
  
 実行時に、XmlWriter をお勧め XML DOM に対して高いメモリ消費の問題が DOM に関連付けられているため ただし、構成または設計時にこれはほとんどの場合になりません問題。 DOM を使用して、XPATH クエリは、便利な追加ツールは、の使用が容易になります。  
  
#### <a name="consider-defining-the-skeleton-of-your-xml-document-as-a-resource"></a>XML ドキュメントのスケルトンをリソースとして定義することを検討してください。  
 デザイン ツールから大きな XML ドキュメントを生成すると、その生成されたドキュメントが常に同じ基本的な構造に従って、それを編集する必要があるときに変更できるようにするプロジェクトではリソースとしてまったくスケルトン XML ファイルを配置することを検討してください。  
  
 コードを DOM に読み込むしに追加するノードを選択する XPATH を使用して、ドキュメントの骨組みに必要な肉付けを追加します。 この場合は、Web サービス記述言語 (WSDL) ファイルを作成します。 ウィザードでは、リソースのスケルトンの WSDL ファイルを格納し、生成された XML スキーマ定義 (XSD) の子パーツを追加します。 Xpath で適切な親を検索 selectNode を使用します。 これは、パフォーマンスが問題ではないと、結果として得られる実装は、クリーン、堅牢性、および保守しやすいように、ユーザー インターフェイスのコードです。  
  
## <a name="consider-placing-processing-steps-in-the-biztalk-pipeline"></a>BizTalk パイプラインで処理手順を配置することを検討してください。  
 一般に Microsoft でビルドされたアダプターはメッセージ形式に基づく処理し、アダプターから BizTalk パイプラインに移動します。 良い例では、構造化されたが、XML 以外のデータ ソースには、アダプターです。  
  
 ここでは、アダプターがのみにデータを取得し、BizTalk パイプラインは、解析して、同等の XML に変換するために使用します。 利点は、パイプライン コンポーネント自体になるアーキテクチャの再利用可能な部分です。  
  
## <a name="make-adapter-behavior-configurable"></a>アダプターの動作を構成します。  
 MQSeries アダプター ベータ プログラムから学習した教訓の 1 つは、すべてのお客様が同じ動作に満足ことでした。 これは、エラーを処理して、順序付けについて考える場合に特に当てはまります。 ソリューションは、構成可能な動作をすることでした。 アダプターは、エラーは、保留キューに移動するかどうか、または処理を停止および自体を無効にするアダプターが発生するかどうかに、順序付けをサポートするかどうかを指定することができます。 このような動作を構成可能なことが大幅に簡略化できます顧客の生活がどれほどは複雑なオーケストレーションまたは外部スクリプトを記述する必要がある場合[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]同じ結果を実現します。  
  
## <a name="support-correlation-with-message-queues"></a>メッセージ キューとの相関関係をサポートします。  
 多くのメッセージング プラットフォームでは、アプリケーション レベルの要求-応答シナリオをサポートするためにメッセージ ヘッダーに相関 ID の概念がサポートします。 例には、MQSeries、MSMQ、および SQL Service Broker が含まれます。 外部メッセージング システムの要求-応答パターンに送信-応答アダプターにマップする魅力的なように思わ[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]します。 ただし、トランザクションがアクティブな場所により検出されることはありません。 具体的には、外部のメッセージング システムへの送信は、その他のキューの最後のデータを認識する前に、トランザクションのコミットが必要です。 受信の個別のトランザクションである必要があります。  
  
 ソリューションは、[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]には。  
  
- オーケストレーションで関連付けセットを使用します。  
  
- 2 つの個別のポートを構成します送信と受信のいずれかのいずれか。  
  
  単純なケースでは、オーケストレーションは、アダプターによってメッセージに関連付けられている相関 ID を指定します。 メッセージ コンテキスト プロパティとしてアダプターに渡されます。 複雑な場合は、シナリオは、外部のメッセージング システム ID を割り当てることの呼び出し この場合、応答メッセージをオーケストレーションに送信ポートから渡さすることができます。 この応答メッセージだけに渡す ID は、実際のメッセージ応答。  
  
> [!NOTE]
>  競合状態があるオーケストレーション エンジンで実際の応答メッセージには、送信からの ID 応答に対して獲得こともできるようにします。 この競合状態は、オーケストレーション自体で処理する必要があります。