---
title: アトミック トランザクション |Microsoft ドキュメント
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- atomic transactions
- scopes, examples
- transactions, orchestrations
- orchestrations, transactions
- transactions, isolation levels
- transactions, ACID concept
- transactions, examples
- transactions, atomic
- scopes, transactions
- scopes
ms.assetid: 5030e1fd-943f-42bc-9296-4f315bd5f733
caps.latest.revision: 12
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: bc07f379c1f7aa1c846b2c20c19cbfb3393e8174
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
ms.locfileid: "22233546"
---
# <a name="atomic-transactions"></a>アトミック トランザクション
BizTalk オーケストレーションは、トランザクションに関する標準的な 'ACID' の概念に従って個別の作業を実行するように設計できます。 このような個別 (アトミック) の作業単位が実行されると、ビジネス プロセスは一貫性のある 1 つの状態から一貫性と持続性のある新しい状態に移行し、他の作業単位から分離された状態になります。 使用してこれは、通常、**スコープ**トランザクション セマンティクスで作業単位をカプセル化するコンストラクトです。 スコープを使用せずに、オーケストレーション全体をアトミック トランザクションとして定義することもできます。 一方、オーケストレーション自体の設定でトランザクションの種類が長時間トランザクションまたはアトミックに設定されていない限り、スコープをトランザクション スコープとして設定することはできません。 アトミック トランザクションでは、トランザクション更新中にエラーが発生すると部分的な更新は自動的にロールバックされ、トランザクションの影響が除去されます。ただし、トランザクションで行われた .NET 呼び出しの影響は除去されません。 BizTalk オーケストレーションのアトミック トランザクションは、一般に期間が短く、4 つの "ACID" 属性 (原子性、一貫性、分離性、および持続性) を備えている点で、分散トランザクション コーディネーター (DTC) トランザクションに似ています。  
  
-   **原子性**  
  
     トランザクションはアトミックな作業単位を表します。 トランザクション内の変更は、すべて実行されるか、まったく実行されないかのどちらかになります。  
  
-   **整合性**  
  
     トランザクションがコミットされたときにシステム内のデータの整合性が失われないようにする必要があります。 トランザクションで実行されるデータ変更の対象となるデータベースがトランザクションの開始前に内部的な一貫性を有していた場合は、トランザクションのコミット時も内部的な一貫性が保たれなければなりません。 このプロパティの確保を担うのは、主にアプリケーション開発者です。  
  
-   **分離性**  
  
     同時実行トランザクションによって加えられた変更は、その他の同時実行トランザクションによって加えられた変更から分離する必要があります。 独立したトランザクションが複数同時に実行された場合、データベースの内部的な一貫性が損なわれることはありません。これは、トランザクションが順番に実行された場合とまったく同じです。  
  
-   **持続性**  
  
     トランザクションのコミット後、既定では、すべての変更結果がシステム内で持続されます。 システム障害が発生しても、変更結果は保持されます。  
  
 BizTalk オーケストレーションで使用されるアトミック トランザクションでは、次に示す分離レベルがサポートされます。  
  
-   **Read Committed**  
  
     データの読み取り中は、ダーティ リードを避けるために、共有ロックが設定されます。しかし、トランザクションの終了前にデータが変更されることもあるため、繰り返し不能な読み取りやファントム データが発生する可能性があります。  
  
-   **Repeatable Read**  
  
     他のユーザーがデータを更新できないようにするために、クエリで使用するすべてのデータをロックします。 繰り返し不能な読み取りは回避できますが、ファントム行が発生する可能性はあります。  
  
-   **シリアル化可能です**  
  
     範囲ロックが設定され、トランザクションが完了するまで、他のユーザーがデータベースの行の更新や挿入を行うことはできなくなります。  
  
 BizTalk Server では、アトミック トランザクション内の状態の変更-変数、メッセージ、およびオブジェクトへの変更など — トランザクションのコミット時にのみアトミック トランザクションのスコープ外に表示されます。 中間的な状態変更は、オーケストレーションの他の部分から分離されます。  
  
> [!NOTE]
>  アトミック トランザクションが含まれている場合、**受信**図形、**送信**図形、または**オーケストレーションの開始**図形、対応するアクションは行われませんまで、トランザクションがコミットされたとします。  
  
 データの完全な ACID プロパティが必要な場合などのとき、データがあります他のトランザクションから分離 — アトミック トランザクションのみを使用する必要があります。  
  
 アトミック トランザクションが失敗すると、すべての状態がリセットされ、オーケストレーション インスタンスがスコープに入る前の状態に戻ります。 アトミック トランザクションに関して、BizTalk には、(スコープのローカル変数に限らず) すべての変数がトランザクションに参加するというルールがあります。 アトミックなトランザクションで使用されるシリアル化できない変数やメッセージはすべてスコープのローカルで宣言する必要があります。ローカルで宣言されていない場合は、コンパイル時に "変数... はシリアル化可能として設定されていません。" というエラーが発生します。 すべてのアトミックのスコープは「同期」と見なされ、オーケストレーション コンパイラは、実際にアトミックのスコープには、同期済みのキーワードが使用する場合、冗長な使用法に関する警告が指定します。 共有データの同期は、スコープの先頭からスコープが正常に完了するまで (スコープの末尾における状態の永続化を含む)、または例外ハンドラーの処理が完了するまで (エラーの場合)、継続されます。 補正ハンドラーは同期ドメインには含まれません。  
  
 アトミック トランザクションは、タイムアウト値に関連付けることができます。タイムアウト値に達すると、オーケストレーションによってトランザクションが停止され、インスタンスが中断されます。 アトミック トランザクションに受信図形、送信図形、またはオーケストレーションの開始図形が含まれている場合、対応するアクションはトランザクションがコミットされるまで実行されません。  
  
 アトミック トランザクションの再試行、ユーザーが意図的をスローするとき、 **RetryTransactionException**場合や、 **PersistenceException**がアトミックのトランザクションがコミットを試行する時に発生します。 後者は、アトミック トランザクションが分散 DTC トランザクションの一部であり、そのトランザクションの他の参加要素によってトランザクションが停止された場合などに発生する可能性があります。 同様に、トランザクションがコミットしようとした時にデータベース接続の問題があった場合も用意してあります、 **PersistenceException**発生します。 これには、アトミックのスコープを持つ場合**を再試行してください = True**、再試行されます 21 回までです。 再試行の間隔は、既定では 2 秒になっています (この間隔は変更できます)。 21 再試行が終了して、トランザクションがコミットすることができない場合後、は、オーケストレーション インスタンス全体が中断されます。 中断されたオーケストレーション インスタンスは手動で再開できます。カウンターはリセットされ、問題が発生したアトミックのスコープの先頭から再実行されます。  
  
> [!NOTE]
>  のみ、 **RetryTransactionException**と**PersistenceException**アトミックのスコープを再試行する可能性があります。 アトミックのスコープで発生したその他の例外が原因では、再試行する場合でも、**を再試行してください**プロパティに設定されている**True**です。 パブリック プロパティを使用して、それぞれ 2 つの連続する再試行の間の 2 秒間の既定の遅延をオーバーライドできます**RetryTransactionException** (かどうかは例外となる再試行に使用されている)。  
  
 アトミックのスコープがあるその他のトランザクションを入れ子やを含めることができない他のトランザクションの入れ子に関する制限**例外のキャッチ**ブロックします。  
  
## <a name="dtc-transactions"></a>DTC トランザクション  
 アトミック トランザクションは DTC トランザクションと同じように動作しますが、既定では明示的な DTC トランザクションではありません。 トランザクション内で使用されているオブジェクトが System.EnterpriseServices.ServicedComponents から派生した COM+ オブジェクトであり、分離レベルがトランザクション コンポーネント間で一致している場合は、明示的に DTC トランザクションにすることができます。  
  
> [!NOTE]
>  アトミック トランザクションに他のトランザクションを含めたり、例外ハンドラーを含めたりすることはできません。  
  
> [!NOTE]
>  アトミック トランザクションが一致する送信が含まれてことはできず、受信アクション — を要求-応答の組み合わせや、送信および受信を同じ関連付けセットを使用します。  
  
## <a name="non-serializable-objects"></a>非シリアル化できるオブジェクト  
 オーケストレーション内でシリアル化できないオブジェクトを使用する場合は、必ずアトミック トランザクション内で使用する必要があります。 シリアル化できないオブジェクトをアトミック トランザクションの外部で使用すると、オーケストレーションがエンジンによって永続化されるたびにデータ損失のリスクが発生します。  
  
> [!CAUTION]
>  アトミックのスコープはそれぞれ永続化ポイントを表します。これは、永続化ポイントに達するたびにオーケストレーションの状態がデータベースに保存されることを意味します。 アトミックのスコープを幅広く使用には、オーケストレーションでの待機時間が増加します。 シリアル化できないオブジェクトの作成には、アトミックのスコープの代わりに静的なメソッド呼び出しを使用できます。静的なメソッド呼び出しはアトミックのスコープを必要としないため、永続化ポイントは不要になります。  
  
## <a name="see-also"></a>参照  
 [アトミック トランザクションの使用シナリオ](../core/scenarios-using-atomic-transactions.md)   
 [実行時間の長いトランザクション](../core/long-running-transactions.md)