---
title: アトミック トランザクション |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- atomic transactions
- scopes, examples
- transactions, orchestrations
- orchestrations, transactions
- transactions, isolation levels
- transactions, ACID concept
- transactions, examples
- transactions, atomic
- scopes, transactions
- scopes
ms.assetid: 5030e1fd-943f-42bc-9296-4f315bd5f733
caps.latest.revision: 12
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 8319f93d4e03dfde94b1cb3b9d099470592b1893
ms.sourcegitcommit: 266308ec5c6a9d8d80ff298ee6051b4843c5d626
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/27/2018
ms.locfileid: "36986843"
---
# <a name="atomic-transactions"></a>アトミック トランザクション
BizTalk オーケストレーションは、トランザクションに関する標準的な 'ACID' の概念に従って個別の作業を実行するように設計できます。 このような個別 (アトミック) の作業単位が実行されると、ビジネス プロセスは一貫性のある 1 つの状態から一貫性と持続性のある新しい状態に移行し、他の作業単位から分離された状態になります。 使用してこれは、通常、**スコープ**コンストラクトをトランザクション セマンティクスで作業単位をカプセル化します。 スコープを使用せずに、オーケストレーション全体をアトミック トランザクションとして定義することもできます。 一方、オーケストレーション自体の設定でトランザクションの種類が長時間トランザクションまたはアトミックに設定されていない限り、スコープをトランザクション スコープとして設定することはできません。 アトミック トランザクションでは、トランザクション更新中にエラーが発生すると部分的な更新は自動的にロールバックされ、トランザクションの影響が除去されます。ただし、トランザクションで行われた .NET 呼び出しの影響は除去されません。 BizTalk オーケストレーションのアトミック トランザクションは、一般に期間が短く、4 つの "ACID" 属性 (原子性、一貫性、分離性、および持続性) を備えている点で、分散トランザクション コーディネーター (DTC) トランザクションに似ています。  
  
- **原子性**  
  
   トランザクションはアトミックな作業単位を表します。 トランザクション内の変更は、すべて実行されるか、まったく実行されないかのどちらかになります。  
  
- **一貫性**  
  
   トランザクションがコミットされたときにシステム内のデータの整合性が失われないようにする必要があります。 トランザクションで実行されるデータ変更の対象となるデータベースがトランザクションの開始前に内部的な一貫性を有していた場合は、トランザクションのコミット時も内部的な一貫性が保たれなければなりません。 このプロパティの確保を担うのは、主にアプリケーション開発者です。  
  
- **分離性**  
  
   同時実行トランザクションによって加えられた変更は、その他の同時実行トランザクションによって加えられた変更から分離する必要があります。 独立したトランザクションが複数同時に実行された場合、データベースの内部的な一貫性が損なわれることはありません。これは、トランザクションが順番に実行された場合とまったく同じです。  
  
- **持続性**  
  
   トランザクションのコミット後、既定では、すべての変更結果がシステム内で持続されます。 システム障害が発生しても、変更結果は保持されます。  
  
  BizTalk オーケストレーションで使用されるアトミック トランザクションでは、次に示す分離レベルがサポートされます。  
  
- **Read Committed**  
  
   データの読み取り中は、ダーティ リードを避けるために、共有ロックが設定されます。しかし、トランザクションの終了前にデータが変更されることもあるため、繰り返し不能な読み取りやファントム データが発生する可能性があります。  
  
- **Repeatable Read**  
  
   他のユーザーがデータを更新できないようにするために、クエリで使用するすべてのデータをロックします。 繰り返し不能な読み取りは回避できますが、ファントム行が発生する可能性はあります。  
  
- **SERIALIZABLE**  
  
   範囲ロックが設定され、トランザクションが完了するまで、他のユーザーがデータベースの行の更新や挿入を行うことはできなくなります。  
  
  BizTalk Server では、アトミック トランザクション内の状態の変更-変数、メッセージ、およびオブジェクトの変更など、トランザクションのコミット時にのみアトミック トランザクションのスコープ外に表示されます。 中間的な状態変更は、オーケストレーションの他の部分から分離されます。  
  
> [!NOTE]
>  アトミックのトランザクションが含まれている場合、**受信**、図形、**送信**図形、または**オーケストレーションの開始**図形を対応するアクションは行われませんまで、トランザクションがコミットされます。  
  
 データの完全な ACID プロパティが必要な場合: たとえば、ときに、データがあります他のトランザクションから分離-アトミック トランザクションを排他的に使用する必要があります。  
  
 アトミック トランザクションが失敗すると、すべての状態がリセットされ、オーケストレーション インスタンスがスコープに入る前の状態に戻ります。 アトミック トランザクションに関して、BizTalk には、(スコープのローカル変数に限らず) すべての変数がトランザクションに参加するというルールがあります。 アトミックなトランザクションで使用されるシリアル化できない変数やメッセージはすべてスコープのローカルで宣言する必要があります。ローカルで宣言されていない場合は、コンパイル時に "変数... はシリアル化可能として設定されていません。" というエラーが発生します。 すべてのアトミックのスコープは「同期」と見なされ、オーケストレーション コンパイラは、実際にアトミックのスコープには、同期済みのキーワードが使用する場合、冗長な使用量は、警告は提供します。 共有データの同期は、スコープの先頭からスコープが正常に完了するまで (スコープの末尾における状態の永続化を含む)、または例外ハンドラーの処理が完了するまで (エラーの場合)、継続されます。 補正ハンドラーは同期ドメインには含まれません。  
  
 アトミック トランザクションは、タイムアウト値に関連付けることができます。タイムアウト値に達すると、オーケストレーションによってトランザクションが停止され、インスタンスが中断されます。 アトミック トランザクションに受信図形、送信図形、またはオーケストレーションの開始図形が含まれている場合、対応するアクションはトランザクションがコミットされるまで実行されません。  
  
 アトミック トランザクションの再試行、ユーザーが意図的に例外をスロー、 **RetryTransactionException**場合や、 **PersistenceException**がアトミックのトランザクションがコミットを試行する時に発生します。 後者は、アトミック トランザクションが分散 DTC トランザクションの一部であり、そのトランザクションの他の参加要素によってトランザクションが停止された場合などに発生する可能性があります。 同様に、トランザクションがコミットしようとした時点でデータベース接続の問題があった場合にも、 **PersistenceException**発生します。 アトミックのスコープを持つのこのような場合**再試行 = True**、21 回まで再試行されます。 再試行の間隔は、既定では 2 秒になっています (この間隔は変更できます)。 トランザクションがコミットすることができない場合、21 の再試行が終了は後、は、オーケストレーション インスタンス全体が中断されます。 中断されたオーケストレーション インスタンスは手動で再開できます。カウンターはリセットされ、問題が発生したアトミックのスコープの先頭から再実行されます。  
  
> [!NOTE]
>  のみ、 **RetryTransactionException**と**PersistenceException**アトミックのスコープが再試行が発生することができます。 アトミックのスコープで発生したその他の例外が発生することはできません、再試行は、場合でも、**再試行**プロパティに設定されて**True**します。 それぞれ 2 つの連続する再試行間隔の 2 秒間の既定のパブリック プロパティを使用してオーバーライドできます**RetryTransactionException** (かどうかある再試行の発生に使用されている例外)。  
  
 アトミックのスコープが他のトランザクションを入れ子にやを含めることができない他のトランザクションの入れ子に関する制限がある**例外のキャッチ**ブロックします。  
  
## <a name="dtc-transactions"></a>DTC トランザクション  
 アトミック トランザクションは DTC トランザクションと同じように動作しますが、既定では明示的な DTC トランザクションではありません。 トランザクション内で使用されているオブジェクトが System.EnterpriseServices.ServicedComponents から派生した COM+ オブジェクトであり、分離レベルがトランザクション コンポーネント間で一致している場合は、明示的に DTC トランザクションにすることができます。  
  
> [!NOTE]
>  アトミック トランザクションに他のトランザクションを含めたり、例外ハンドラーを含めたりすることはできません。  
  
> [!NOTE]
>  アトミックのトランザクションが一致する送信を含むことはできず、受信アクション-は、要求-応答の組み合わせまたは送信を受信する同じ関連付けセットを使用します。  
  
## <a name="non-serializable-objects"></a>非シリアル化可能なオブジェクト  
 オーケストレーション内でシリアル化できないオブジェクトを使用する場合は、必ずアトミック トランザクション内で使用する必要があります。 シリアル化できないオブジェクトをアトミック トランザクションの外部で使用すると、オーケストレーションがエンジンによって永続化されるたびにデータ損失のリスクが発生します。  
  
> [!CAUTION]
>  アトミックのスコープはそれぞれ永続化ポイントを表します。これは、永続化ポイントに達するたびにオーケストレーションの状態がデータベースに保存されることを意味します。 アトミックのスコープの広範な使用には、オーケストレーションでの待機時間が増加します。 シリアル化できないオブジェクトの作成には、アトミックのスコープの代わりに静的なメソッド呼び出しを使用できます。静的なメソッド呼び出しはアトミックのスコープを必要としないため、永続化ポイントは不要になります。  
  
## <a name="see-also"></a>参照  
 [アトミック トランザクションの使用シナリオ](../core/scenarios-using-atomic-transactions.md)   
 [長時間トランザクション](../core/long-running-transactions.md)