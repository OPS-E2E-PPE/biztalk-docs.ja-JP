---
title: パフォーマンスの高いアダプターを設計する方法 |Microsoft ドキュメント
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: b5a1f338-fd7c-41c8-a181-8da8b293c4cc
caps.latest.revision: 15
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: e7958968809dc224a3446ac81f3f89d08f6128a0
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
ms.locfileid: "22250538"
---
# <a name="how-to-design-a-performant-adapter"></a><span data-ttu-id="6cfc1-102">パフォーマンスの高いアダプターをデザインする方法</span><span class="sxs-lookup"><span data-stu-id="6cfc1-102">How to Design a Performant Adapter</span></span>
<span data-ttu-id="6cfc1-103">アダプターのパフォーマンスを確保するには、すべてのアダプターを、メッセージのバッチの送信、バッチの転送、およびバッチ単位での一般的なメッセージ操作を実行可能なバッチ対応にしておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-103">For performance purposes all adapters should be batch-aware with regard to submitting batches of messages, transmitting batches, and generally performing operations on messages in batches.</span></span> <span data-ttu-id="6cfc1-104">また、アダプターのパフォーマンス関連の属性 (バッチのサイズやバッチ内のバイト数など) をできる限り構成可能な属性として公開し、アダプターのデザイン時ユーザー インターフェイスで構成できるようにします。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-104">Adapters should try to expose configurable performance-related attributes, such as the size of batches or the number of bytes in a batch, that are configurable from the adapter's design-time user interface.</span></span>  
  
 <span data-ttu-id="6cfc1-105">前述したように、送信ホストのパフォーマンス低下を避けるため、送信アダプターは常に非ブロッキング送信を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-105">As mentioned earlier, send adapters should always perform non-blocking sends to avoid degrading the performance of the send host.</span></span> <span data-ttu-id="6cfc1-106">メッセージング エンジン API をさらにブロックすることはお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-106">Further blocking of Messaging Engine APIs is not recommended.</span></span>  
  
 <span data-ttu-id="6cfc1-107">メッセージ コンテキストの書き込みと読み取りは、実行時のパフォーマンスに影響します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-107">Writing to and reading from the message context affects run-time performance.</span></span> <span data-ttu-id="6cfc1-108">通常は、アダプターでメッセージ コンテキスト プロパティの読み取り、書き込み、および昇格が発生しすぎないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-108">In general, adapters should avoid reading, writing, and promoting excessive numbers of message-context properties.</span></span> <span data-ttu-id="6cfc1-109">プロパティを昇格させると、昇格させたプロパティごとに実行時にサブスクリプションの評価が行われるため、パフォーマンスがさらに低下します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-109">Promoting properties creates an additional performance drain because of the subscription evaluation that occurs on each promoted property at run time.</span></span> <span data-ttu-id="6cfc1-110">アダプターで昇格させるプロパティの数が膨大にならない限りパフォーマンスに著しい影響が及ぶことはありませんが、</span><span class="sxs-lookup"><span data-stu-id="6cfc1-110">However, an adapter would need to promote a huge number of properties to noticeably impact performance.</span></span> <span data-ttu-id="6cfc1-111">昇格の必要なプロパティに限定して昇格させることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-111">Still it is a good practice to promote only those properties that are required to be promoted.</span></span>  
  
## <a name="throttle-send-and-receive"></a><span data-ttu-id="6cfc1-112">送信と受信の制限</span><span class="sxs-lookup"><span data-stu-id="6cfc1-112">Throttle Send and Receive</span></span>  
 <span data-ttu-id="6cfc1-113">BizTalk エンジンの負荷がしきい値の構成値を超えると、最適なパフォーマンスを確保するためにエンジンによってアダプターとオーケストレーションが制限されます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-113">When the load on the BizTalk engine exceeds the configured threshold, the engine throttles adapters and orchestrations to ensure optimum performance.</span></span> <span data-ttu-id="6cfc1-114">エンジンの作業負荷がアダプターの呼び出しを指定されたしきい値を超えた場合、受信側で**IBTTransportBatch.Done**は負荷が十分に減少するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-114">On the receive side, when the workload on the engine exceeds a given threshold, the adapter's call to **IBTTransportBatch.Done** is blocked until the load has decreased sufficiently.</span></span> <span data-ttu-id="6cfc1-115">これにより、アダプターからエンジンに新しい作業が送信されるのは、エンジンが使用可能な場合に限られることになります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-115">This forces the adapter to submit new work into the engine only when the engine is available.</span></span> <span data-ttu-id="6cfc1-116">送信側では、アダプターによる送信メッセージの送信がエンジンによって制限されている場合は、負荷が減少するまで、エンジンから新たな送信メッセージが配信されなくなります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-116">On the send side, when the engine is throttling adapters sending outbound messages, the engine does not deliver new messages to be transmitted until its load is reduced.</span></span>  
  
 <span data-ttu-id="6cfc1-117">このため、バックエンド システムへの接続数を制限するなどの必要が生じない限り、アダプターでの制限を考慮する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-117">For these reasons, the adapter does not need to be concerned with throttling unless it is required, for example, to limit the number of connections to a back-end system.</span></span> <span data-ttu-id="6cfc1-118">このようなシナリオについて、エンジンおよびアダプター フレームワークにおけるサポートは提供されていません。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-118">For these types of scenarios, neither the engine nor the Adapter Framework provides any support.</span></span>  
  
 <span data-ttu-id="6cfc1-119">カスタム送信アダプターから送信されるメッセージの数を制限するには、アダプターのソース コードを制御するかどうかに応じていくつかの方法があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-119">You can handle throttling the number of messages sent from a custom send adapter in several ways depending on whether you control the source code for the adapter.</span></span>  
  
### <a name="send-side-throttling-improves-performance"></a><span data-ttu-id="6cfc1-120">送信側の制限によるパフォーマンス向上</span><span class="sxs-lookup"><span data-stu-id="6cfc1-120">Send-Side Throttling Improves Performance</span></span>  
 <span data-ttu-id="6cfc1-121">アダプターのソース コードを制御する場合は、いつでも送信できるようキューに格納するメッセージの最大数をヒューリスティックによって決定できます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-121">If you control the source code for the adapter, you can determine from heuristics the maximum number of messages that you want to have in the queue to send at any time.</span></span> <span data-ttu-id="6cfc1-122">メッセージング エンジンを呼び出すと、`TransmitMessage`メソッドおよびパス、送信アダプターが新しいメッセージできますブロックを選択するか、スレッドまたはキュー内のメッセージの数があらかじめ定義した最大値より大きいかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-122">When the Messaging Engine calls the `TransmitMessage` method and passes the send adapter a new message, you can choose to either block the thread or check to see if the number of messages in the queue is larger than the maximum value you determined previously.</span></span> <span data-ttu-id="6cfc1-123">メッセージの最大数を超過したを使って、`Resubmit`メッセージング エンジンにメッセージを再送信する方法です。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-123">If the maximum number of messages has been exceeded, you can use the `Resubmit` method to resubmit the message to the Messaging Engine.</span></span> <span data-ttu-id="6cfc1-124">同期アダプターの場合、メッセージはそれ以前にブロックされます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-124">Note that if the adapter is synchronous, the message would already be blocked.</span></span>  
  
 <span data-ttu-id="6cfc1-125">変更することによってキューに置かれたメッセージの数を変更するには、アダプターのソース コードを制御しない場合、 **Highwatermark** BizTalk 管理データベースの Adm_serviceclass テーブル内の値。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-125">If you do not control the source code for the adapter, you can change the number of queued messages by changing the **Highwatermark** value in the Adm_serviceclass table in the BizTalk Management database.</span></span> <span data-ttu-id="6cfc1-126">最大値、 **Highwatermark**プロパティは 200 です。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-126">The maximum value for the **Highwatermark** property is 200.</span></span> <span data-ttu-id="6cfc1-127">値を変更することも、**低**プロパティ値を小さくします。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-127">You can also change the value for the **Lowwatermark** property to a smaller value.</span></span>  
  
 <span data-ttu-id="6cfc1-128">注意しての値、 **Highwatermark**メッセージング エンジンがアダプターに指定されたメッセージの数のアカウントを非同期アダプターのプロパティです。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-128">Remember that the value of the **Highwatermark** property for asynchronous adapters accounts for the number of messages that the Messaging Engine has given to the adapter.</span></span> <span data-ttu-id="6cfc1-129">メッセージング エンジンからアダプターに渡します、`TransmitMessage`メソッド、これらのメッセージの伝送で未解決のままにすることができます: たとえば、アダプターが対応する呼び出しを行っていない場合、 `DeleteMessage`、 `Resubmit`、 `MoveToNextTransport`、または[Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx)メソッドです。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-129">The Messaging Engine passes them to the adapter through the `TransmitMessage` method, These messages can be still outstanding in their transmission—for example, if the adapter has not made a corresponding call to the `DeleteMessage`, `Resubmit`, `MoveToNextTransport`, or [Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx) methods.</span></span> <span data-ttu-id="6cfc1-130">同期アダプターの場合、 **Highwatermark**プロパティが、メッセージング エンジンから渡されたでアダプターを使用してメッセージの数のアカウントのみ、 **TransmitMessage**メソッドのためこの呼び出し呼び出し元のメッセージング エンジン スレッドをブロックして同期的に処理します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-130">For synchronous adapters, the **Highwatermark** property only accounts for the number of messages the Messaging Engine has passed to the adapter by using the **TransmitMessage** method because this call processes synchronously, blocking the calling Messaging Engine thread.</span></span>  
  
 <span data-ttu-id="6cfc1-131">本質的に低速なプロトコル (HTTP、FTP、双方向の SOAP など) の送信アダプターを作成する場合は、次の点を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-131">If you are writing a send adapter for a protocol that is inherently slow in nature (such as HTTP, FTP, or two-way SOAP), consider the following:</span></span>  
  
-   <span data-ttu-id="6cfc1-132">BizTalk メッセージング エンジンから送信されるメッセージをアダプターで受信する速度が、送信可能な速度を上回る可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-132">Such an adapter might receive messages for transmission from the BizTalk Messaging Engine faster than it can transmit them.</span></span> <span data-ttu-id="6cfc1-133">この速度の差は、さまざまなレベルの問題の原因になります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-133">This discrepancy causes problems at various levels.</span></span> <span data-ttu-id="6cfc1-134">送信中のメッセージがメモリに残って仮想メモリが占有され、システム全体の処理速度が低下します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-134">The messages under transmission remain in memory and take up the virtual memory, slowing down the entire system.</span></span>  
  
-   <span data-ttu-id="6cfc1-135">アダプターは、プロトコル固有のリソースをかかる場合があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-135">The adapter might take up protocol-specific resources.</span></span> <span data-ttu-id="6cfc1-136">たとえば、サーバーに対して多数の同時接続が行われると、リモート サーバーの処理が低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-136">For example, it might open too many concurrent connections to the server, which could disrupt the remote server.</span></span>  
  
-   <span data-ttu-id="6cfc1-137">他のアダプターにも影響が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-137">The adapter might affect other adapters.</span></span> <span data-ttu-id="6cfc1-138">たとえば、特定のアダプターに対する多数のメッセージがキューに保存されると、メッセージング エンジンはそのプロセスの他の送信アダプターに対する要求の発行を停止します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-138">For example, if too many messages queue up for a particular adapter, the Messaging Engine stops issuing requests to other send adapters in that process.</span></span>  
  
 <span data-ttu-id="6cfc1-139">解決方法としては、低速のアダプターと高速のアダプターを異なる BizTalk ホストに配置し、"High Watermark" および "Low Watermark" の設定を使用してメッセージの数を制御する方法があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-139">A solution is to put the slow and fast adapters in separate BizTalk Hosts and control the number of messages by using the "High Watermark" and "Low Watermark" settings.</span></span>  
  
### <a name="receive-side-throttling-improves-performance"></a><span data-ttu-id="6cfc1-140">受信側の制限によるパフォーマンス向上</span><span class="sxs-lookup"><span data-stu-id="6cfc1-140">Receive-Side Throttling Improves Performance</span></span>  
 <span data-ttu-id="6cfc1-141">受信アダプターのメッセージ受信速度が、システムの他の部分におけるメッセージ処理速度を上回る状況は多数存在します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-141">There are numerous situations in which a receive adapter receives messages faster than the rate at which the rest of the system can process the messages.</span></span> <span data-ttu-id="6cfc1-142">このような状況では、メッセージ ボックス データベースでバックログが発生します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-142">When such a situation occurs, the MessageBox database becomes backlogged.</span></span> <span data-ttu-id="6cfc1-143">この場合、システム全体のパフォーマンスが大幅に低下します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-143">When this happens, the performance of the whole system drops dramatically.</span></span>  
  
 <span data-ttu-id="6cfc1-144">アダプターでこの現象が発生した場合は、次のいずれかの方法で受信アダプターの速度を下げることができます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-144">If this is happening with your adapter, you can use one of the following techniques to reduce the speed of the receive adapter:</span></span>  
  
-   <span data-ttu-id="6cfc1-145">メッセージング エンジンのスレッド プールのサイズを小さくします。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-145">Reduce the Messaging Engine thread pool size.</span></span> <span data-ttu-id="6cfc1-146">メッセージをメッセージ ボックスに公開するためにメッセージング エンジンが使用するスレッドの数を制御することができます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-146">You can control the number of threads that the Messaging Engine uses to publish messages into the MessageBox.</span></span> <span data-ttu-id="6cfc1-147">スレッドの数を減らすことで、受信アダプターがメッセージ ボックスにメッセージを取り込む速度を下げることができます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-147">By reducing the number of threads, you reduce the rate at which the receive adapter receives messages into the MessageBox.</span></span> <span data-ttu-id="6cfc1-148">この設定を適用する必要があるのは、アダプターの受信ハンドラーに対応するホストのみです。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-148">This setting only needs to be done for the host corresponding to the receive handler for the adapter.</span></span> <span data-ttu-id="6cfc1-149">送信アダプターの速度も下げる必要がある場合を除き、アダプターの送信ハンドラーに対応するホストにはこの設定を適用しないでください。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-149">You should not set this for the host corresponding to the send handler for the adapter, unless you want to slow down the send adapter as well.</span></span>  
  
-   <span data-ttu-id="6cfc1-150">アダプターのバッチ サイズを小さくします。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-150">Reduce the adapter batch size.</span></span> <span data-ttu-id="6cfc1-151">高速の受信アダプターの大多数は、メッセージをバッチ単位でメッセージ ボックスに公開します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-151">Most fast receive adapters publish messages to the MessageBox in batches.</span></span> <span data-ttu-id="6cfc1-152">通常、これらのバッチのサイズは受信場所のプロパティ ページで構成できます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-152">The size of these batches is usually configurable in the receive location property page.</span></span> <span data-ttu-id="6cfc1-153">バッチ サイズを小さくすることで、システムに入ってくるメッセージ全体のスループットを下げることができます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-153">By decreasing the batch size you can decrease the overall throughput of messages coming into the system.</span></span>  
  
-   <span data-ttu-id="6cfc1-154">その他のアダプター固有の設定を変更します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-154">Change other adapter-specific settings.</span></span> <span data-ttu-id="6cfc1-155">上記の 2 つの手順が完了したら、アダプターの他のパラメーターを調整することでスループットをさらに下げられるかどうか試してみます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-155">After you complete the two previous steps, you can try adjusting other adapter parameters to further decrease throughput.</span></span> <span data-ttu-id="6cfc1-156">アダプターの中には、スループットを下げるために使用できる内部パラメーターを公開しているものがあります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-156">Some adapters expose internal parameters that can be used to decrease throughput.</span></span> <span data-ttu-id="6cfc1-157">たとえば、MQSeries アダプターには "順次配送" に関する設定があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-157">For example, the MQSeries adapter has a setting for “Ordered Delivery.”</span></span> <span data-ttu-id="6cfc1-158">順次配送とは、アダプターがメッセージのバッチを 1 つずつ公開し、1 つのバッチの処理が完了するのを待って次のバッチを公開することを示します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-158">Ordered Delivery specifies that the adapter will publish a batch of messages, wait for it to complete, and then publish the next batch.</span></span> <span data-ttu-id="6cfc1-159">この設定を有効にすると、該当する受信アダプターでは実質的に並列処理が行われなくなります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-159">By enabling this setting, you essentially remove all parallelism from the receive adapter.</span></span> <span data-ttu-id="6cfc1-160">逆に、パラメーターを逆方向に調整することで、受信アダプターの受信速度を上げることもできます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-160">Conversely, tuning the parameters in the opposite way can be used to increase the receiving rate of a receive adapter.</span></span>  
  
 <span data-ttu-id="6cfc1-161">アダプターは、必要な数だけバッチをトランスポート プロキシに送信できます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-161">An adapter can submit as many batches as required to the transport proxy.</span></span> <span data-ttu-id="6cfc1-162">ときに、システム大きな負荷がかかってへの呼び出し、**完了**のメソッド、 **IBTTransportBatch**インターフェイス システムに必要なリソースが解放されるまでメッセージがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-162">When the system is heavily stressed, a call to the **Done** method of the **IBTTransportBatch** interface will block the message until the required resources are released to the system.</span></span>  
  
## <a name="plan-for-asynchronous-receive-and-send"></a><span data-ttu-id="6cfc1-163">非同期の送受信への対応</span><span class="sxs-lookup"><span data-stu-id="6cfc1-163">Plan for Asynchronous Receive and Send</span></span>  
 <span data-ttu-id="6cfc1-164">BizTalk Server メッセージング API には、非同期プログラミングをサポートするさまざまな機能があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-164">The BizTalk Server messaging APIs have rich support for asynchronous programming.</span></span> <span data-ttu-id="6cfc1-165">スケーラブルなアダプターを作成するには、当初から同時実行性の高い非同期モデルの使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-165">If you want to write a scalable adapter, plan on using the asynchronous model from the start because the asynchronous model provides better concurrency.</span></span>  
  
 <span data-ttu-id="6cfc1-166">アダプターは、BizTalk メッセージング エンジンにメッセージのバッチを送信すると、受信側で (を呼び出して**ibttransportbatch::done**)、メッセージング エンジンが、内部スレッド プールを使用して作業をキューに配置し、直ちに返されます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-166">On the receive side, when an adapter submits a batch of messages to the BizTalk Messaging Engine (by calling **IBTTransportBatch::Done**), the Messaging Engine queues up the work using its internal thread pool and returns immediately.</span></span> <span data-ttu-id="6cfc1-167">エンジンはメッセージを別のスレッドで処理するため、アダプターはソースからさらにメッセージを読み取って、前のメッセージの処理が完了するのを待たずに送信することができます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-167">The engine processes the messages on a separate thread, leaving the adapter free to read more messages from its source and submit them without waiting for the previous message processing to complete.</span></span>  
  
 <span data-ttu-id="6cfc1-168">送信側のアダプターは非同期でも同期でもかまいません。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-168">On the send side, your adapter can be either asynchronous or synchronous.</span></span> <span data-ttu-id="6cfc1-169">ただし、プロトコルで非同期操作がサポートされている場合は、そのサポートを利用してスケーラブルなアダプターを作成するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-169">However, if your protocol supports asynchronous operations, you should use this support to write a scalable adapter.</span></span> <span data-ttu-id="6cfc1-170">たとえば、ファイル送信アダプターと HTTP 送信アダプターは完全に非同期であり、ブロック操作や同期操作はほとんど実行されません。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-170">For example, File and HTTP send adapters are fully asynchronous and they perform very few blocking/synchronous operations.</span></span>  
  
 <span data-ttu-id="6cfc1-171">非同期操作では、メッセージング エンジンとアダプターの両方の作業が並行して続行されるようになっており、通常のメッセージ処理で相互の作業完了を待機することはありません。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-171">Asynchronous operations ensure that both the Messaging Engine and your adapter will continue to do their respective work in parallel and not wait on each other for normal message processing.</span></span>  
  
## <a name="use-batching-to-improve-performance"></a><span data-ttu-id="6cfc1-172">バッチ処理によるパフォーマンス向上</span><span class="sxs-lookup"><span data-stu-id="6cfc1-172">Use Batching to Improve Performance</span></span>  
 <span data-ttu-id="6cfc1-173">スケーラブルなアダプターを作成するには、まずバッチ処理から取り組むのが最も有効です。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-173">Batching is the best starting point for writing a scalable adapter.</span></span> <span data-ttu-id="6cfc1-174">これは、送信側と受信側の両方のアダプターに該当します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-174">This is true for both send-side and receive-side adapters.</span></span> <span data-ttu-id="6cfc1-175">アダプターが非トランザクション アダプターであっても、各バッチは BizTalk Server 内のデータベース トランザクションで処理されます。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-175">Every batch goes through a database transaction within BizTalk Server even if your adapter is nontransactional.</span></span> <span data-ttu-id="6cfc1-176">トランザクションごとに一定の遅延が発生するため、複数の操作を 1 つのバッチにまとめることによってトランザクションの数を最小限に抑える必要があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-176">Because there is a fixed delay associated with each transaction, you should try to minimize the number of transactions by combining more than one operation into a single batch.</span></span>  
  
## <a name="do-not-starve-the-net-thread-pool"></a><span data-ttu-id="6cfc1-177">.NET スレッド プールの枯渇の回避</span><span class="sxs-lookup"><span data-stu-id="6cfc1-177">Do Not Starve the .NET Thread Pool</span></span>  
 <span data-ttu-id="6cfc1-178">BizTalk アダプターの作成は .NET ランタイム コードの記述の一環であり、.NET ランタイム コードの記述は常に非同期プログラミングの一環です。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-178">Writing BizTalk adapters is an exercise in writing .NET runtime code; writing .NET runtime code is invariably an exercise in asynchronous programming.</span></span>  
  
 <span data-ttu-id="6cfc1-179">.NET における非同期プログラミングには .NET スレッド プールの枯渇のリスクが生じます。このリスクを回避することは BizTalk アダプターのプログラマにとって特に重要です。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-179">Starving the .NET thread pool is a risk to all asynchronous programming in .NET, and it is particularly important for the BizTalk adapter programmer to avoid.</span></span>  
  
 <span data-ttu-id="6cfc1-180">.NET スレッド プールは、限られたリソースでありながら広く共有されています。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-180">The .NET thread pool is a limited but widely shared resource.</span></span> <span data-ttu-id="6cfc1-181">.NET スレッド プールのスレッドの 1 つを使用して長時間保持し、他の作業項目の実行をブロックするコードを書くのは簡単です。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-181">It is easy to write code that uses one of the .NET thread pool threads and holds onto it for long time, blocking other work items from being executed.</span></span>  
  
 <span data-ttu-id="6cfc1-182">使用するたびに**BeginInvoke**またはタイマーを使用して、.NET スレッド プールのスレッドを使用しています。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-182">Whenever you use **BeginInvoke** or use a timer, you are using a .NET thread pool thread.</span></span> <span data-ttu-id="6cfc1-183">複数の作業を行うにがある場合 (たとえば BizTalk Server にメッセージを MQSeries からをコピーする)、する必要があります実行 1 つの作業アイテム (BizTalk Server にメッセージの 1 つのバッチ) し、requeue スレッド プールで作業をすることがある場合。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-183">If you have multiple pieces of work to do (for example copying messages out of MQSeries into BizTalk Server), you should execute one work item (one batch of messages into BizTalk Server) and then requeue in the thread pool if there is more work to do.</span></span> <span data-ttu-id="6cfc1-184">配置しないで、`while`ループでスレッドです。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-184">Never sit in a `while` loop on the thread.</span></span>  
  
 <span data-ttu-id="6cfc1-185">具体的に言うつまり交換`while`ループを繰り返し呼び出すの**BeginInvoke**です。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-185">In concrete terms this means replacing `while` loops with repeated calls to **BeginInvoke**.</span></span> <span data-ttu-id="6cfc1-186">この単純な変更により、実装全体の応答性と拡張性が大幅に向上する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-186">This simple change can dramatically improve the responsiveness and scale-out ability for the whole implementation.</span></span>  
  
## <a name="choose-the-right-measurement-when-limiting-batch-size"></a><span data-ttu-id="6cfc1-187">バッチ サイズの制限に適した単位の選択</span><span class="sxs-lookup"><span data-stu-id="6cfc1-187">Choose the Right Measurement When Limiting Batch Size</span></span>  
 <span data-ttu-id="6cfc1-188">メッセージをバッチ単位で BizTalk Server に送信する場合、メッセージ数のみに基づいてバッチ サイズを制限しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-188">If you are submitting messages to BizTalk Server in batches, do not limit the batch size based only on the message count.</span></span> <span data-ttu-id="6cfc1-189">メッセージ数のみに基づくバッチ アダプターが構成されているときの動作を検討してください: 2 つのバッチ サイズは、アダプターの 4 つのメッセージを取得する場合、それぞれ 4 KB、8 KB、1 MB、および 5 MB のサイズは、最初のバッチになりますサイズは 12 KB、、2 番目のバッチでは 6 MB のサイズを変更します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-189">Consider what happens when an adapter has been configured to batch based only on message count: If the batch size is two and the adapter gets four messages of size 4 KB, 8 KB, 1 MB, and 5MB respectively, the first batch will be of size 12 KB, and the second batch will be of size 6 MB.</span></span>  
  
 <span data-ttu-id="6cfc1-190">BizTalk メッセージング エンジンは各バッチのすべてのメッセージを順に処理するため、この例の 2 つ目のバッチの処理速度は 1 つ目のバッチに比べて大幅に低下します。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-190">Because the BizTalk Messaging Engine processes all messages in a single batch sequentially, the second batch in this example will be processed much more slowly than the first batch.</span></span> <span data-ttu-id="6cfc1-191">これは実質的にスループットの低下をもたらします。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-191">This is effectively reducing throughput.</span></span> <span data-ttu-id="6cfc1-192">このような問題への対処としては、バッチのメッセージ数と合計バイト数 (バイト単位のバッチ サイズ) の両方に基づくバッチ処理の方が優れています。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-192">A better way to handle this problem is to batch based on both message count and total bytes in the batch (that is, batch size in bytes).</span></span> <span data-ttu-id="6cfc1-193">適切な合計バイト数は場合によって異なりますが、</span><span class="sxs-lookup"><span data-stu-id="6cfc1-193">There is no magic number for total bytes.</span></span> <span data-ttu-id="6cfc1-194">通常の処理シナリオでは、バッチ サイズが 1 MB を超えると同時実行性とスループットの低下が始まります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-194">However, in a normal processing scenario, if the batch size exceeds 1 MB, you will start seeing poor concurrency and throughput.</span></span>  
  
 <span data-ttu-id="6cfc1-195">一般に、アダプターではメッセージは区別されず、実稼働環境でのメッセージのサイズは認識されません。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-195">Generally adapters are message agnostic and they do not know the size of the messages in the production environment.</span></span> <span data-ttu-id="6cfc1-196">通常、受信メッセージによってサイズは大幅に異なります。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-196">The sizes of the incoming messages are likely to vary significantly.</span></span> <span data-ttu-id="6cfc1-197">このため、常にメッセージ数と合計バイト数に基づいてバッチを作成するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="6cfc1-197">Because of this, always use message count and total bytes to build the batch.</span></span>