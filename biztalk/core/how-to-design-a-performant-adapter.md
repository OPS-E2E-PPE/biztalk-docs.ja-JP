---
title: パフォーマンスの高いアダプターを設計する方法 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: b5a1f338-fd7c-41c8-a181-8da8b293c4cc
caps.latest.revision: 15
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 4175732cc9896789a0a101cc6e8f6f028d19dc3b
ms.sourcegitcommit: 266308ec5c6a9d8d80ff298ee6051b4843c5d626
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/27/2018
ms.locfileid: "36970243"
---
# <a name="how-to-design-a-performant-adapter"></a>パフォーマンスの高いアダプターをデザインする方法
アダプターのパフォーマンスを確保するには、すべてのアダプターを、メッセージのバッチの送信、バッチの転送、およびバッチ単位での一般的なメッセージ操作を実行可能なバッチ対応にしておく必要があります。 また、アダプターのパフォーマンス関連の属性 (バッチのサイズやバッチ内のバイト数など) をできる限り構成可能な属性として公開し、アダプターのデザイン時ユーザー インターフェイスで構成できるようにします。  
  
 前述したように、送信ホストのパフォーマンス低下を避けるため、送信アダプターは常に非ブロッキング送信を行う必要があります。 メッセージング エンジン API をさらにブロックすることはお勧めしません。  
  
 メッセージ コンテキストの書き込みと読み取りは、実行時のパフォーマンスに影響します。 通常は、アダプターでメッセージ コンテキスト プロパティの読み取り、書き込み、および昇格が発生しすぎないようにする必要があります。 プロパティを昇格させると、昇格させたプロパティごとに実行時にサブスクリプションの評価が行われるため、パフォーマンスがさらに低下します。 アダプターで昇格させるプロパティの数が膨大にならない限りパフォーマンスに著しい影響が及ぶことはありませんが、 昇格の必要なプロパティに限定して昇格させることをお勧めします。  
  
## <a name="throttle-send-and-receive"></a>送信と受信の制限  
 BizTalk エンジンの負荷がしきい値の構成値を超えると、最適なパフォーマンスを確保するためにエンジンによってアダプターとオーケストレーションが制限されます。 エンジンのワークロードが、アダプターの呼び出しに指定されたしきい値を超えたときに、受信側で**IBTTransportBatch.Done**負荷が十分に減少するまでブロックされます。 これにより、アダプターからエンジンに新しい作業が送信されるのは、エンジンが使用可能な場合に限られることになります。 送信側では、アダプターによる送信メッセージの送信がエンジンによって制限されている場合は、負荷が減少するまで、エンジンから新たな送信メッセージが配信されなくなります。  
  
 このため、バックエンド システムへの接続数を制限するなどの必要が生じない限り、アダプターでの制限を考慮する必要はありません。 このようなシナリオについて、エンジンおよびアダプター フレームワークにおけるサポートは提供されていません。  
  
 カスタム送信アダプターから送信されるメッセージの数を制限するには、アダプターのソース コードを制御するかどうかに応じていくつかの方法があります。  
  
### <a name="send-side-throttling-improves-performance"></a>送信側の制限によるパフォーマンス向上  
 アダプターのソース コードを制御する場合は、いつでも送信できるようキューに格納するメッセージの最大数をヒューリスティックによって決定できます。 メッセージング エンジンを呼び出すと、`TransmitMessage`メソッドを呼び出し、新しいメッセージを送信アダプターか、以前に決定した最大値よりも大きい場合は、キュー内のメッセージの数を表示するか、またはスレッドをブロックする選択できます。 メッセージの最大数が超過した場合は使用できます、`Resubmit`メッセージング エンジンにメッセージを再送信する方法。 同期アダプターの場合、メッセージはそれ以前にブロックされます。  
  
 変更することによってキューに置かれたメッセージの数を変更するには、アダプターのソース コードを制御しない場合、 **Highwatermark** BizTalk 管理データベースの Adm_serviceclass テーブル内の値。 最大値、 **Highwatermark**プロパティは 200 です。 値を変更することも、**低レベルのウォーターマーク**プロパティ値を小さくします。  
  
 注意の値、 **Highwatermark**メッセージング エンジンがアダプターに指定されたメッセージの数のアカウントを非同期アダプターのプロパティ。 メッセージング エンジンからアダプターに渡します、`TransmitMessage`メソッドでは、これらのメッセージを送信をまだ未処理になる可能性 — たとえば、アダプターが対応する呼び出しを行っていない場合、 `DeleteMessage`、 `Resubmit`、 `MoveToNextTransport`、または[Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx)メソッド。 同期アダプターの場合、 **Highwatermark**のみを使用してアダプターに渡すがメッセージング エンジンは、メッセージの数のアカウントのプロパティ、 **TransmitMessage**メソッドのため、この呼び出し呼び出し元のメッセージング エンジン スレッドをブロックして同期的に処理します。  
  
 本質的に低速なプロトコル (HTTP、FTP、双方向の SOAP など) の送信アダプターを作成する場合は、次の点を考慮してください。  
  
- BizTalk メッセージング エンジンから送信されるメッセージをアダプターで受信する速度が、送信可能な速度を上回る可能性があります。 この速度の差は、さまざまなレベルの問題の原因になります。 送信中のメッセージがメモリに残って仮想メモリが占有され、システム全体の処理速度が低下します。  
  
- アダプターは、プロトコル固有のリソースをかかる場合があります。 たとえば、サーバーに対して多数の同時接続が行われると、リモート サーバーの処理が低下することがあります。  
  
- 他のアダプターにも影響が生じる可能性があります。 たとえば、特定のアダプターに対する多数のメッセージがキューに保存されると、メッセージング エンジンはそのプロセスの他の送信アダプターに対する要求の発行を停止します。  
  
  解決方法としては、低速のアダプターと高速のアダプターを異なる BizTalk ホストに配置し、"High Watermark" および "Low Watermark" の設定を使用してメッセージの数を制御する方法があります。  
  
### <a name="receive-side-throttling-improves-performance"></a>受信側の制限によるパフォーマンス向上  
 受信アダプターのメッセージ受信速度が、システムの他の部分におけるメッセージ処理速度を上回る状況は多数存在します。 このような状況では、メッセージ ボックス データベースでバックログが発生します。 この場合、システム全体のパフォーマンスが大幅に低下します。  
  
 アダプターでこの現象が発生した場合は、次のいずれかの方法で受信アダプターの速度を下げることができます。  
  
- メッセージング エンジンのスレッド プールのサイズを小さくします。 メッセージをメッセージ ボックスに公開するためにメッセージング エンジンが使用するスレッドの数を制御することができます。 スレッドの数を減らすことで、受信アダプターがメッセージ ボックスにメッセージを取り込む速度を下げることができます。 この設定を適用する必要があるのは、アダプターの受信ハンドラーに対応するホストのみです。 送信アダプターの速度も下げる必要がある場合を除き、アダプターの送信ハンドラーに対応するホストにはこの設定を適用しないでください。  
  
- アダプターのバッチ サイズを小さくします。 高速の受信アダプターの大多数は、メッセージをバッチ単位でメッセージ ボックスに公開します。 通常、これらのバッチのサイズは受信場所のプロパティ ページで構成できます。 バッチ サイズを小さくすることで、システムに入ってくるメッセージ全体のスループットを下げることができます。  
  
- その他のアダプター固有の設定を変更します。 上記の 2 つの手順が完了したら、アダプターの他のパラメーターを調整することでスループットをさらに下げられるかどうか試してみます。 アダプターの中には、スループットを下げるために使用できる内部パラメーターを公開しているものがあります。 たとえば、MQSeries アダプターには "順次配送" に関する設定があります。 順次配送とは、アダプターがメッセージのバッチを 1 つずつ公開し、1 つのバッチの処理が完了するのを待って次のバッチを公開することを示します。 この設定を有効にすると、該当する受信アダプターでは実質的に並列処理が行われなくなります。 逆に、パラメーターを逆方向に調整することで、受信アダプターの受信速度を上げることもできます。  
  
  アダプターは、必要な数だけバッチをトランスポート プロキシに送信できます。 ときに、システム大きな負荷がかかってへの呼び出し、**完了**のメソッド、 **IBTTransportBatch**インターフェイス メッセージがシステムに必要なリソースが解放されるまでブロックされます。  
  
## <a name="plan-for-asynchronous-receive-and-send"></a>非同期の送受信への対応  
 BizTalk Server メッセージング API には、非同期プログラミングをサポートするさまざまな機能があります。 スケーラブルなアダプターを作成するには、当初から同時実行性の高い非同期モデルの使用を検討してください。  
  
 アダプターが BizTalk メッセージング エンジンにメッセージのバッチを送信すると、受信側で (を呼び出して**ibttransportbatch::done**)、メッセージング エンジンは、その内部スレッド プールを使用して作業をキューに配置しが直ちに返されます。 エンジンはメッセージを別のスレッドで処理するため、アダプターはソースからさらにメッセージを読み取って、前のメッセージの処理が完了するのを待たずに送信することができます。  
  
 送信側のアダプターは非同期でも同期でもかまいません。 ただし、プロトコルで非同期操作がサポートされている場合は、そのサポートを利用してスケーラブルなアダプターを作成するようにしてください。 たとえば、ファイル送信アダプターと HTTP 送信アダプターは完全に非同期であり、ブロック操作や同期操作はほとんど実行されません。  
  
 非同期操作では、メッセージング エンジンとアダプターの両方の作業が並行して続行されるようになっており、通常のメッセージ処理で相互の作業完了を待機することはありません。  
  
## <a name="use-batching-to-improve-performance"></a>バッチ処理によるパフォーマンス向上  
 スケーラブルなアダプターを作成するには、まずバッチ処理から取り組むのが最も有効です。 これは、送信側と受信側の両方のアダプターに該当します。 アダプターが非トランザクション アダプターであっても、各バッチは BizTalk Server 内のデータベース トランザクションで処理されます。 トランザクションごとに一定の遅延が発生するため、複数の操作を 1 つのバッチにまとめることによってトランザクションの数を最小限に抑える必要があります。  
  
## <a name="do-not-starve-the-net-thread-pool"></a>.NET スレッド プールの枯渇の回避  
 BizTalk アダプターの作成は .NET ランタイム コードの記述の一環であり、.NET ランタイム コードの記述は常に非同期プログラミングの一環です。  
  
 .NET における非同期プログラミングには .NET スレッド プールの枯渇のリスクが生じます。このリスクを回避することは BizTalk アダプターのプログラマにとって特に重要です。  
  
 .NET スレッド プールは、限られたリソースでありながら広く共有されています。 .NET スレッド プールのスレッドの 1 つを使用して長時間保持し、他の作業項目の実行をブロックするコードを書くのは簡単です。  
  
 使用するたびに**BeginInvoke**またはタイマーを使用して、.NET スレッド プールのスレッドを使用しています。 複数の処理を行うがある場合 (たとえば BizTalk Server にメッセージを MQSeries からをコピーする)、する必要があります実行 1 つの作業項目 (BizTalk Server にメッセージの 1 つのバッチ) し requeue スレッド プールで作業をすることがある場合します。 占有しないように、`while`スレッドでループします。  
  
 具体的に言うことを意味`while`ループを繰り返し呼び出すの**BeginInvoke**します。 この単純な変更により、実装全体の応答性と拡張性が大幅に向上する可能性があります。  
  
## <a name="choose-the-right-measurement-when-limiting-batch-size"></a>バッチ サイズの制限に適した単位の選択  
 メッセージをバッチ単位で BizTalk Server に送信する場合、メッセージ数のみに基づいてバッチ サイズを制限しないようにしてください。 メッセージ数のみに基づくバッチをアダプターが構成されている場合の動作を検討してください: 2 つのバッチ サイズは、アダプターの 4 つのメッセージを取得する場合、それぞれ 4 KB、8 KB 1 MB 5 MB のサイズのられる最初のバッチ サイズは 12 KB、2 番目のバッチには 6 MB のサイズを変更します。  
  
 BizTalk メッセージング エンジンは各バッチのすべてのメッセージを順に処理するため、この例の 2 つ目のバッチの処理速度は 1 つ目のバッチに比べて大幅に低下します。 これは実質的にスループットの低下をもたらします。 このような問題への対処としては、バッチのメッセージ数と合計バイト数 (バイト単位のバッチ サイズ) の両方に基づくバッチ処理の方が優れています。 適切な合計バイト数は場合によって異なりますが、 通常の処理シナリオでは、バッチ サイズが 1 MB を超えると同時実行性とスループットの低下が始まります。  
  
 一般に、アダプターではメッセージは区別されず、実稼働環境でのメッセージのサイズは認識されません。 通常、受信メッセージによってサイズは大幅に異なります。 このため、常にメッセージ数と合計バイト数に基づいてバッチを作成するようにしてください。