---
title: アダプターの障害を処理する方法 |Microsoft ドキュメント
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: bdceb364-38d6-4aab-a176-bf751da1be25
caps.latest.revision: 12
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 94ce45dbf8fcc46c952ddd5ccf7ed45e633641a4
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
ms.locfileid: "22255930"
---
# <a name="how-to-handle-adapter-failures"></a>アダプターのエラーを処理する方法
アダプターでは通常、処理できないメッセージを中断します。 たとえば、受信アダプターで送信エラーが発生した場合は通常、メッセージを中断します。ただし、この判断はアダプターの目的によって変わることがあります。 エラーを処理するときには、セキュリティの問題も考慮する必要があります。 たとえば、失敗したメッセージをすべてアダプターで自動的に中断すると、そのアダプターはサービス拒否攻撃に対して脆弱になり、BizTalk Server の保留キューがいっぱいになる可能性があります。  HTTP アダプターなど一部のアダプターでは、要求が拒否されたことを示すエラー コードをクライアントに返すことができます。 こうした種類のアダプターでは、多くの場合、メッセージを中断するよりもエラー コードを返す方が有効です。 送信アダプターでは通常、プライマリ トランスポートとセカンダリ トランスポートの両方で、再試行回数が設定値を超えた後ではじめてメッセージを中断します。  
  
## <a name="associate-error-processing-with-an-individual-operation-and-not-with-the-batch-that-contains-the-operation"></a>操作を含むバッチではなく、個々の操作にエラー処理を関連付ける  
 アダプターでのメッセージのバッチ処理は、アダプターのユーザーに見えないところで実行し、 バッチ内の操作の 1 つが失敗しても他の操作に影響が生じないようにする必要があります。 しかし、バッチはアトミックであるため、1 つのメッセージでエラーが発生するとバッチのエラーとなり、操作は処理されなくなります。  
  
 したがって、エラーが発生したときに処理するコードを記述し、正常なメッセージを再送信して失敗したメッセージを中断するよう指定する必要があります。 BizTalk Server では詳細なエラー構造が提供されるので、アダプターでは失敗した操作を特定できます。 これを基に、正常な操作を再実行し失敗した操作を中断するバッチをさらに構築できます。  
  
 アダプター内のバッチ処理によって、操作の最終的な状態が影響を受けないようにしてください。  
  
## <a name="use-seterrorinfo-to-report-failure-to-biztalk-server"></a>SetErrorInfo を使用して BizTalk Server にエラーを報告する  
 メッセージを中断する場合は、その前のメッセージ コンテキストから BizTalk Server にエラー情報を送信する必要があります。 BizTalk Server は、エラー レポート機能を使用して、 **SetErrorInfo**両方のメソッド、 **IBaseMessage**と**ITransportProxy**インターフェイスです。 エラーを報告するには次の方法を使用できます。  
  
-   メッセージの処理中に、障害が発生したときに設定を使用して例外**SetErrorInfo (Exception e)** メッセージ (**IBaseMessage**) が中断されます。 こうすると、エンジンではメッセージと共にエラーが保持され、後の診断に使用できます。また、イベント ログにエラーが記録され、管理者はエラーを認識できます。  
  
-   中ではないメッセージの処理) 初期化または内部ブックキーピング中にエラーが発生した場合を呼び出す必要があります**SetErrorInfo (Exception e)** 上、 **ITransportProxy**に渡されたポインター初期化中にします。 アダプターが BaseAdapter 実装を基にしている場合は、このポインターに常にアクセスできるようにしておく必要があります。 そうでない場合は、ポインターをキャッシュしておくようにします。  
  
 どちらの方法でも、エラーが報告されると、イベント ログにエラー メッセージが書き込まれます。 エラーとそのメッセージを関連付けることができる場合は、必ず関連付けを行ってください。  
  
## <a name="handle-a-database-offline-condition"></a>データベースがオフラインになった場合の処理  
 BizTalk Server データベースの 1 つがオフラインになった場合、BizTalk サービスは自身を再利用します。 メッセージング エンジンは、サービスが再利用される前にすべての受信場所のシャットダウンをあらゆる方法で試行しますが、 この処理が 60 秒以上かかるとサービスは終了します。 エンジンのトランザクションは行われるので、データの損失は起こりません。  
  
 タイムアウトはレジストリで次のキーを使用して設定できます。  
  
```  
DWORD   
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTSSvc{Host Guid}\MessagingDBFailoverShutdownTimeLimit  
```  
  
 分離アダプターの場合はプロセスの所有者が BizTalk Server ではないため、BizTalk Server データベースの 1 つがオフラインになると受信場所は無効になります。 これらの受信場所は、データベースがオンラインに戻った後で再度有効になります。  
  
## <a name="write-to-the-event-log"></a>イベント ログへの書き込み  
 使用して、アダプターがイベント ログ エントリを書き込むことができます、 **IBTTransportProxy**例外を渡すインターフェイス。 ネイティブ コードで開発されたアダプターを渡す必要があります、 **IErrorInfo**インターフェイス、 **IBTTransportProxy.SetErrorInfo (例外** `e` **)** です。  
  
 送信エラー後にアダプターでメッセージの送信を再試行したり、アダプターのバックアップ トランスポートにメッセージを移動したり、メッセージを中断するときなどは、メッセージング エンジンがアダプターに代わってイベント ログへの書き込みを行います。 このような場合、アダプターで必要になる操作は、API の呼び出し前にメッセージに例外を設定することだけです。 このコード例の一部を次に示します。  
  
```  
IBaseMessage msg;  
...  
// Set exception on msg to indicate why transmission failed...  
msg.SetErrorInfo(  
 new ApplicationException(  
 "The TCP connection was closed by the destination"));  
```  
  
## <a name="handle-receive-specific-batch-errors"></a>受信に固有のバッチ エラーの処理  
  
### <a name="handle-receive-failures"></a>受信に失敗した場合の処理  
 アダプターから BizTalk Server に操作または操作のバッチを送信するときに失敗した場合は、さまざまな原因が考えられます。 最も大きな原因は次の 2 つです。  
  
-   受信パイプラインが失敗した。  
  
-   メッセージを公開するときにルーティング エラーが発生した。  
  
 受信パイプラインが失敗した場合、メッセージング エンジンは自動的にメッセージの中断を試行します。 この中断操作は常に正常に完了するとは限りません。 たとえば、メッセージの公開中にメッセージング エンジンでルーティング エラーが発生すると、エンジンではメッセージの中断を試行することもできません。  
  
 メッセージの失敗は常に発生する可能性があります。 このような状況で、アダプターが明示的に呼び出す、 **MoveToSuspendQ** API と、メッセージの中断を試行する必要があります。 アダプターでメッセージの中断を試行する場合は、次のいずれかの状況が該当します。  
  
-   アダプターが送信 (推奨) したメッセージ オブジェクトと同じオブジェクトを中断する必要がある。  
  
-   アダプターで新しいメッセージを作成する必要がある場合は、新しいメッセージのメッセージ コンテキストに、最初に送信されたメッセージのメッセージ コンテキストへのポインターを設定する必要がある。 この理由は、メッセージのメッセージ コンテキストに、メッセージとエラーに関する有用な情報が多く含まれるためです。 この情報は、失敗したメッセージをデバッグするときに必要になります。  
  
> [!NOTE]
>  アダプターで新しいメッセージ オブジェクトを作成して中断する場合、アダプターでは、古いメッセージ オブジェクトから新しいメッセージ オブジェクトにエラー情報をコピーする必要があります。  
  
 BizTalk Server 付属の HTTP アダプターなど、一部のアダプターではメッセージを中断する必要はありません。 これらのアダプターでは、エラーをクライアントに返すことができます。  
  
#### <a name="causes-of-failure"></a>エラーの原因  
 エラーの簡単な原因としては、バッチが構築された場合や場合に発生するエラー **ibttransportbatch::done**と呼びます。  
  
-   **発信に失敗しました。** **送信**限られた数の理由の呼び出しが失敗して、すべてが致命的です。 原因には次のようなものがあります。  
  
-   BizTalk Server のプロセス領域で発生するメモリ不足エラー。  
  
-   スキーマ アセンブリが展開先から削除されている。 ここで、**送信**解読不明のエラーで失敗します。 MQSeries アダプターの場合は、BizTalk Server からの一般的なエラー例外がキャッチされ、システム イベント ログに拡張エラー メッセージが書き込まれます。 このメッセージでは、考えられるエラー原因の 1 つとして、スキーマ アセンブリが展開先から削除されていることが示されます。  
  
     [全般] の場合に**送信**が失敗したが、同じトランザクションを使用してメッセージを中断しようとする必要があります。  
  
-   **Ibttransportbatch::done に失敗しました。** **Ibttransportbatch::done**呼び出しが失敗する理由はいくつかのいずれか。 通常は、中断操作を 1 回試行してから、それが失敗したときのみトランザクションを終了してください。 いずれかのエラー コードの障害から受信する可能性があります**ibttransportbatch::done**は、BizTalk Server がシャット ダウンしようとしていること。 この場合、のみ、トランザクションを終了してくださいためにのままに、 **Terminate**呼び出しが同時に行われている可能性があります。 バッチを適切に構築して正常に実行されたときに、その他のシナリオが発生する**ibttransportbatch::done**です。 このような場合、エラーが返される**BatchComplete**し、アダプターは、それらの処理方法を確認する必要があります。 以下では、この場合について検討します。  
  
#### <a name="processing-batchcomplete-errors"></a>BatchComplete エラーの処理  
 **BatchComplete**バッチ操作の完了状態を示すために BizTalk Server によって呼び出されるアダプターによって提供されるコールバックです。  
  
 最も重要なパラメーターが渡される**BatchComplete**バッチの状態は、`hResult`です。 このパラメーターはバッチの成功または失敗を示します。 バッチの失敗は、バッチのいずれの操作も成功しなかったことを意味します。 アダプターはバッチの状態の構造が組まれ、どのメッセージの失敗を判断 (これは呼ば*バッチのフィルター処理*)。  
  
#### <a name="nontransactional-batchcomplete-errors"></a>非トランザクション BatchComplete エラー  
 非トランザクション アダプターの障害が発生した場合、ユーザーへの応答を選択する必要があります、 **SubmitMessage**/**SubmitRequestMessage**または**SubmitResponseMessage**操作します。 アダプターが呼び出すことによって、メッセージを中断する通常**MoveToSuspendQ**です。  
  
 次の操作は常に渡すことが: **DeleteMessage**、 **MoveToSuspendQ**、 **ResubmitMessage**です。 これらの操作が失敗した場合は、通常、アダプターにバグがあることを示しています。 この場合は、エラーを処理するコードを記述する必要はありません。 ただし、別の操作の失敗が原因でバッチが失敗した場合は、新しいバッチでこれらの操作を再実行する必要があります。  
  
 アダプターが呼び出す場合**MovetoBackupTransport** (バックアップ トランスポートがないため) 失敗すると、アダプターを呼び出す必要があります**MoveToSuspendQ**メッセージを保留にします。  
  
#### <a name="transactional-batchcomplete-errors"></a>トランザクション BatchComplete エラー  
 アダプターによって作成されたトランザクションを使用して BizTalk Server にバッチを送信するときには、次のいずれかの方法を使用する必要があります。  
  
-   **単一メッセージのバッチを使用します。** 。単一メッセージのバッチを BizTalk Server に送信します。 この単一メッセージが失敗した場合は、同じトランザクションで BizTalk Server に 2 つ目のバッチを送信できますが、問題のあるメッセージは再送信せず保留キューへ移動する必要があります。 失敗したメッセージを削除して 2 つ目のバッチを送信し、 BizTalk Server で 2 つ目のバッチが成功したことが確認されたら、トランザクションをコミットできます。 2 つ目のバッチが失敗した場合、アダプターではトランザクションを中止するか、メッセージの格納先を見つける必要があります。 この場合、トランザクションのロールバック処理によって、パフォーマンスが急激に低下します。  
  
     アダプターのパフォーマンスを改善するにはいくつかの方法があります。 たとえば MQSeries アダプターでは、実行時に動的に処理方法が調整されます。 このアダプターは 100 メッセージのバッチを処理できます。 エラーが発生した場合はバッチを終了する必要がありますが、このとき単一メッセージのバッチに切り替えて問題のあるメッセージに対処し、 その後、100 メッセージのバッチに戻ります。 再度エラーが発生した場合は、再び処理が遅くなります。  
  
-   **プリエンプティブ中断を使用します。** 。複数メッセージのバッチを構築し、その中で、エラーがあるメッセージをプリエンプティブに中断します。 バッチには組み合わせが含まれています**送信**と**MoveToSuspendQ**操作は、最初で唯一のバッチ、トランザクションとします。 問題のあるデータはプリエンプティブに中断され、処理が続行されます。BizTalk Server からの確認を受信したら、トランザクションをコミットできます。  
  
     この処理には予測が必要なように思えますが、この方法は MSMQ アダプターで以前から使用されています。 この方法を使用する場合は、メッセージ ID がそれぞれ確実に一意であることが必要です。 このアダプターは複数メッセージを含む単一バッチを構築し、 エラーが発生した場合は、トランザクションとバッチをロールバックします。このとき、アダプターは一時データ構造にメッセージ ID を記録します  (この構造が無制限に大きくならないように、中の項目は一定の時間を置いて削除されます)。各バッチの送信前に、アダプターは問題のあるメッセージ ID の一覧を確認します。 問題のあるメッセージ ID があった場合、該当のメッセージは以前に一度失敗しているので、アダプターで失敗を予測できます。したがって、メッセージを送信せずに、プリエンプティブに中断できます。  
  
     すべてのアダプターで、メッセージ ID が確実に一意であるとは限りません。トランザクション ストアではさらに可能性が低くなります。 このため、多くのトランザクション アダプターは、単一メッセージ バッチの送信のみに制限されています。  
  
#### <a name="processing-other-errors"></a>その他のエラーの処理  
 メッセージ中断中のエラーなど、その他のエラーが発生した場合はすべて、アダプターでトランザクションを終了する必要があります。 その他の方法ではメッセージが重複するか削除されます。  
  
 バッチが失敗した場合、アダプターでは可能な限りトランザクションを中止する必要があります。 ただし、アダプターでトランザクションを中止できない場合もあり、 このような場合は、同じトランザクションを使用するメッセージを中断する必要があります。  
  
#### <a name="processing-errors-on-transactional-receive"></a>トランザクション受信でのエラーの処理  
 トランザクション処理では、エラーが発生したときにトランザクションを終了するのが一般的なパターンです。 この場合、すべての操作が以前の状態に戻され、データが失われることはありません。 ただし、トランザクションで取得したデータを使用している場合は、これでは十分ではない可能性があります。この例としては、データベースの段階テーブルから一度に 1 行を取得している場合や、MQSeries、MSMQ などのキューイング製品から一度に 1 つのメッセージを取得している場合などがあります。 単純にトランザクションを終了して元の状態に戻し、また同じデータを取得すると、同じエラーが発生する可能性が高く、システムはエラーのある状況から抜け出せません。  
  
 以前のバージョンの BizTalk Server に付属の SQL アダプターには、この動作が設定されていました。 しかし、リリース後すぐにこのアダプターの動作は変更され、失敗したメッセージの中断とトランザクションのコミットを試行するようになっています。 同じトランザクションで保留キューにメッセージを移動し、トランザクションをコミットすると、データ損失を防止でき、アダプターでは問題があるデータに対処できるようになります。  
  
 アダプターの受信部分は、渡されたときに、エラー メッセージに応答を**送信**メッセージ、操作、アダプターがそのエラーを処理する必要があり、メッセージを保留キューに移動します。  
  
 アダプターでトランザクション オブジェクトを作成し、そのトランザクションでメッセージを送信するトランザクション バッチの場合、アダプターではエラーが発生したときと同じトランザクションでメッセージを保留キューに移動する必要があります。 トランザクションでは、エラーの原因となったデータも含めすべてのデータが削除されないようにします。  
  
### <a name="handle-messages-without-subscriptions"></a>サブスクリプションが存在しない場合のメッセージの処理  
 BizTalk Server では、メッセージを受け入れるサブスクリプションが定義されていない場合、メッセージ ボックス データベースでのメッセージの公開は許可されません。 サブスクリプションはオーケストレーションまたは送信ポートで登録されます。 複数のサブスクリプションの定義が可能で、この場合メッセージは複数の送信先に送信されます。 サブスクリプションが存在しない場合、BizTalk Server はメッセージを拒否し、メッセージの中断を試行しません。 アダプターでこのエラーを処理せず、明示的にメッセージを中断しない場合は、メッセージは削除され、メッセージのデータも失われる可能性があります。 トランザクション アダプターの場合は、トランザクションを終了してメッセージを送信先に返すものもあります。  
  
### <a name="support-seek-with-your-receive-stream"></a>受信ストリームのシークのサポート  
 受信側のストリームをサポートする必要があります、**シーク**パイプライン エラー発生時にメッセージを中断できる BizTalk Server 用のメソッドです。 メッセージ ストリームはシーク可能ではないかどうかは、これを実行しようとするときに、BizTalk Server によってエラーが発生**シーク**です。  
  
 サポートする多くの場合**シーク**容易ではありません。 たとえば、ネットワークからデータをストリーミングするときには、ネットワーク リソースに戻って再度データを要求することは困難です。  
  
 BizTalk Server に付属のいくつかのアダプターは、BizTalk Server でメッセージ データが読み取られると同時に、データをディスク上のファイルにスプールします。 これにより、アダプターを使用する**シーク**で (たとえば、メッセージ データのパイプライン処理) のエラーが発生した場合は、そのファイルにします。 内部的に、アダプターが使用して、 **ReadOnlySeekableStream**受信、シークできないストリームをラップし、構成可能なサイズのしきい値に達したときに、ディスクにオーバーフローが発生するクラス。 しきい値のサイズよりも小さいメッセージはディスクに保存されません。  
  
### <a name="consider-user-configurable-error-handling-options"></a>ユーザーが構成できるエラー処理オプションについて検討する  
 エラーへの適切な対応が 1 つでない場合があります。 この場合は、ユーザーが構成できるオプションを検討し、動作を選択できるようにする必要があります。 MQSeries アダプターはこのオプションに対応しています。  
  
 エラーが発生したときにアダプターでメッセージを中断する場合の問題点は、BizTalk Server の保留キューが "一方通行" 的な性質を持つことです。 キューにメッセージを移動するのは比較的簡単ですが、キューからメッセージを取り出すことは困難です。  
  
 アダプターの使用において、保留キュー内のアイテムをユーザーがまったく必要としない場合もあります。 たとえば MQSeries アダプターを使用する場合、ユーザーは構成オプションで次のいずれかの動作を実行できます。  
  
-   アダプターでエラーが発生したとき、現在のトランザクションを終了し、アダプター自身を無効にする。  
  
-   失敗したメッセージを中断し、トランザクションをコミットする。 BizTalk Server でメッセージが正常に中断された場合でも、アダプターではこの操作を実行します。 この操作では、イベント ログが厳密には正確ではなくなりますが、顧客の要件を満たすことができます。  
  
### <a name="implement-receive-ordering-by-using-a-single-thread-and-waiting-on-batchcomplete"></a>1 つのスレッドを使用して BatchComplete を待機することで受信を順序付ける  
 BizTalk Server のインターフェイスは、同時実行をサポートすることでパフォーマンスと拡張性を向上するよう設計されています。 しかし、MQSeries または MSMQ などのメッセージ キュー製品からメッセージを受信するときなどは、しばしばメッセージの受信を厳密に順序付ける必要が生じます。このような場合は、アダプターに対して追加の作業を行い、同時実行の一部を無効にする必要があります。 これは、次の 2 つの手順で行うことができます。  
  
1.  アダプターでのすべてのデータ処理に単一スレッドを使用します。  
  
2.  BizTalk Server でそれぞれのバッチが完全に処理されるまで待機します。 この要件は重要であり、.NET スレッド同期プリミティブを使用して実現できます。 たとえばを使用して、 **AutoResetEvent**は。  
  
    -   メイン ワーカー スレッドがアクセスできるイベント オブジェクトを宣言し、 **BatchComplete**コールバック オブジェクト。  
  
    -   メイン ワーカー スレッドでバッチにメッセージを通常どおりに送信し、呼び出すことは**AutoResetEvent.Reset**バッチへの呼び出しの直前に、イベント オブジェクトに対して**ibttransportbatch::done**です。  
  
    -   呼び出す**AutoResetEvent.WaitOne**この同じスレッドからイベント オブジェクトです。 これによって、メイン ワーカー スレッドがブロックされます。 **BatchComplete** BizTalk Server からのコールバック呼び出して**AutoResetEvent.Set**を別のメッセージを処理できるように、ワーカー スレッドのブロックを解除する同じイベント オブジェクト。  
  
 強くお勧めする*受信の順序付け*大幅なパフォーマンスの低下が発生するため構成可能なこのできるようにします。 ほとんどではないにせよ、多くの場合、ユーザーはメッセージの順序付けを必要としません。 メッセージを中断すると、順序も崩れる可能性があり、 この場合の対応はアプリケーションによって異なります。このため、アダプターを構成するポイントを用意し、ユーザーにオプションを提供するのが最良の方法です。  
  
 順序付けを使用する場合で、順序を破棄するのではなくアダプターを無効にし、処理を停止することを顧客が希望する場合もあります。 受信の順序付けがサポートされている MQSeries アダプターを使用すれば、このオプションをユーザーに提供できます。  
  
## <a name="handle-send-specific-batch-errors"></a>送信に固有のバッチ エラーの処理  
  
### <a name="handle-send-retry-and-batching"></a>送信再試行とバッチの処理  
 送信側バッチ処理の一般的な例としては、次のような処理があります。  
  
-   BizTalk Server がアダプターにメッセージのバッチを送信します。  
  
-   アダプターは、メッセージが送信先に正常に送信されたことを確認した後、BizTalk Server に送信の完了を示す削除メッセージを送信します。 通常はパフォーマンス向上のため、複数の削除メッセージが任意にまとめられます。  
  
 送信側アダプターでメッセージの処理に失敗した場合、アダプターはそのメッセージに対して次のいずれかの処理を実行します。  
  
-   BizTalk Server にメッセージの再試行を要求する。 BizTalk Server はメッセージの再試行を自動的に実行しませんが、 再試行のカウントを保持しており、このカウントはメッセージのコンテキストで参照できます。  
  
-   メッセージを処理できないと判断し、 メッセージを次のトランスポートに移動する。 アダプターが、これを**MoveToNextTransport**でを呼び出す、**バッチ**オブジェクト。  
  
-   メッセージを保留キューに移動する。  
  
 アダプターではメッセージの処理が決定されますが、 アダプターの動作を一貫したものにするようお勧めします。こうすることで、BizTalk Server のサポートが容易になります。  
  
 アダプターは次のような動作に設定することを強くお勧めします。 BizTalk Server に付属のアダプターにはこの動作が設定されています。  
  
### <a name="recommended-behavior-for-handling-send-errors-in-a-batch"></a>バッチでの送信エラー処理に関する推奨動作  
 送信アダプターはいくつかのメッセージを受信し、BizTalk Server に送信します。  
  
 アダプターでは成功したメッセージごとに、BizTalk Server にメッセージの削除を要求する必要があります。 BizTalk Server への通信はすべてバッチで行います。削除もバッチにまとめることができます。 これらのバッチは、BizTalk Server によってアダプター上に作成されるバッチと同じである必要はありません。 SolicitResponse シナリオなどで応答メッセージがある場合は、これらのメッセージも削除メッセージと共に (SubmitResponse で) BizTalk Server に返送する必要があります。  
  
-   アダプターでメッセージ処理が失敗した場合は、再試行カウントを確認する。  
  
    -   再試行カウントが設定値を超えていない場合は、BizTalk Server にメッセージを再送信する。その際、メッセージの再試行回数を設定する。 アダプターで使用する再試行カウントと再試行間隔は、メッセージ コンテキストで確認できます。  
  
    -   再試行回数が超過したかどうかを使用して、メッセージを移動するべきでは、アダプター **MoveToNextTransport**です。 再送信と**MoveToNextTransport** BizTalk サーバーに同じバッチ内で削除とメッセージを混在させることができます。 これは必須ではありませんが、有効な方法です。  
  
-   再送信し、 **MoveToNextTransport**アダプターがエラーに対処するための方法です。 この処理中にエラーが発生することもあります。 BizTalk Server からの応答の処理中には、ここでは、(で、 **BatchComplete**メソッド)、アダプターは、そのエラーの処理方法を示すために BizTalk Server に対して別のバッチを作成する必要があります。  
  
     失敗への対処中に起こったエラーを処理するには、次の手順に従います。  
  
    -   再送信が失敗すると、 **MoveToNextTransport**です。  
  
    -   場合、 **MoveToNextTransport**失敗した場合を使用して**MoveToSuspendQ**です。  
  
 BizTalk Server で操作の成功を受信するまで、BizTalk Server に対してバッチの作成を続ける必要があります。  
  
### <a name="serialization-of-message-context-property"></a>メッセージ コンテキスト プロパティのシリアル化  
 メッセージ コンテキスト プロパティに割り当てるオブジェクトはすべてシリアル化できる必要があります。 それ以外の場合、メッセージング エンジンは型の例外をスロー **E_NOINTERFACE**です。 この戻り値は、メッセージ コンテキスト プロパティに対してシリアル化できないオブジェクトの割り当てが試行されたことを暗黙的に示すものです。