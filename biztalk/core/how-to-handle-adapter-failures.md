---
title: アダプターの障害を処理する方法 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: bdceb364-38d6-4aab-a176-bf751da1be25
caps.latest.revision: 12
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: ac87b905d7eb68bdb37a900840f7bd747c92ed77
ms.sourcegitcommit: 266308ec5c6a9d8d80ff298ee6051b4843c5d626
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/27/2018
ms.locfileid: "36971923"
---
# <a name="how-to-handle-adapter-failures"></a>アダプターのエラーを処理する方法
アダプターでは通常、処理できないメッセージを中断します。 たとえば、受信アダプターで送信エラーが発生した場合は通常、メッセージを中断します。ただし、この判断はアダプターの目的によって変わることがあります。 エラーを処理するときには、セキュリティの問題も考慮する必要があります。 たとえば、失敗したメッセージをすべてアダプターで自動的に中断すると、そのアダプターはサービス拒否攻撃に対して脆弱になり、BizTalk Server の保留キューがいっぱいになる可能性があります。  HTTP アダプターなど一部のアダプターでは、要求が拒否されたことを示すエラー コードをクライアントに返すことができます。 こうした種類のアダプターでは、多くの場合、メッセージを中断するよりもエラー コードを返す方が有効です。 送信アダプターでは通常、プライマリ トランスポートとセカンダリ トランスポートの両方で、再試行回数が設定値を超えた後ではじめてメッセージを中断します。  
  
## <a name="associate-error-processing-with-an-individual-operation-and-not-with-the-batch-that-contains-the-operation"></a>操作を含むバッチではなく、個々の操作にエラー処理を関連付ける  
 アダプターでのメッセージのバッチ処理は、アダプターのユーザーに見えないところで実行し、 バッチ内の操作の 1 つが失敗しても他の操作に影響が生じないようにする必要があります。 しかし、バッチはアトミックであるため、1 つのメッセージでエラーが発生するとバッチのエラーとなり、操作は処理されなくなります。  
  
 したがって、エラーが発生したときに処理するコードを記述し、正常なメッセージを再送信して失敗したメッセージを中断するよう指定する必要があります。 BizTalk Server では詳細なエラー構造が提供されるので、アダプターでは失敗した操作を特定できます。 これを基に、正常な操作を再実行し失敗した操作を中断するバッチをさらに構築できます。  
  
 アダプター内のバッチ処理によって、操作の最終的な状態が影響を受けないようにしてください。  
  
## <a name="use-seterrorinfo-to-report-failure-to-biztalk-server"></a>SetErrorInfo を使用して BizTalk Server にエラーを報告する  
 メッセージを中断する場合は、その前のメッセージ コンテキストから BizTalk Server にエラー情報を送信する必要があります。 BizTalk Server は、エラー レポート機能を使用して、 **SetErrorInfo**両方のメソッド、 **IBaseMessage**と**ITransportProxy**インターフェイス。 エラーを報告するには次の方法を使用できます。  
  
- メッセージの処理中に失敗したとき、設定を使用して例外**SetErrorInfo (Exception e)** メッセージ (**IBaseMessage**) を中断します。 こうすると、エンジンではメッセージと共にエラーが保持され、後の診断に使用できます。また、イベント ログにエラーが記録され、管理者はエラーを認識できます。  
  
- 呼び出す必要があります (メッセージの処理) 中ではなく初期化または内部ブックキーピング中にエラーが発生した場合**SetErrorInfo (Exception e)** 上、 **ITransportProxy**に渡されたポインター初期化中にします。 アダプターが BaseAdapter 実装を基にしている場合は、このポインターに常にアクセスできるようにしておく必要があります。 そうでない場合は、ポインターをキャッシュしておくようにします。  
  
  どちらの方法でも、エラーが報告されると、イベント ログにエラー メッセージが書き込まれます。 エラーとそのメッセージを関連付けることができる場合は、必ず関連付けを行ってください。  
  
## <a name="handle-a-database-offline-condition"></a>データベースがオフラインになった場合の処理  
 BizTalk Server データベースの 1 つがオフラインになった場合、BizTalk サービスは自身を再利用します。 メッセージング エンジンは、サービスが再利用される前にすべての受信場所のシャットダウンをあらゆる方法で試行しますが、 この処理が 60 秒以上かかるとサービスは終了します。 エンジンのトランザクションは行われるので、データの損失は起こりません。  
  
 タイムアウトはレジストリで次のキーを使用して設定できます。  
  
```  
DWORD   
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTSSvc{Host Guid}\MessagingDBFailoverShutdownTimeLimit  
```  
  
 分離アダプターの場合はプロセスの所有者が BizTalk Server ではないため、BizTalk Server データベースの 1 つがオフラインになると受信場所は無効になります。 これらの受信場所は、データベースがオンラインに戻った後で再度有効になります。  
  
## <a name="write-to-the-event-log"></a>イベント ログへの書き込み  
 使用して、アダプターがイベント ログ エントリを書き込むことができます、 **IBTTransportProxy**例外で渡すインターフェイス。 ネイティブ コードで開発されたアダプターを渡す必要があります、 **IErrorInfo**インターフェイス、 **IBTTransportProxy.SetErrorInfo (例外** `e` **)** します。  
  
 送信エラー後にアダプターでメッセージの送信を再試行したり、アダプターのバックアップ トランスポートにメッセージを移動したり、メッセージを中断するときなどは、メッセージング エンジンがアダプターに代わってイベント ログへの書き込みを行います。 このような場合、アダプターで必要になる操作は、API の呼び出し前にメッセージに例外を設定することだけです。 このコード例の一部を次に示します。  
  
```  
IBaseMessage msg;  
...  
// Set exception on msg to indicate why transmission failed...  
msg.SetErrorInfo(  
 new ApplicationException(  
 "The TCP connection was closed by the destination"));  
```  
  
## <a name="handle-receive-specific-batch-errors"></a>受信に固有のバッチ エラーの処理  
  
### <a name="handle-receive-failures"></a>受信に失敗した場合の処理  
 アダプターから BizTalk Server に操作または操作のバッチを送信するときに失敗した場合は、さまざまな原因が考えられます。 最も大きな原因は次の 2 つです。  
  
- 受信パイプラインが失敗した。  
  
- メッセージを公開するときにルーティング エラーが発生した。  
  
  受信パイプラインが失敗した場合、メッセージング エンジンは自動的にメッセージの中断を試行します。 この中断操作は常に正常に完了するとは限りません。 たとえば、メッセージの公開中にメッセージング エンジンでルーティング エラーが発生すると、エンジンではメッセージの中断を試行することもできません。  
  
  メッセージの失敗は常に発生する可能性があります。 このような場合は、アダプターは呼び出す必要があります明示的に、 **MoveToSuspendQ** API と、メッセージの中断を試行する必要があります。 アダプターでメッセージの中断を試行する場合は、次のいずれかの状況が該当します。  
  
- アダプターが送信 (推奨) したメッセージ オブジェクトと同じオブジェクトを中断する必要がある。  
  
- アダプターで新しいメッセージを作成する必要がある場合は、新しいメッセージのメッセージ コンテキストに、最初に送信されたメッセージのメッセージ コンテキストへのポインターを設定する必要がある。 この理由は、メッセージのメッセージ コンテキストに、メッセージとエラーに関する有用な情報が多く含まれるためです。 この情報は、失敗したメッセージをデバッグするときに必要になります。  
  
> [!NOTE]
>  アダプターで新しいメッセージ オブジェクトを作成して中断する場合、アダプターでは、古いメッセージ オブジェクトから新しいメッセージ オブジェクトにエラー情報をコピーする必要があります。  
  
 BizTalk Server 付属の HTTP アダプターなど、一部のアダプターではメッセージを中断する必要はありません。 これらのアダプターでは、エラーをクライアントに返すことができます。  
  
#### <a name="causes-of-failure"></a>エラーの原因  
 エラーの簡単な原因は次のように、バッチを構築、またはときに発生するエラー **ibttransportbatch::done**が呼び出されます。  
  
-   **発信に失敗しました。** **送信**呼び出しが失敗の理由の数を制限して、そのすべてが致命的な。 原因には次のようなものがあります。  
  
-   BizTalk Server のプロセス領域で発生するメモリ不足エラー。  
  
-   スキーマ アセンブリが展開先から削除されている。 ここで、**送信**わかりにくいエラーで失敗します。 MQSeries アダプターの場合は、BizTalk Server からの一般的なエラー例外がキャッチされ、システム イベント ログに拡張エラー メッセージが書き込まれます。 このメッセージでは、考えられるエラー原因の 1 つとして、スキーマ アセンブリが展開先から削除されていることが示されます。  
  
     一般的で**送信**が失敗したのと同じトランザクションを使用してメッセージを中断しようとする必要があります。  
  
-   **Ibttransportbatch::done の失敗。** **Ibttransportbatch::done**いくつかの理由の 1 つの呼び出しが失敗します。 通常は、中断操作を 1 回試行してから、それが失敗したときのみトランザクションを終了してください。 いずれかのエラー コードの障害から受信する可能性があります**ibttransportbatch::done** BizTalk Server がシャット ダウンしようとしていることができます。 ここでは、どうかだけにトランザクションを終了し、ためにのままに、 **Terminate**呼び出しが同時に行われている可能性があります。 バッチを適切に構築して正常に実行されるときに、その他のシナリオが発生する**ibttransportbatch::done**します。 このような場合、エラーが返される**BatchComplete**とアダプターは、それらの処理方法を決定する必要があります。 以下では、この場合について検討します。  
  
#### <a name="processing-batchcomplete-errors"></a>BatchComplete エラーの処理  
 **BatchComplete**をバッチ操作の完了状態を示すために BizTalk Server によって呼び出されるアダプターによって提供されるコールバックです。  
  
 渡される最も重要なパラメーター **BatchComplete** 、バッチの状態は、`hResult`します。 このパラメーターはバッチの成功または失敗を示します。 バッチの失敗は、バッチのいずれの操作も成功しなかったことを意味します。 アダプターがバッチの状態の構造を通過し、メッセージの失敗を判断します (これと呼ばれます*バッチのフィルター処理*)。  
  
#### <a name="nontransactional-batchcomplete-errors"></a>非トランザクション BatchComplete エラー  
 非トランザクション アダプターの場合のエラーが発生した場合、応答を選択する必要があります、 **SubmitMessage**/**SubmitRequestMessage**または**SubmitResponseMessage**操作。 アダプターが呼び出すことによって、メッセージを中断する通常**MoveToSuspendQ**します。  
  
 次の操作は常に渡すが必要です: **DeleteMessage**、 **MoveToSuspendQ**、 **ResubmitMessage**します。 これらの操作が失敗した場合は、通常、アダプターにバグがあることを示しています。 この場合は、エラーを処理するコードを記述する必要はありません。 ただし、別の操作の失敗が原因でバッチが失敗した場合は、新しいバッチでこれらの操作を再実行する必要があります。  
  
 アダプターが呼び出す場合**MovetoBackupTransport** (バックアップ トランスポートがないため) 失敗すると、アダプターが呼び出す必要があります**MoveToSuspendQ**にメッセージを中断します。  
  
#### <a name="transactional-batchcomplete-errors"></a>トランザクション BatchComplete エラー  
 アダプターによって作成されたトランザクションを使用して BizTalk Server にバッチを送信するときには、次のいずれかの方法を使用する必要があります。  
  
-   **単一メッセージのバッチを使用します。** 。単一メッセージのバッチを BizTalk Server に送信します。 この単一メッセージが失敗した場合は、同じトランザクションで BizTalk Server に 2 つ目のバッチを送信できますが、問題のあるメッセージは再送信せず保留キューへ移動する必要があります。 失敗したメッセージを削除して 2 つ目のバッチを送信し、 BizTalk Server で 2 つ目のバッチが成功したことが確認されたら、トランザクションをコミットできます。 2 つ目のバッチが失敗した場合、アダプターではトランザクションを中止するか、メッセージの格納先を見つける必要があります。 この場合、トランザクションのロールバック処理によって、パフォーマンスが急激に低下します。  
  
     アダプターのパフォーマンスを改善するにはいくつかの方法があります。 たとえば MQSeries アダプターでは、実行時に動的に処理方法が調整されます。 このアダプターは 100 メッセージのバッチを処理できます。 エラーが発生した場合はバッチを終了する必要がありますが、このとき単一メッセージのバッチに切り替えて問題のあるメッセージに対処し、 その後、100 メッセージのバッチに戻ります。 再度エラーが発生した場合は、再び処理が遅くなります。  
  
-   **プリエンプティブ中断を使用します。** 。複数メッセージのバッチを構築し、その中で、エラーがあるメッセージをプリエンプティブに中断します。 バッチが混在**送信**と**MoveToSuspendQ**操作では、最初で唯一のバッチ、トランザクションとします。 問題のあるデータはプリエンプティブに中断され、処理が続行されます。BizTalk Server からの確認を受信したら、トランザクションをコミットできます。  
  
     この処理には予測が必要なように思えますが、この方法は MSMQ アダプターで以前から使用されています。 この方法を使用する場合は、メッセージ ID がそれぞれ確実に一意であることが必要です。 このアダプターは複数メッセージを含む単一バッチを構築し、 エラーが発生した場合は、トランザクションとバッチをロールバックします。このとき、アダプターは一時データ構造にメッセージ ID を記録します  (この構造が無制限に大きくならないように、中の項目は一定の時間を置いて削除されます)。各バッチの送信前に、アダプターは問題のあるメッセージ ID の一覧を確認します。 問題のあるメッセージ ID があった場合、該当のメッセージは以前に一度失敗しているので、アダプターで失敗を予測できます。したがって、メッセージを送信せずに、プリエンプティブに中断できます。  
  
     すべてのアダプターで、メッセージ ID が確実に一意であるとは限りません。トランザクション ストアではさらに可能性が低くなります。 このため、多くのトランザクション アダプターは、単一メッセージ バッチの送信のみに制限されています。  
  
#### <a name="processing-other-errors"></a>その他のエラーの処理  
 メッセージ中断中のエラーなど、その他のエラーが発生した場合はすべて、アダプターでトランザクションを終了する必要があります。 その他の方法ではメッセージが重複するか削除されます。  
  
 バッチが失敗した場合、アダプターでは可能な限りトランザクションを中止する必要があります。 ただし、アダプターでトランザクションを中止できない場合もあり、 このような場合は、同じトランザクションを使用するメッセージを中断する必要があります。  
  
#### <a name="processing-errors-on-transactional-receive"></a>トランザクション受信でのエラーの処理  
 トランザクション処理では、エラーが発生したときにトランザクションを終了するのが一般的なパターンです。 この場合、すべての操作が以前の状態に戻され、データが失われることはありません。 ただし、トランザクションで取得したデータを使用している場合は、これでは十分ではない可能性があります。この例としては、データベースの段階テーブルから一度に 1 行を取得している場合や、MQSeries、MSMQ などのキューイング製品から一度に 1 つのメッセージを取得している場合などがあります。 単純にトランザクションを終了して元の状態に戻し、また同じデータを取得すると、同じエラーが発生する可能性が高く、システムはエラーのある状況から抜け出せません。  
  
 以前のバージョンの BizTalk Server に付属の SQL アダプターには、この動作が設定されていました。 しかし、リリース後すぐにこのアダプターの動作は変更され、失敗したメッセージの中断とトランザクションのコミットを試行するようになっています。 同じトランザクションで保留キューにメッセージを移動し、トランザクションをコミットすると、データ損失を防止でき、アダプターでは問題があるデータに対処できるようになります。  
  
 アダプターの受信部分が渡された場合、エラー メッセージに応答を**送信**メッセージ操作では、アダプターがそのエラーを処理し、メッセージを保留キューに移動する必要があります。  
  
 アダプターでトランザクション オブジェクトを作成し、そのトランザクションでメッセージを送信するトランザクション バッチの場合、アダプターではエラーが発生したときと同じトランザクションでメッセージを保留キューに移動する必要があります。 トランザクションでは、エラーの原因となったデータも含めすべてのデータが削除されないようにします。  
  
### <a name="handle-messages-without-subscriptions"></a>サブスクリプションが存在しない場合のメッセージの処理  
 BizTalk Server では、メッセージを受け入れるサブスクリプションが定義されていない場合、メッセージ ボックス データベースでのメッセージの公開は許可されません。 サブスクリプションはオーケストレーションまたは送信ポートで登録されます。 複数のサブスクリプションの定義が可能で、この場合メッセージは複数の送信先に送信されます。 サブスクリプションが存在しない場合、BizTalk Server はメッセージを拒否し、メッセージの中断を試行しません。 アダプターでこのエラーを処理せず、明示的にメッセージを中断しない場合は、メッセージは削除され、メッセージのデータも失われる可能性があります。 トランザクション アダプターの場合は、トランザクションを終了してメッセージを送信先に返すものもあります。  
  
### <a name="support-seek-with-your-receive-stream"></a>受信ストリームのシークのサポート  
 受信側ストリームをサポートする必要があります、**シーク**のパイプライン エラー メッセージを中断できる BizTalk Server 用のメソッド。 メッセージ ストリームはシーク不可能としている場合、BizTalk Server を実行する際にエラーが発生**シーク**します。  
  
 多くの場合をサポートしている**シーク**簡単ではありません。 たとえば、ネットワークからデータをストリーミングするときには、ネットワーク リソースに戻って再度データを要求することは困難です。  
  
 BizTalk Server に付属のいくつかのアダプターは、BizTalk Server でメッセージ データが読み取られると同時に、データをディスク上のファイルにスプールします。 これにより、使用するアダプター**シーク**(たとえば、メッセージ データのパイプライン処理) でエラーが発生した場合は、そのファイルにします。 内部的には、アダプターを使用して、 **ReadOnlySeekableStream**クラスを着信シーク可能ではないストリームをラップし、構成可能なサイズのしきい値に達したときに、ディスクにオーバーフローが発生します。 しきい値のサイズよりも小さいメッセージはディスクに保存されません。  
  
### <a name="consider-user-configurable-error-handling-options"></a>ユーザーが構成できるエラー処理オプションについて検討する  
 エラーへの適切な対応が 1 つでない場合があります。 この場合は、ユーザーが構成できるオプションを検討し、動作を選択できるようにする必要があります。 MQSeries アダプターはこのオプションに対応しています。  
  
 エラーが発生したときにアダプターでメッセージを中断する場合の問題点は、BizTalk Server の保留キューが "一方通行" 的な性質を持つことです。 キューにメッセージを移動するのは比較的簡単ですが、キューからメッセージを取り出すことは困難です。  
  
 アダプターの使用において、保留キュー内のアイテムをユーザーがまったく必要としない場合もあります。 たとえば MQSeries アダプターを使用する場合、ユーザーは構成オプションで次のいずれかの動作を実行できます。  
  
-   アダプターでエラーが発生したとき、現在のトランザクションを終了し、アダプター自身を無効にする。  
  
-   失敗したメッセージを中断し、トランザクションをコミットする。 BizTalk Server でメッセージが正常に中断された場合でも、アダプターではこの操作を実行します。 この操作では、イベント ログが厳密には正確ではなくなりますが、顧客の要件を満たすことができます。  
  
### <a name="implement-receive-ordering-by-using-a-single-thread-and-waiting-on-batchcomplete"></a>1 つのスレッドを使用して BatchComplete を待機することで受信を順序付ける  
 BizTalk Server のインターフェイスは、同時実行をサポートすることでパフォーマンスと拡張性を向上するよう設計されています。 しかし、MQSeries または MSMQ などのメッセージ キュー製品からメッセージを受信するときなどは、しばしばメッセージの受信を厳密に順序付ける必要が生じます。このような場合は、アダプターに対して追加の作業を行い、同時実行の一部を無効にする必要があります。 これは、次の 2 つの手順で行うことができます。  
  
1. アダプターでのすべてのデータ処理に単一スレッドを使用します。  
  
2. BizTalk Server でそれぞれのバッチが完全に処理されるまで待機します。 この要件は重要であり、.NET スレッド同期プリミティブを使用して実現できます。 たとえばを使用して、 **AutoResetEvent**の場合します。  
  
   -   メイン ワーカー スレッドによってアクセスできるイベント オブジェクトを宣言し、 **BatchComplete**コールバック オブジェクト。  
  
   -   メイン ワーカー スレッドで、バッチにメッセージを通常どおり送信が呼び出して**した**バッチへの呼び出しの直前に、イベント オブジェクトに対して**ibttransportbatch::done**します。  
  
   -   呼び出す**AutoResetEvent.WaitOne**でこの同じスレッドからイベント オブジェクト。 これによって、メイン ワーカー スレッドがブロックされます。 **BatchComplete** BizTalk Server からのコールバックを呼び出して**AutoResetEvent.Set**同じイベント オブジェクトを別のメッセージを処理できるように、ワーカー スレッドのブロックを解除します。  
  
   強くお勧めする*受信の順序付け*パフォーマンスが著しく低下するので、構成可能なこのできるようにします。 ほとんどではないにせよ、多くの場合、ユーザーはメッセージの順序付けを必要としません。 メッセージを中断すると、順序も崩れる可能性があり、 この場合の対応はアプリケーションによって異なります。このため、アダプターを構成するポイントを用意し、ユーザーにオプションを提供するのが最良の方法です。  
  
   順序付けを使用する場合で、順序を破棄するのではなくアダプターを無効にし、処理を停止することを顧客が希望する場合もあります。 受信の順序付けがサポートされている MQSeries アダプターを使用すれば、このオプションをユーザーに提供できます。  
  
## <a name="handle-send-specific-batch-errors"></a>送信に固有のバッチ エラーの処理  
  
### <a name="handle-send-retry-and-batching"></a>送信再試行とバッチの処理  
 送信側バッチ処理の一般的な例としては、次のような処理があります。  
  
- BizTalk Server がアダプターにメッセージのバッチを送信します。  
  
- アダプターは、メッセージが送信先に正常に送信されたことを確認した後、BizTalk Server に送信の完了を示す削除メッセージを送信します。 通常はパフォーマンス向上のため、複数の削除メッセージが任意にまとめられます。  
  
  送信側アダプターでメッセージの処理に失敗した場合、アダプターはそのメッセージに対して次のいずれかの処理を実行します。  
  
- BizTalk Server にメッセージの再試行を要求する。 BizTalk Server はメッセージの再試行を自動的に実行しませんが、 再試行のカウントを保持しており、このカウントはメッセージのコンテキストで参照できます。  
  
- メッセージを処理できないと判断し、 メッセージを次のトランスポートに移動する。 アダプターは、これを**MoveToNextTransport**を呼び出す、**バッチ**オブジェクト。  
  
- メッセージを保留キューに移動する。  
  
  アダプターではメッセージの処理が決定されますが、 アダプターの動作を一貫したものにするようお勧めします。こうすることで、BizTalk Server のサポートが容易になります。  
  
  アダプターは次のような動作に設定することを強くお勧めします。 BizTalk Server に付属のアダプターにはこの動作が設定されています。  
  
### <a name="recommended-behavior-for-handling-send-errors-in-a-batch"></a>バッチでの送信エラー処理に関する推奨動作  
 送信アダプターはいくつかのメッセージを受信し、BizTalk Server に送信します。  
  
 アダプターでは成功したメッセージごとに、BizTalk Server にメッセージの削除を要求する必要があります。 BizTalk Server への通信はすべてバッチで行います。削除もバッチにまとめることができます。 これらのバッチは、BizTalk Server によってアダプター上に作成されるバッチと同じである必要はありません。 SolicitResponse シナリオなどで応答メッセージがある場合は、これらのメッセージも削除メッセージと共に (SubmitResponse で) BizTalk Server に返送する必要があります。  
  
- アダプターでメッセージ処理が失敗した場合は、再試行カウントを確認する。  
  
  -   再試行カウントが設定値を超えていない場合は、BizTalk Server にメッセージを再送信する。その際、メッセージの再試行回数を設定する。 アダプターで使用する再試行カウントと再試行間隔は、メッセージ コンテキストで確認できます。  
  
  -   再試行回数を超えているかどうかは、アダプターを使用して、メッセージの移動を試行する**MoveToNextTransport**します。 再送信し、 **MoveToNextTransport**メッセージは、BizTalk Server に同じバッチ内で削除と一緒に指定することができます。 これは必須ではありませんが、有効な方法です。  
  
- 再送信し、 **MoveToNextTransport**方法はエラーに対処するアダプター。 この処理中にエラーが発生することもあります。 BizTalk Server からの応答の処理中には、この場合、(で、 **BatchComplete**メソッド) アダプターをそのエラーの処理方法を示すために BizTalk Server に対して別のバッチを作成する必要があります。  
  
   失敗への対処中に起こったエラーを処理するには、次の手順に従います。  
  
  -   再送信が失敗した場合、 **MoveToNextTransport**します。  
  
  -   場合、 **MoveToNextTransport**使用して、失敗した場合、 **MoveToSuspendQ**します。  
  
  BizTalk Server で操作の成功を受信するまで、BizTalk Server に対してバッチの作成を続ける必要があります。  
  
### <a name="serialization-of-message-context-property"></a>メッセージ コンテキスト プロパティのシリアル化  
 メッセージ コンテキスト プロパティに割り当てるオブジェクトはすべてシリアル化できる必要があります。 それ以外の場合、メッセージング エンジンは型の例外をスロー **E_NOINTERFACE**します。 この戻り値は、メッセージ コンテキスト プロパティに対してシリアル化できないオブジェクトの割り当てが試行されたことを暗黙的に示すものです。