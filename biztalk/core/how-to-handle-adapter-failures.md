---
title: アダプターの障害を処理する方法 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: bdceb364-38d6-4aab-a176-bf751da1be25
caps.latest.revision: 12
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 863ad82ce429bebb6bb5eb3ce671ca493830e8f4
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65337535"
---
# <a name="how-to-handle-adapter-failures"></a>アダプターの障害を処理する方法
一般に、アダプターは処理できないメッセージを中断する必要があります。 たとえば、この決定は、アダプターの目的によって異なりますが、送信エラーが発生している受信アダプターは、メッセージを中断通常必要があります。 エラー処理に関するセキュリティの考慮事項もあります。 たとえば、アダプターは、すべての失敗したメッセージを自動的に停止する場合、アダプターは BizTalk Server の保留キューがいっぱいの原因となるサービス拒否攻撃を開くのようにあります。  HTTP など、一部のアダプターは、エラー コードを要求が拒否されていることを示すクライアントに返すことができます。 これらの種類のアダプターの多くの場合、理にかなってメッセージを中断するのではなく、エラー コードが返されます。 通常、アダプターは、プライマリとセカンダリの両方のトランスポートの再試行がすべてが終了された後にのみメッセージを中断も送信されます。  
  
## <a name="associate-error-processing-with-an-individual-operation-and-not-with-the-batch-that-contains-the-operation"></a>個々 の操作とは、操作を含むバッチではなくを処理中にエラーを関連付ける  
 アダプターでのメッセージのバッチ処理はできません、アダプターのユーザーに表示されます。 つまり、バッチ内での 1 つの操作の失敗が何らかの方法で他の操作に影響はありません。 ただし、バッチはアトミックで、エラー メッセージが 1 つのバッチのエラーが発生し、操作が処理されません。  
  
 エラーの処理、成功したメッセージを再送信および失敗したものの中断を担当するコードを記述するとします。 さいわい、BizTalk Server は、失敗した操作を特定するようにアダプターをできるようにする詳細なエラー構造を提供します。 バッチをさらに成功した操作を再実行し、失敗したものの中断の構築が許可されます。  
  
 アダプター内のバッチ処理して、操作の最終的な状態は受けませんする必要があります。  
  
## <a name="use-seterrorinfo-to-report-failure-to-biztalk-server"></a>BizTalk Server にエラーをレポートする SetErrorInfo を使用してください。  
 メッセージを中断する場合は、前のメッセージ コンテキストから BizTalk Server にエラーに関する情報を提供する必要があります。 BizTalk Server は、エラー レポート機能を使用して、 **SetErrorInfo**両方のメソッド、 **IBaseMessage**と**ITransportProxy**インターフェイス。 次のようにエラーを報告できます。  
  
- メッセージの処理中に失敗したとき、設定を使用して例外**SetErrorInfo (Exception e)** メッセージ (**IBaseMessage**) を中断します。 これにより、エンジンは、エラーの後の診断メッセージを保持するために、管理者に警告をイベント ログに記録します。  
  
- 呼び出す必要があります (メッセージの処理) 中ではなく初期化または内部ブックキーピング中にエラーが発生した場合**SetErrorInfo (Exception e)** 上、 **ITransportProxy**に渡されたポインター初期化中にします。 場合は、アダプターが BaseAdapter 実装に基づいて、このポインターへのアクセスを常が必要です。 それ以外の場合、することがそれをキャッシュします。  
  
  イベント ログに書き込まれるエラー メッセージにこれらのメソッドの結果のいずれかでエラーを報告します。 これを行うことができる場合、エラーを関連するメッセージと関連付けることが重要です。  
  
## <a name="handle-a-database-offline-condition"></a>データベースがオフラインの状態を処理します。  
 BizTalk Server データベースの 1 つがオフラインになった場合、BizTalk サービスでは、自体がリサイクルされます。 メッセージング エンジンは、サービスのリサイクルの前に、すべての受信場所をシャット ダウンするために最適な努力します。 この時間が 60 秒を超える、サービスが終了します。 エンジンのトランザクションはために、データの損失は発生しません。  
  
 このタイムアウトは、キーを使用してレジストリに調整できます。  
  
```  
DWORD   
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTSSvc{Host Guid}\MessagingDBFailoverShutdownTimeLimit  
```  
  
 分離アダプターの場合は BizTalk Server は、プロセスを所有していないため、受信場所が無効に BizTalk Server データベースの 1 つがオフラインになったときです。 これらの受信場所、データベースがオンラインに戻った後に再び有効にします。  
  
## <a name="write-to-the-event-log"></a>イベント ログに書き込む  
 使用して、アダプターがイベント ログ エントリを書き込むことができます、 **IBTTransportProxy**例外で渡すインターフェイス。 ネイティブ コードで開発されたアダプターを渡す必要があります、 **IErrorInfo**インターフェイス、 **IBTTransportProxy.SetErrorInfo (例外** `e` **)** します。  
  
 メッセージング エンジンでは、アダプターに代わってイベントのイベント ログに書き込みます送信の失敗後のメッセージが、バックアップ トランスポートにメッセージを移動します。 または、メッセージを中断するアダプターの再試行時になど。 など、これらの操作、アダプターは、API を呼び出す前に、メッセージで例外を設定するだけ済みます。 次のコード フラグメントでは、これを示しています。  
  
```  
IBaseMessage msg;  
...  
// Set exception on msg to indicate why transmission failed...  
msg.SetErrorInfo(  
 new ApplicationException(  
 "The TCP connection was closed by the destination"));  
```  
  
## <a name="handle-receive-specific-batch-errors"></a>受信に固有のバッチ エラーを処理します。  
  
### <a name="handle-receive-failures"></a>ハンドルの受信エラー数  
 アダプター操作 (または操作のバッチ) を BizTalk Server に送信するときは、障害のさまざまな理由があります。 最も重要な 2 つは次のとおりです。  
  
- 受信パイプラインが失敗しました。  
  
- メッセージの発行中に、ルーティングの障害が発生しました。  
  
  メッセージング エンジンは、受信パイプラインが失敗した場合、メッセージの中断を自動的に試みます。 中断操作は常に失敗します。 など、メッセージング エンジンでは、メッセージの発行中にルーティング エラーが発生する場合、エンジンも行われませんメッセージを中断します。  
  
  メッセージが失敗する可能性が常にあります。 このような場合は、アダプターは呼び出す必要があります明示的に、 **MoveToSuspendQ** API と、メッセージの中断を試行する必要があります。 アダプターがメッセージを保留しようとすると、次のいずれかが該当します。  
  
- 同じメッセージ オブジェクトをアダプターの送信 (推奨) を中断する必要があります。  
  
- 場合は、アダプターは、新しいメッセージを作成するには、最初に送信されたメッセージのメッセージ コンテキストにポインターを含む新しいメッセージのメッセージ コンテキストを設定があります。 これは、メッセージのメッセージ コンテキストに、メッセージとエラーに関する有用な情報の多くがあるためにです。 失敗したメッセージをデバッグするには、この情報が必要です。  
  
> [!NOTE]
>  アダプターが新しいメッセージ オブジェクトを作成して、中断した場合、アダプターする必要がありますオブジェクトにコピー エラー情報、古いメッセージ オブジェクトから新しいメッセージ。  
  
 BizTalk Server で提供される HTTP アダプターなど、一部のアダプターでは、メッセージが中断されますは必要ありません。 これらのアダプターをクライアントにエラーを返すことができます。  
  
#### <a name="causes-of-failure"></a>エラーの原因  
 エラーの簡単な原因は次のように、バッチを構築、またはときに発生するエラー **ibttransportbatch::done**が呼び出されます。  
  
-   **発信に失敗しました。** **送信**呼び出しが失敗の理由の数を制限して、そのすべてが致命的な。 これらの理由は次のとおりです。  
  
-   BizTalk Server のプロセス領域で発生するメモリ不足のエラー。  
  
-   展開から、スキーマ アセンブリが削除されました。 ここで、**送信**わかりにくいエラーで失敗します。 MQSeries アダプターで、BizTalk Server から一般的なエラー例外をキャッチすると、および拡張エラー メッセージが、システム イベント ログに書き込まれます。 このメッセージは、スキーマ アセンブリが何らかの方法で、展開から削除されたことには、エラーの考えられる原因の 1 つをお勧めします。  
  
     一般的で**送信**が失敗したのと同じトランザクションを使用してメッセージを中断しようとする必要があります。  
  
-   **Ibttransportbatch::done の失敗。** **Ibttransportbatch::done**いくつかの理由の 1 つの呼び出しが失敗します。 一般に、常に 1 回試行する必要があり、中断操作が失敗した場合にのみ、トランザクションを終了します。 いずれかのエラー コードの障害から受信する可能性があります**ibttransportbatch::done** BizTalk Server がシャット ダウンしようとしていることができます。 ここでは、どうかだけにトランザクションを終了し、ためにのままに、 **Terminate**呼び出しが同時に行われている可能性があります。 バッチを適切に構築して正常に実行されるときに、その他のシナリオが発生する**ibttransportbatch::done**します。 このような場合、エラーが返される**BatchComplete**とアダプターは、それらの処理方法を決定する必要があります。 このセクションの残りの部分は、このケースを処理します。  
  
#### <a name="processing-batchcomplete-errors"></a>BatchComplete エラーの処理  
 **BatchComplete**をバッチ操作の完了状態を示すために BizTalk Server によって呼び出されるアダプターによって提供されるコールバックです。  
  
 渡される最も重要なパラメーター **BatchComplete** 、バッチの状態は、`hResult`します。 これは、バッチの成功または失敗を示します。 バッチが失敗した場合は、none、バッチ内の操作の成功したことを意味します。 アダプターがバッチの状態の構造を通過し、メッセージの失敗を判断します (これと呼ばれます*バッチのフィルター処理*)。  
  
#### <a name="nontransactional-batchcomplete-errors"></a>非トランザクション BatchComplete エラー  
 非トランザクション アダプターの場合のエラーが発生した場合、応答を選択する必要があります、 **SubmitMessage**/**SubmitRequestMessage**または**SubmitResponseMessage**操作。 アダプターが呼び出すことによって、メッセージを中断する通常**MoveToSuspendQ**します。  
  
 次の操作は常に渡すことが。**DeleteMessage**、 **MoveToSuspendQ**、 **ResubmitMessage**します。 これらの操作が失敗した場合は、通常、アダプターにバグがあることを意味します。 このような場合の障害に対処するコードを記述する必要はありません。 ただし別の操作が失敗したため、バッチが失敗した場合、これらの操作があります、新しいバッチで再実行します。  
  
 アダプターが呼び出す場合**MovetoBackupTransport** (バックアップ トランスポートがないため) 失敗すると、アダプターが呼び出す必要があります**MoveToSuspendQ**にメッセージを中断します。  
  
#### <a name="transactional-batchcomplete-errors"></a>トランザクション BatchComplete エラー  
 アダプターによって作成されたトランザクションを使用して BizTalk Server にバッチを送信するときにこれら 2 つのシナリオのいずれかに従う必要があります。  
  
-   **単一メッセージのバッチを使用します。** BizTalk Server には、単一メッセージ バッチを送信します。 その 1 つのメッセージが失敗した場合、し、合法的に送信できます BizTalk Server で、同じトランザクションで 2 番目のバッチが問題のあるメッセージを再送信するのではなく、保留キューに移動する必要があります。 失敗したメッセージが削除されると、2 番目のバッチの送信は成功します。 トランザクションをコミットするには、BizTalk Server では、ことを確認するときに発生した後は、2 番目のバッチが成功しました。 2 番目のバッチが失敗した場合、アダプターが、トランザクションを中止またはそのメッセージを配置する他の場所を検索する必要があります。 このシナリオでは、すぐにパフォーマンスに大きなトランザクションのロールバック処理が原因の影響を有効します。  
  
     アダプターのパフォーマンスを向上させるために使用できるいくつかの方法はあります。 たとえば、MQSeries アダプターは実行時にその手法を動的に調整します。 これは、100 メッセージのバッチを実行します。 エラーが発生すると、バッチを終了する必要がありますが、過去の問題のあるメッセージの取得に短時間の単一メッセージのバッチに切り替わります。 後、100 メッセージのバッチに戻されます。 もう一度、エラーが発生する場合は、もう一度ダウンを低下します。  
  
-   **プリエンプティブ中断を使用します。** エラーがあるメッセージは中断されて事前複数メッセージのバッチを構築します。 バッチが混在**送信**と**MoveToSuspendQ**操作では、最初で唯一のバッチ、トランザクションとします。 それは、不適切なデータが中断された事前 (BizTalk Server から、確認を待っている) した後、トランザクションをコミットできるために成功する必要があります。  
  
     要求するように見えるかもしれませんが、この手法は、MSMQ アダプターで使用されています。 確実に一意のメッセージ Id があることに依存します。 このアダプターは、メッセージのバッチを構築します。 エラーが発生した場合、ロールはトランザクション (およびそのため、バッチ) をバックアップが、一時的なデータ構造内のメッセージ ID を記憶します。 (この構造体が、無制限に大きくをするを防ぐために項目が削除されます一定の遅延時間。)各バッチが送信される前に、アダプターは不適切なメッセージ Id の一覧を確認します。 いずれかの場合、そのメッセージが失敗 (エラーのため、これまでに 1 回) し、プリエンプティブ中断ことがなく送信しようとしています。 を認識します。  
  
     すべてのアダプターが確実に一意のメッセージ ID を持つし、トランザクション ストアが 1 つの可能性は低くします。 このため、多くのトランザクション アダプターでは、単一メッセージ バッチの送信に制限されます。  
  
#### <a name="processing-other-errors"></a>その他のエラーの処理  
 メッセージ中断中のエラー) などの他のすべての場合、アダプターは、トランザクションを終了する必要があります。 その他の結果は、重複するか、破棄されたメッセージで発生します。  
  
 アダプターができるたびに、バッチが失敗した場合、トランザクションを中止する必要があります。 ただし、アダプターがトランザクションを中止できないシナリオがあります。 このようなシナリオで同じトランザクションを使用してメッセージを中断します。  
  
#### <a name="processing-errors-on-transactional-receive"></a>トランザクションで処理エラーが表示されます。  
 トランザクション処理の一般的なパターンでは、エラーが発生したときにトランザクションを終了します。 ここですべてのものを返しますを以前の状態とデータは失われません。 ただし、(データベースでは、ステージング テーブルから一度に 1 行を取得または MQSeries または MSMQ などのキューイング製品から一度に 1 つのメッセージをプルなど) のトランザクションのフィードからデータを利用する場合、この可能性がありますできません十分です。 単に、トランザクションを終了する戻るし、同じデータを取得、同じエラーが発生する可能性が、もう一度と、ループの繰り返しでシステムが停止します。  
  
 BizTalk Server の以前のバージョンの SQL アダプターは、この動作で付属しています。 ただし、リリース後間もなく、アダプターの動作が失敗したメッセージを中断し、トランザクションをコミットしようとする変更されました。 同じトランザクションで保留キューにメッセージを移動し、トランザクションをコミットは、損失を防止データが保存され、アダプターが過去の不適切なデータを取得することができます。  
  
 アダプターの受信部分が渡された場合、エラー メッセージに応答を**送信**メッセージ操作では、アダプターがそのエラーを処理し、メッセージを保留キューに移動する必要があります。  
  
 トランザクション オブジェクトが作成し、トランザクションでメッセージを送信アダプターのトランザクション バッチは、の場合、アダプター論理的に移動メッセージ同じトランザクションで保留キューにエラー発生時にします。 トランザクションにより、データが削除されないことと、エラーの原因となっているものデータを削除することはありません。  
  
### <a name="handle-messages-without-subscriptions"></a>サブスクリプションを使用しないメッセージを処理します。  
 BizTalk Server では、それを受け入れるように定義されたサブスクリプションがない場合、メッセージ ボックス データベースに発行されるメッセージは受け入れられません。 サブスクリプションは、いずれかのオーケストレーションによって登録されているまたは送信ポート。 複数の送信先にメッセージを送信する場合、複数のサブスクリプションを定義できます。 サブスクリプションが存在しない場合、BizTalk Server はメッセージを拒否し、中断を試行しません。 アダプターはいないこのエラーを処理し、明示的にメッセージを中断する場合、は、メッセージを削除し、データが失われる可能性があります。 もちろんトランザクション アダプターは、トランザクションを終了し、その宛先にメッセージが返される可能性があります。  
  
### <a name="support-seek-with-your-receive-stream"></a>シーク、受信 Stream のサポート  
 受信側ストリームをサポートする必要があります、**シーク**のパイプライン エラー メッセージを中断できる BizTalk Server 用のメソッド。 メッセージ ストリームはシーク不可能としている場合、BizTalk Server を実行する際にエラーが発生**シーク**します。  
  
 多くの場合をサポートしている**シーク**簡単ではありません。 ネットワークからデータをストリーミングする場合などがあります、ネットワーク リソースに戻るし、データを再度要求が困難。  
  
 BizTalk Server に付属している複数のアダプターは、BizTalk Server には、データが読み取られると、ディスク上のファイルにメッセージ データを同時にスプールされます。 これにより、使用するアダプター**シーク**(たとえば、メッセージ データのパイプライン処理) でエラーが発生した場合は、そのファイルにします。 内部的には、アダプターを使用して、 **ReadOnlySeekableStream**クラスを着信シーク可能ではないストリームをラップし、構成可能なサイズのしきい値に達したときに、ディスクにオーバーフローが発生します。 メッセージのしきい値のサイズより小さい場合は、ディスクに保存されません。  
  
### <a name="consider-user-configurable-error-handling-options"></a>ユーザー構成可能なエラー処理オプションを検討してください。  
 エラーに 1 つ正しい応答がありませんがある場合があります。 この場合、動作の間で選択するユーザー構成可能なオプションを検討してください。 MQSeries アダプターで行われます。  
  
 エラーが発生したときにメッセージを中断するアダプターを装着問題は、BizTalk Server の保留キューは、「ブラック ホール」のものです。 取り出すことが困難になりますが、キューにメッセージを取得するは比較的簡単になります。  
  
 アダプターの一部のユーザーが保留キューにまったく必要としません。 など、MQSeries アダプターの場合、ユーザーでは、次のいずれかを実行するオプションが提供されます。  
  
-   現在のトランザクションを終了し、エラーを見つけた場合自体が無効にするアダプターを設定します。  
  
-   失敗したメッセージを中断し、トランザクションをコミットします。 アダプターは BizTalk Server がメッセージを正常に中断された場合でも、します。 このアクションは、イベント ログが厳密に正しくないが発生する場合でも、顧客の要件を満たしています。  
  
### <a name="implement-receive-ordering-by-using-a-single-thread-and-waiting-on-batchcomplete"></a>受信を 1 つを使用して順序スレッドと BatchComplete を待機しています。  
 BizTalk Server へのインターフェイスは、パフォーマンスと、同時実行をサポートすることでスケール アウトする機能向けです。 ただし、(MQSeries、MSMQ などのメッセージ キュー製品からメッセージを受信するときは、必要な場合があります)、メッセージの受信を厳密に順序付けられた場合は、同時実行の一部を無効にするアダプターの追加の作業を行う必要があります。 これは、2 つの手順で実行できます。  
  
1. アダプターのすべてのデータ処理の 1 つのスレッドを使用する必要があります。  
  
2. 各バッチの処理を完了する BizTalk Server を待つ必要があります。 この要件は、重要な .NET スレッド同期プリミティブを使用して実現できます。 たとえばを使用して、 **AutoResetEvent**の場合します。  
  
   -   メイン ワーカー スレッドによってアクセスできるイベント オブジェクトを宣言し、 **BatchComplete**コールバック オブジェクト。  
  
   -   メイン ワーカー スレッドで、バッチにメッセージを通常どおり送信が呼び出して**した**バッチへの呼び出しの直前に、イベント オブジェクトに対して**ibttransportbatch::done**します。  
  
   -   呼び出す**AutoResetEvent.WaitOne**でこの同じスレッドからイベント オブジェクト。 これによって、メイン ワーカー スレッドがブロックされます。 **BatchComplete** BizTalk Server からのコールバックを呼び出して**AutoResetEvent.Set**同じイベント オブジェクトを別のメッセージを処理できるように、ワーカー スレッドのブロックを解除します。  
  
   強くお勧めする*受信の順序付け*パフォーマンスが著しく低下するので、構成可能なこのできるようにします。 ユーザーのほとんどではない場合は、多くのシナリオでは、メッセージの順序付けは必要ありません。 メッセージを中断するには、順序付けも改ページします。 でしょうは、ユーザーの構成ポイントを提供するので、最善のため、アダプターをアプリケーションに依存する、ここでは。  
  
   順序付けられた場合は、一部のお客様とを処理を停止は、アダプターを無効にするにはなく、順序付けを解除する希望が述べています。 MQSeries アダプターは、サポートする受信の順序付けは、ユーザーにこのオプションを提供します。  
  
## <a name="handle-send-specific-batch-errors"></a>特定の送信バッチ エラーを処理します。  
  
### <a name="handle-send-retry-and-batching"></a>送信再試行とバッチ処理します。  
 送信側のバッチ処理の典型的な例を次に示します。  
  
- BizTalk Server では、メッセージのバッチをアダプターにします。  
  
- アダプターは、ことが指定が、メッセージの宛先に正しく判断した場合は、BizTalk Server を示すには、その delete を実行します。 (通常どおり、いくつか削除するメッセージ任意にバッチ処理できるのパフォーマンスを向上させるためにします。)  
  
  送信側のアダプターは、メッセージの処理に失敗した場合のメッセージにいくつかのいずれかを行いますが可能性があります。  
  
- アダプターがメッセージの再試行を求めていることを BizTalk Server で知らせる必要があります。 BizTalk Server では、メッセージは自動的に再試行しません。 BizTalk Server は、再試行のカウントを保持し、この数は、メッセージ コンテキストで確認できます。  
  
- アダプターは、メッセージを処理できないことを確認できます。 この場合、アダプターでは、次のトランスポートにメッセージを移動する可能性があります。 アダプターは、これを**MoveToNextTransport**を呼び出す、**バッチ**オブジェクト。  
  
- アダプターは、保留キューにメッセージを移動することがあります。  
  
  アダプターは、メッセージに動作を決定します。 ただし、これにより、BizTalk Server のインストールをサポートしやすくするために、一貫した方法で動作するアダプターがあることをお勧めします。  
  
  以下に示すようにアダプターが動作することを強くお勧めします。 BizTalk Server に付属するアダプターは、次のように動作します。  
  
### <a name="recommended-behavior-for-handling-send-errors-in-a-batch"></a>バッチの送信エラー処理に関する推奨動作  
 送信アダプターは、いくつかのメッセージを受信しに BizTalk Server に送信します。  
  
 成功したメッセージごとに、アダプターは BizTalk Server にメッセージを削除する必要があります。 BizTalk Server へのすべての通信がバッチで行います、削除もバッチにまとめることができます。 これらは、アダプターの BizTalk Server を作成した同じバッチではありません。 関連付けられていると共に (SubmitResponse で) BizTalk サーバーに送信する必要があります (SolicitResponse シナリオの場合) のように、応答メッセージがある場合は削除します。  
  
- アダプターでメッセージ処理が成功しなかった場合は、再試行回数を確認します。  
  
  -   再試行回数を超過していない場合は、忘れずに、メッセージの再試行回数を設定すること、BizTalk Server にメッセージを再送信します。 再試行の回数と再試行間隔が、アダプターを使用する必要があります、メッセージ コンテキストを提供します。  
  
  -   再試行回数を超えているかどうかは、アダプターを使用して、メッセージの移動を試行する**MoveToNextTransport**します。 再送信し、 **MoveToNextTransport**メッセージは、BizTalk Server に同じバッチ内で削除と一緒に指定することができます。 これは必須ではありませんが、有効なことができます。  
  
- 再送信し、 **MoveToNextTransport**方法はエラーに対処するアダプター。 エラーの処理中にエラーがあります。 BizTalk Server からの応答の処理中には、この場合、(で、 **BatchComplete**メソッド) アダプターをそのエラーの処理方法を示すために BizTalk Server に対して別のバッチを作成する必要があります。  
  
   別のエラーの処理内に発生するエラーを処理するときに、次の手順に従います。  
  
  -   再送信が失敗した場合、 **MoveToNextTransport**します。  
  
  -   場合、 **MoveToNextTransport**使用して、失敗した場合、 **MoveToSuspendQ**します。  
  
  必要があります保持バッチの作成で BizTalk Server で BizTalk Server で操作の成功を受信するまで。  
  
### <a name="serialization-of-message-context-property"></a>メッセージ コンテキスト プロパティのシリアル化  
 メッセージ コンテキスト プロパティに割り当てられているすべてのオブジェクトをシリアル化する必要があります。 それ以外の場合、メッセージング エンジンは型の例外をスロー **E_NOINTERFACE**します。 この戻り値は、あいまいしようとすると、メッセージ コンテキストに割り当てられる非シリアル化可能なオブジェクトを表します。