---
title: "注文プロセス マネージャでフロー |Microsoft ドキュメント"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- process management solution tutorial, processing
- processing, processing logic
ms.assetid: e2b51eff-44b5-440f-a7d1-0872543e5f27
caps.latest.revision: "30"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 8556bce43ba4a951d0045d22f76d4bd222fcd8f2
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
---
# <a name="order-flow-through-the-process-manager"></a>プロセス マネージャでの注文の流れ
このセクションでは、どのように、Southridge Video の注文プロセス マネージャ、について説明します、 **OrderManager**オーケストレーションで、注文が処理されます。 順を追って、新しい注文のオーケストレーションでの処理過程を見ていきます。 また、オーケストレーションによって注文の更新がどのように処理されるかについても説明します。  
  
> [!NOTE]
>  ビジネス プロセス マネージャ ソリューションは、複数の種類のマネージャを使用できるように記述されていますが、実際に使用されているのは 1 つのプロセス マネージャのみです。  
  
 **OrderManager**オーケストレーションが注文を処理するビジネス プロセスを実装している下位オーケストレーションを調整します。 **OrderManager**注文を 2 つのステージを送信、注文の検証、機能グループに情報を送信、リモート処理コンポーネントを介した注文システムに注文を送信および注文履歴を更新組み合わせることで、します。 追加、削除、または変更することがなくこれらのステージを変更することができます、 **OrderManager**です。  
  
> [!NOTE]
>  規模のスコープであるため、 **OrderManager**オーケストレーション、オーケストレーションを Microsoft Visual Studio で開いてこのセクションを参照する可能性があります。  
  
## <a name="order-manager-structure"></a>注文マネージャの構造  
 **OrderManager**オーケストレーションをアクティブにする受信図形でオーケストレーションを開始します。 次の図の一般的な構造を示しています、 **OrderManager**オーケストレーションです。  
  
 ![注文マネージャーの図をブロック](../core/media/ordermanagerblockdiagram.gif "OrderManagerBlockDiagram")  
  
 最初の受信図形から 2 つの主要分岐が出ています。 右側の分岐は新しい注文を処理します。 左側の分岐は注文のキャンセルを処理します。 ユーザー入力を受け付けることはための**OrderManager**注文が既に完了した後に、取り消しを受信します。 そのようなケースを扱うのが左側の主分岐です。 左側の分岐では、処理中止のフラグを設定し、イベント ログに警告を追加して、これらのキャンセルを処理します。 右側の分岐で注文が処理されている間に到着した注文のキャンセルも、このオーケストレーションで処理されます。  
  
 注文処理の分岐は初期化の後に、入れ子構造になった 2 つのループに入ります。 外側のループは、注文処理の各ステージで 1 回実行されます。 内側のループはステージが処理される間、実行されています。 内側のループの中で、注文マネージャは注文の更新に対しても待機します。 ループが終了すると、注文マネージャは完了メッセージを送信します。  
  
 注文処理ステージへの通信、自己関連付けを行う動的なポートを使用して、 **OrderManager**オーケストレーションです。 これが簡略化の相関関係、 **OrderManager**とステージ インスタンスの関連付けセットを使用する必要がなくなるためです。 自己関連付けを行うポートの詳細については、次を参照してください。[ポートのバインド](../core/port-bindings.md)です。  
  
## <a name="receiving-orders"></a>注文の受信  
 **OrderManager**からの注文メッセージを受信、 **OrderBroker**を介してオーケストレーション、 **FromBrokerPort**ポートです。 このポートは直接メッセージ ボックス データベースにバインドされています。 2 つのオーケストレーションが**受信**図形をポートに接続されている: 新しい注文のいずれかとの 1 つの注文を更新します。  
  
 **OrderManger**フィルター式に基づくプロセスへのメッセージを決定します。 フィルター式は、メッセージの状態フィールドと注文マネージャの種類フィールドの値をテスト**OrderMgrType**です。 場合は、ステータス フィールドが ACCEPTED、および**OrderMgrType**が CABLEORDER、順序は、新しいと、このプロセス マネージャを目的としました。  
  
 新しい注文が到着すると、このオーケストレーションの新しいインスタンスがアクティブになります。 **OrderManager**の要求の種類を次にチェック、**デシジョン**図形です。 種類が TERMINATE の場合は、オーケストレーションは左側の分岐を実行して注文を終了します。 それ以外の場合は、オーケストレーションは注文の処理を進めます。 これには、この注文に関連する後続メッセージの待機も含まれることに注意してください。  
  
## <a name="initialization-for-new-orders"></a>新しい注文の初期化  
 後に、 **OrderManager**から構成情報を取得、オーケストレーションは、最初のメッセージを受信し、右側の主分岐が開始、 **SSOConfigStore**です。 これはで定義されているシングルトン オブジェクトを介して、**ユーティリティ**アセンブリ。 構成値はこのオブジェクトのプロパティです。 このオブジェクトは、構成値のローカル キャッシュをサービス指向のアーキテクチャ ソリューションと同様の方法で管理します。 シングルトン オブジェクトの詳細については、次を参照してください。[を使用して SSO の効率的なビジネス プロセス管理ソリューションで](../core/using-sso-efficiently-in-the-business-process-management-solution.md)です。  
  
 サービス指向ソリューションと同様、ビジネス プロセス管理ソリューションでも、シークレット ストアが使用されます。シークレット ストアは、BizTalk がインストールされていれば常に存在するものであり、SSO は値をすぐに使用できるように構成情報をキャッシュできます。さらに、データベース接続文字列やパスワードなどの情報の保護も可能になります。 これらの理由により、シングル サインオン (SSO) がバックエンド アプリケーションの接続管理に使用されていなくても、シークレット ストアは構成情報を保存する場所として適しています。  
  
> [!NOTE]
>  オーケストレーションは処理を開始する前に構成情報を取得します。 これによって、オーケストレーションが退避されて後で復元するときも同じ構成の使用が可能になります。 退避の詳細については、次を参照してください。[オーケストレーションの退避と復元](../core/orchestration-dehydration-and-rehydration.md)です。  
  
 注文マネージャは、構成データから 1 つの値を使用: **TotalStages**、注文プロセスを処理中のステージの合計数。 マネージャーが、ローカル変数にこの値を割り当てます**numStages**です。 また、外側のループに接続されている 2 つの変数を設定**ステージ**と**停止**です。 **ステージ**現在のステージを示し、外側のループのカウンターは、**停止**停止の値。  
  
 マネージャーが最後に、設定、 **orderStatus**変数を STARTED に外側の処理ループに入ります。  
  
## <a name="new-order-processing-loops"></a>新しい注文の処理ループ  
 外側のループを実行している間の値、**ステージ**変数がの値より小さい、 **numStages**変数。 つまり各ステージの処理は、外側のループによって進行されます。 内側のループはステージが処理されている限り実行され、 注文の変更があった場合にも備えて待機します。  
  
### <a name="outer-loop"></a>外側のループ  
 オーケストレーションが受信したメッセージを割り当てることによって、外側のループを開始 (**NewOrderMgrMsg**) の変数に**OrderMgrMsg**です。 次にメッセージのルーティングの部分にステージと状態がコピーされます。 オーケストレーションは、メッセージのアドレスをリターン アドレスを設定するも、 **StageCompletionPort**:  
  
```  
OrderMgrMsg.RoutingPart.OrderMgrReturnAddress =   
       StageCompletionPort(Microsoft.XLANGs.BaseTypes.Address);  
```  
  
 オーケストレーションに送信するように順序、 **StagePort**、送信請求-応答ポートです。 注文の処理が開始されたこと示す、ステージからの確認メッセージを待ちます。 ステージの送信、 **OrderAck**注文の処理を開始するときのメッセージします。  
  
> [!NOTE]
>  **OrderAck**メッセージは、スキーマではなく .NET クラスによって定義されているソリューション内のいくつかのいずれか。 .NET クラスを使用してメッセージを定義する方法の詳細については、次を参照してください。[ユーザー コードでメッセージを構築する](../core/constructing-messages-in-user-code.md)です。  
  
 オーケストレーションは受信確認を受け取る、ステージが割り当てられます、 **currentStage**変数内側のループに入ります。  
  
### <a name="inner-loop"></a>内側のループ  
 限り、内側のループの実行、 **currentStage**変数と等しい、**ステージ**; 変数が、現在のステージが処理されている限り、します。 ループの本体は、**リッスン**図形と 3 つ**受信**図形です。 オーケストレーションで、左端のシェイプ**発注要求**、次のセクションで説明されている注文更新メカニズムの一部です。  
  
 ときに注文処理ステージが完了すると、そのメッセージを送信する、 **StageCompletion**のポート、 **OrderManager**オーケストレーションです。 ステージ突然終了した場合、エラーのため、送信、 **TerminatedMessage**です。 ここで、 **OrderManager**例外をスローします。 最も外側の例外ハンドラーが例外をキャッチし、エラー メッセージを送信、 **OperatorPort**です。  
  
 ステージを送信する場合、 **OrderMgrMsg**、 **OrderManager**インクリメント、**ステージ**変数。 オーケストレーションが注文ステータスを設定 (stage の値以上に numStages) の段階がある場合は、 **OrderMgrMsg** STAGE_n_COMPLETED n は、現在のステージの数にします。 処理するステージがなくなると、注文の状態を COMPLETED に設定して両方のループから出ます。  
  
## <a name="order-updates"></a>注文の更新  
 **OrderManager**オーケストレーションは、内部処理ループ内の注文の更新を待機します。 注意して、**受信**これは、使用を図形**OrderRequest**も使用して、 **FromBrokerPort**です。 ループ内の同じポートで、関連付けセットと組み合わせて受信図形をもう 1 つ使用することにより、BizTalk Server 共通パターンであるコンボイ パターンが形成されます。 オーケストレーションの同じインスタンスが、特定の操作に接続された最初およびその後のメッセージを処理することを確認するのにには、コンボイ パターンを使用します。  
  
 注文マネージャが注文に接続されている最初のメッセージを受け取ると、2 つの関連付けセットが初期化されます。 最初、 **OrderCorrelation**、顧客 ID を使用して (**CustID**) と注文 ID (**OrderID**)。 注文マネージャはこの関連付けを注文処理ステージと共有します。 2 番目の相関関係は、コンボイ関連付け**OrderConvoyCorrelation**、注文ステータスを使用する (**ステータス**) に加えて、顧客 ID と注文 ID **OrderRequestReceive**図形の使用**OrderConvoyCorrelation**フォロー関連付けセットとして。 関連付けセットをこのように設定することによって、注文に変更があれば、その注文を処理している注文マネージャのインスタンスが変更内容を受信できるようになります。  
  
> [!NOTE]
>  関連付けセットは、個々のメッセージがオーケストレーションのどのインスタンスに所属するかを決定するために使用するメッセージ プロパティをグループ化したものであることに注意してください。 詳細については、次を参照してください。[オーケストレーションでの相関関係を使用して](../core/using-correlations-in-orchestrations.md)です。  
  
 ときに、 **OrderManager**後続のメッセージを受信、注文、最初のテストの要求の種類。 要求の種類が TERMINATE の場合は、決定図形が終了分岐を実行します。 それ以外の場合、オーケストレーションは新しいメッセージが更新に関するものかどうかをテストします。 更新メッセージが大きいシーケンス番号 (**SeqNum**)、元の要求よりもします。 新しいメッセージのシーケンス番号が大きければ、オーケストレーションはそのメッセージで注文処理をやり直します。 更新メッセージのシーケンス番号が元のメッセージのものより大きくない場合は、シーケンス エラーが生じます。 シーケンス番号が等しい場合は、重複注文なので重複エラーのフラグが付きます。  
  
 詳細については**SeqNum**を参照してください[キー メッセージおよびフィールド](../core/key-messages-and-fields.md)です。  
  
## <a name="final-steps"></a>最終ステップ  
 注文マネージャが動的ポートに返信アドレスを割り当てます、ループを終了するには、後も**CSRCompletionPort**です。 次に、完了状態メッセージを作成して送信し、エラーがなかったかどうかをテストします。 エラーがあった場合は、オーケストレーションが終了図形を実行します。それ以外の場合は処理が完了します。  
  
## <a name="coordinating-with-the-stages"></a>ステージとの調整  
 両方の**OrderBroker**オーケストレーションと 2 つ目の処理ステージ オーケストレーション (**CableOrder2**)、履歴データベースにエントリを作成します。 CableOrder2 オーケストレーションによって記入された履歴情報を更新する、 **OrderBroker**オーケストレーションです。 更新するには、データベース内のエントリがあることを確認するために、 **OrderBroker**データベースを使用するポートの配信通知を使用します。  
  
 構成をマッピング、 **OrderBroker** 2 つのポートを含む送信ポート グループに、履歴データベース用のポートを送信: テスト構成の 1 つのポート (**HISTORYINSERT-SP テスト**)、1 つずつ、通常構成 (**HISTORYINSERT-SP**)。 グループの両方のポートをアクティブにしておいた場合は、両方にメッセージが送信されます。 したがって、2 つの配信通知が要求されますが、処理されるのは 1 つだけです。  
  
 このような状況を避けるためには、テスト ポートを参加解除 (**HISTORYINSERT-SP テスト**)、またはアプリケーションのテスト版を停止します。 配信通知の詳細については、次を参照してください。[を使用して受信確認](../core/using-acknowledgments.md)です。  
  
## <a name="errors-and-routing-repaired-messagesdesign-choices"></a>エラーおよびルーティングの修復済みメッセージ: デザインの選択  
 例外ハンドラ オーケストレーションと注文処理ステージで使用されるオーケストレーションは、エラー処理オーケストレーションを使用して (**ErrorHandlerOrch**) 修復のための不適切な注文をルーティングします。 このデザインでは、必要とされているフォームで注文を訂正する部署またはグループがあることが前提となっています。 注文ブローカのオーケストレーションから修復された注文が再送信されていない (**OrderBroker**)。 注文は正規化されたフォームで修復されます。 ソリューションの現在のデザインでは、処理オーケストレーションが元の注文の送信元へエラー メッセージを回送します。 ただし、修復された注文は、エラー処理オーケストレーションの MSMQ ポートに回送される必要があります (ソリューションのテスト バージョンはファイル フォルダを使用します)。その後、エラー処理オーケストレーションは修復されたメッセージを呼び出し元のオーケストレーションに返します。  
  
 このようなデザインが使用されている理由は、注文ブローカが注文メッセージの検証と正規化を行う重要な役割を担っているからです。 修復を必要とする注文メッセージも正規化されたフォームです。 メッセージの正規化されたフォームを維持することによって、メッセージの送信フォームと正規化フォームの違いに煩わされずに済みます。  
  
## <a name="see-also"></a>参照  
 [プロセス マネージャのロジック](../core/process-manager-logic.md)   
 [キー メッセージおよびフィールド](../core/key-messages-and-fields.md)