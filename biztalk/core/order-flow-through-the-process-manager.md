---
title: 注文プロセス マネージャでフロー |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- process management solution tutorial, processing
- processing, processing logic
ms.assetid: e2b51eff-44b5-440f-a7d1-0872543e5f27
caps.latest.revision: 30
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: a9c272f8b9aaf179a7d9db395a1ad1e884567c3f
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65262907"
---
# <a name="order-flow-through-the-process-manager"></a>プロセス マネージャでの注文の流れ
このセクションでは、Southridge Video の注文プロセス マネージャの場合は、する方法について説明します、 **OrderManager**オーケストレーションで、注文が処理します。 このセクションでは、オーケストレーションを新しい順序に従います。 セクションでは、オーケストレーションが注文の更新を処理する方法についても説明します。  
  
> [!NOTE]
>  ビジネス プロセス マネージャのソリューションには、マネージャーの 1 つ以上の型を使用できるように記述されていますが、1 つだけのプロセス マネージャが含まれています。  
  
 **OrderManager**オーケストレーションが注文を処理するために、ビジネス プロセスを実装する下位のオーケストレーションを調整します。 **OrderManager**注文を 2 つのステージに送信順序を検証、機能グループに、情報を送信、リモート処理コンポーネントを介した注文システムに注文を送信および注文履歴を更新、します。 追加、削除、または変更することがなくこれらのステージを変更することができます、 **OrderManager**します。  
  
> [!NOTE]
>  サイズとスコープのため、 **OrderManager**オーケストレーション、オーケストレーションを Microsoft Visual Studio で開いてこのセクションを参照する可能性があります。  
  
## <a name="order-manager-structure"></a>注文マネージャの構造  
 **OrderManager**受信図形をオーケストレーションをアクティブにするオーケストレーションを開始します。 次の図の一般的な構造を示しています、 **OrderManager**オーケストレーションします。  
  
 ![注文マネージャーの図の block](../core/media/ordermanagerblockdiagram.gif "OrderManagerBlockDiagram")  
  
 最初の受信図形は、2 つのメイン分岐につながります。 1 つの分岐では、右側の 1 つは、新しい注文を処理します。 左の分岐では、注文のキャンセルを処理します。 ことは、ユーザー入力を受け入れるため、 **OrderManager**注文が既に完了した後に、注文のキャンセルを受信します。 これは、ような場合、左側のメイン ブランチのハンドル。 分岐は、処理中止のフラグを設定し、イベント ログに警告を追加することで、独立したキャンセルを処理します。 オーケストレーションでは、右側の分岐で注文の処理中に到着した注文の取り消しを処理します。  
  
 注文処理の分岐は、なんらかの初期化を行い、2 つの入れ子になったループを次に、入力します。 外側のループは、注文処理の各ステージに 1 回実行します。 内側のループはステージが処理中に実行されます。 注文マネージャは、内側のループ内で注文の更新に対してもリッスンします。 ループが終了した後、注文マネージャは、完了のメッセージを送信します。  
  
 注文処理ステージが通信するために、自己関連付けを行う動的なポートを使用して、 **OrderManager**オーケストレーションします。 こうことの相関関係、 **OrderManager**とステージ インスタンスが、関連付けセットを使用する必要があるためです。 自己関連付けを行うポートの詳細については、次を参照してください。[ポートのバインド](../core/port-bindings.md)します。  
  
## <a name="receiving-orders"></a>注文の受信  
 **OrderManager**からの注文メッセージを受信、 **OrderBroker**を介してオーケストレーション、 **FromBrokerPort**ポート。 このポートは、メッセージ ボックス データベースに直接バインドされます。 オーケストレーションが 2 つあります**受信**図形をポートに接続されている: 新しい注文のいずれかとに 1 つは注文を更新します。  
  
 **OrderManger**フィルター式に基づくプロセスへのメッセージを決定します。 フィルター式は、メッセージの状態フィールドと注文マネージャの種類フィールドの値をテスト**OrderMgrType**します。 状態フィールドが ACCEPTED でに等しい場合、 **OrderMgrType**が CABLEORDER、順序は、新しいと、このプロセス マネージャーの目的です。  
  
 新しい順序は、オーケストレーションの新しいインスタンスをアクティブにします。 **OrderManager**で要求の種類を次にチェックを**デシジョン**図形。 種類が Terminate の場合は、オーケストレーションは左側の分岐を実行し、順序を終了します。 それ以外の場合、オーケストレーションは、注文の処理を続行します。 この特定の順序に関連する後続のメッセージの待機を含むことに注意してください。  
  
## <a name="initialization-for-new-orders"></a>新しい注文の初期化  
 後に、 **OrderManager**から構成情報を取得、オーケストレーションが最初のメッセージを受信し、右側の主分岐を開始、 **SSOConfigStore**します。 これはで定義されているシングルトン オブジェクトを介して、**ユーティリティ**アセンブリ。 構成値は、オブジェクトのプロパティです。 オブジェクトは、サービス指向アーキテクチャ ソリューションのような構成値のローカル キャッシュを管理します。 シングルトン オブジェクトの詳細については、次を参照してください。[を使用して SSO の効率的なビジネス プロセス管理ソリューションで](../core/using-sso-efficiently-in-the-business-process-management-solution.md)します。  
  
 値はすぐに使用して保護できますように BizTalk がインストールされているときに存在するために、シークレットが格納するビジネス プロセス管理ソリューションは、サービス指向ソリューションと同様に SSO が構成情報をキャッシュします。データベース接続文字列やパスワードなどの情報。 これらの理由からすべてのシークレット ストアなる適切な場所の構成情報でシングル サインオンでした。 バックエンド アプリケーションへの接続を管理するため使用されている場合でもです。  
  
> [!NOTE]
>  オーケストレーションでは、処理を開始する前に構成情報を取得します。 これにより、オーケストレーションが退避され、後で、リハイド レートする場合、同じ構成を使用します。 退避の詳細については、次を参照してください。[オーケストレーションの退避と復元](../core/orchestration-dehydration-and-rehydration.md)します。  
  
 注文マネージャは、構成データから 1 つの値を使用します。**TotalStages**、注文処理過程で、ステージの合計数。 マネージャーは、ローカル変数にこの値を割り当てます**numStages**します。 また、外側のループに接続されている 2 つの変数を設定**ステージ**と**停止**します。 **ステージ**外側のループのカウンターを現在のステージを示します**停止**"stopping"の値。  
  
 マネージャーが最後に、設定、 **orderStatus**変数を STARTED 外側の処理ループに入るとします。  
  
## <a name="new-order-processing-loops"></a>新しい注文の処理ループ  
 外側のループの実行の値として long、**ステージ**変数がの値より小さい、 **numStages**変数。 外側のループでは、各ステージの処理をドライブします。 ステージがまだ処理されている限り、内側のループが実行されます。 また、順序変更があった場合もリッスンします。  
  
### <a name="outer-loop"></a>外側のループ  
 オーケストレーションが受信したメッセージを割り当てることで、外側のループを開始 (**NewOrderMgrMsg**)、変数に**OrderMgrMsg**します。 また、メッセージのルーティングの部分には、ステージと状態のコピーされます。 オーケストレーションがメッセージのアドレスにもリターン アドレスを設定、 **StageCompletionPort**:  
  
```  
OrderMgrMsg.RoutingPart.OrderMgrReturnAddress =   
       StageCompletionPort(Microsoft.XLANGs.BaseTypes.Address);  
```  
  
 次にオーケストレーションは注文を送信する、 **StagePort**、送信請求-応答ポート。 オーケストレーションは注文処理が開始されたステージからの受信確認を待機します。 ステージの送信、 **OrderAck**注文の処理を開始するときのメッセージします。  
  
> [!NOTE]
>  **OrderAck**メッセージは、スキーマではなく .NET クラスによって定義されているソリューションでいくつかのいずれか。 .NET クラスを使用してメッセージを定義する方法の詳細については、次を参照してください。[ユーザー コードでのメッセージの構築](../core/constructing-messages-in-user-code.md)します。  
  
 オーケストレーションは受信確認を受け取る、ステージが割り当てられます、 **currentStage**変数と、内側のループに入ります。  
  
### <a name="inner-loop"></a>内側のループ  
 限り、内側のループの実行、 **currentStage**変数と等しい、**ステージ**; 変数は、現在のステージが処理されている限り、します。 ループの本体は、**リッスン**図形と 3 つ**受信**図形。 オーケストレーションで、左端の図形**発注要求**は、次のセクションで説明されている注文更新メカニズムの一部です。  
  
 ときに注文処理ステージが完了すると、そのメッセージを送信する、 **StageCompletion**のポート、 **OrderManager**オーケストレーションします。 ステージは、エラーのため突然終了する場合は、送信、 **TerminatedMessage**します。 ここで、 **OrderManager**例外をスローします。 最も外側の例外ハンドラーが例外をキャッチし、エラー メッセージを送信、 **OperatorPort**します。  
  
 ステージを送信する場合、 **OrderMgrMsg**、 **OrderManager**インクリメント、**ステージ**変数。 オーケストレーションが注文の状態を設定 (stage の値以下に numStages) の段階がある場合は、 **OrderMgrMsg**を STAGE_n_COMPLETED n は現在のステージの数です。 なしの段階がある場合を完了、注文ステータスを設定して、両方のループを終了します。  
  
## <a name="order-updates"></a>注文の更新プログラム  
 **OrderManager**オーケストレーションは内側の処理ループで注文の更新をリッスンします。 注意して、**受信**これは、使用を図形**OrderRequest**を使用しても、 **FromBrokerPort**します。 関連付けセットと組み合わせて、ループ内で同じポート上の 2 番目の受信図形の使用は、一般的な BizTalk Server パターンでは、コンボイ パターンを形成します。 オーケストレーションの同じインスタンスが、特定の操作で接続されている最初と後続のメッセージを処理することを確認するのにには、コンボイ パターンを使用します。  
  
 注文マネージャは、注文に接続されている最初のメッセージを受信した場合は、2 つの関連付けセットを初期化します。 まず、 **OrderCorrelation**、顧客 ID を使用して (**CustID**) と注文 ID (**OrderID**)。 注文マネージャは、この関連付けを注文処理ステージと共有します。 2 番目の相関関係はコンボイ関連付けの**OrderConvoyCorrelation**、注文ステータスを使用する (**状態**) だけでなく、顧客 ID と注文 ID **OrderRequestReceive**図形の使用**OrderConvoyCorrelation**フォロー関連付けセットとして。 関連付けセットをこのように設定により、特定の順序で作業注文マネージャのインスタンスがすべての変更を受信します。  
  
> [!NOTE]
>  関連付けセットは、メッセージがオーケストレーションの特定のインスタンスに属するかどうかを判断するために使用するメッセージ プロパティのグループを思い出してください。 詳細については、次を参照してください。[オーケストレーションでの相関関係を使用して](../core/using-correlations-in-orchestrations.md)します。  
  
 ときに、 **OrderManager**後続のメッセージを受信する注文が最初のテストの要求の種類。 要求の種類が TERMINATE の場合は、判断図形は終了分岐を実行します。 それ以外の場合、オーケストレーションは、更新プログラムが新しいメッセージをテストします。 更新メッセージが大きいシーケンス番号 (**SeqNum**) 元の要求よりもします。 新しいメッセージのシーケンス番号が大きい場合は、オーケストレーションは注文に新しいメッセージが経由で処理を開始します。 場合、元の更新メッセージは、同じまたは低いシーケンス番号があるとは、シーケンス エラーが発生します。 シーケンス番号が等しい場合は重複する注文と、重複エラー フラグが設定されます。  
  
 詳細については**SeqNum**を参照してください[キーのメッセージとフィールド](../core/key-messages-and-fields.md)します。  
  
## <a name="final-steps"></a>最後の手順  
 注文マネージャが動的ポートに応答アドレスを割り当てます、ループを終了した後**CSRCompletionPort**します。 マネージャーには、完了状態メッセージを作成、送信にエラーが発生する場合をテストします。 終了図形。 オーケストレーションのあった、エラーが発生した場合それ以外の場合、単純に終了します。  
  
## <a name="coordinating-with-the-stages"></a>ステージとの調整  
 両方の**OrderBroker**オーケストレーションと 2 つ目の処理ステージ オーケストレーション (**CableOrder2**) 履歴データベースにエントリを作成します。 CableOrder2 オーケストレーションが入力した履歴情報を更新する、 **OrderBroker**オーケストレーションします。 更新するには、データベース内のエントリがあることを確認するには、 **OrderBroker**データベース用に使用するポートの配信通知を使用します。  
  
 マップの構成、 **OrderBroker** 2 つのポートを含む送信ポート グループに、履歴データベース用のポートを送信: テスト構成の 1 つのポート (**HISTORYINSERT-SP テスト**)、1 つずつ、通常構成 (**HISTORYINSERT-SP**)。 グループの両方のポートをアクティブのままにした場合、ソリューションは、両方のポートでメッセージを送信します。 したがって、2 つの配信通知を要求する、1 つのみを処理します。  
  
 このような状況を避けるためには、テスト ポートを参加解除 (**HISTORYINSERT-SP テスト**)、またはアプリケーションのテスト バージョンを停止します。 配信通知の詳細については、次を参照してください。[を使用して受信確認](../core/using-acknowledgments.md)します。  
  
## <a name="errors-and-routing-repaired-messagesdesign-choices"></a>エラーおよびルーティングの修復済みメッセージ: デザインの選択  
 エラー処理オーケストレーションを使用して、例外ハンドラ オーケストレーションと注文処理ステージで使用されるオーケストレーション (**ErrorHandlerOrch**) 修復の不正な注文をルーティングします。 デザインは supposes は部署またはグループに必要な形式で順序を修正します。 修復された注文が注文ブローカのオーケストレーションを再送信されていない (**OrderBroker**)。 代わりに、正規化された注文は正規化されたフォームで修復されます。 現在のソリューションのデザインでは、元の順序のソースに、エラー メッセージをルーティング ハンドラー オーケストレーションがあります。 ただし、修復された注文は、エラー ハンドラー オーケストレーションの MSMQ ポートにルーティングする必要があります。 (ソリューションのテスト バージョンは、ファイルのフォルダーを使用します)。エラー ハンドラーは、呼び出し元オーケストレーションに修復されたメッセージを返します。  
  
 このソリューションは、注文ブローカは注文メッセージの重要な検証と正規化するためにこの設計を使用します。 一方、修復を必要とする注文メッセージは、正規化された形式でも。 メッセージの正規化されたフォームを維持するには、メッセージの送信済みおよび正規化された形式間の違いを回避することができないようにします。  
  
## <a name="see-also"></a>参照  
 [プロセス マネージャのロジック](../core/process-manager-logic.md)   
 [主要メッセージとフィールド](../core/key-messages-and-fields.md)