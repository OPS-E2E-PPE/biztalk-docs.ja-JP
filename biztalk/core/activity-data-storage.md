---
title: アクティビティ データのストレージ |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- performance, BAM
- databases [BAM], performance
- activities [BAM], peformance
- databases [BAM], partitioning
- BAM, performance
ms.assetid: 1f736599-3d16-496e-a459-8b0507d57fcb
caps.latest.revision: 6
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: cd0a4744f5022bfdc466460a25def23ea362d7b6
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65361687"
---
# <a name="activity-data-storage"></a>アクティビティ データのストレージ
このトピックでは、アクティビティ データ ストレージ、時間の経過と共にアクティビティ テーブルの増加率および BAM が進行中のアクティビティと完了したアクティビティの別個のテーブルでこれらのパフォーマンス問題を解決する方法に起因するパフォーマンスの問題について説明します。 このトピックでは、データ、およびパフォーマンスの向上、BAM でパーティション分割を使用する方法を照会するためのオンライン時間帯にも説明します。  
  
 アクティビティ データのストレージの基本的な考え方では、各レコードは、さまざまなアクティビティのインスタンス (たとえば、進行中または完了) を表します。 各アクティビティの種類に個別のテーブルです。  
  
 この例では、アクティビティが注文書と、テーブルは、次のようになります。  
  
|PO #|受け取ら|City|Quantity|時間|DeliveryTime|  
|----------|--------------|----------|--------------|--------------|------------------|  
|123|8時 00分 am|Seattle|150|8時 24分 am|12時 45分 pm|  
|124|8時 30分 am|Seattle|234|8時 45分 am|午後 1時 20分|  
|125|午前 8時 35分|Redmond|87|9時 05分 am|2時 30分 pm|  
|126|8時 45分 am|Seattle|450|9時 20分 am|3時 10分 pm|  
|127|午前 8 時 55|Redmond|200|午前 9時 30分|\<NULL\>|  
|128|午前 8時 57分|Seattle|340|9時 20分 am|3時 05分 pm|  
|129|午前 9時 12分|Seattle|120|9時 45分 am|\<NULL\>|  
|130|午前 9時 30分|Redmond|25|10時 15分 am|\<NULL\>|  
|131|9:45|Seattle|250|午前 10時 35分|\<NULL\>|  
|132|午前 10時 00分|Redmond|100|\<NULL\>|\<NULL\>|  
|133|10時 15分 am|Seattle|230|\<NULL\>|\<NULL\>|  
|134|10時 25分 am|Redmond|45|\<NULL\>|\<NULL\>|  
  
 このテーブルでは、新しい行を挿入 BAM では、新しい注文を受信するとされ、一部の列が null 以外の値 (受け取ら、市、数量、およびなど) に設定します。 後で、承認し、この注文の出荷すると、BAM は時間を null 以外の値に設定します。 最後に、受信、収録されていることを確認すると、BAM は DeliveryTime を null 以外の値に設定します。  
  
 この簡単な実装のパフォーマンスは、すぐに、時間の経過と共に低下します。 最初は、パフォーマンスによって制限されます (基本的にバインドされている CPU) を実行できる SQL server トランザクションの数がいくつかの時間、急速に低下します。 同時に、ディスク IO のキューの平均の長さが許容される上限を超えて増加します。  
  
 ![](../core/media/ebiz-prog-bam-data-maint-fig4.gif "ebiz_prog_bam_data_maint_fig4")  
BAM の書き込みのパフォーマンスとディスク キューの長さ  
  
 この理由は、テーブルのサイズ拡張するビジネス プロセスのインスタンス完了です。 など、最初にストアド プロシージャが発生したため、UPDATE ステートメントのクラスター化インデックスで検索を発注書番号とメモリの一部のページを読み取ります。 発注プロセスのインスタンスは独立したので (、時間がかかるものがいくつか短い) ストアド プロシージャを次に呼び出した他のいくつかの注文書インスタンスの場合があり、そのため、メモリ内の別のデータ ページの読み取りが必要です。 注文書レコードの合計数が小さい場合に限り、SQL Server はメモリ内のすべてのデータ ページをキャッシュします。 レコードの数が十分な大きさが増加するとは、キャッシュ ヒット率が低下し、各操作には、物理ディスクの読み取りが必要です。 どうやらこれは、このような状況で、テーブルに対するクエリ アクティビティはありません。  
  
## <a name="bam-tables"></a>BAM テーブル  
 BAM この問題を回避するには、次の図に完了したものに – 実行中、アクティビティのいずれかのもう 1 つの 2 つの独立したテーブルを使用します。  
  
 ![](../core/media/ebiz-prog-bam-data-maint-fig5.gif "ebiz_prog_bam_data_maint_fig5")  
BAM テーブル  
  
 この図では、考え方は、比較的小さなテーブルで発生する更新プログラムを維持して、大きくが段階的に、別のアクセス (Insert のみ)。 例では、現時点で処理される注文のみ既に配信されているすべての注文は、完了したテーブルに移動中に作業中のテーブル内になります。  
  
 トリガーによりこのテーブルの構造は開始時に、1 つのテーブルの挿入/更新よりも遅くなりますが、時間の経過と共に、安定した書き込みパフォーマンスを維持します。  
  
## <a name="online-window-for-activity-data"></a>アクティビティ データのオンライン ウィンドウ  
 アクティビティのストレージは、主に、現在または最近完了したアクティビティのクエリを処理します。 BAM をアーカイブして、BAM プライマリ インポート データベースから非常に古い、完了したアクティビティを削除します。 したがって、アクティビティ データは BAM 経由で流れるし、は構成可能なオンライン時間帯の中にクエリで使用できます。  
  
## <a name="bam-partitioning"></a>BAM のパーティション分割  
 ダウンタイムを回避してパフォーマンスを向上できるように、アクティビティのストレージは、アクティビティが完了したときに、タイムスタンプに基づくパーティション分割を使用します。 BAM は、これが完了したテーブルを同一フォーマットの空のテーブルとの定期的に交換を実現します。 BAM がこの後、古いパスワードを次の図のように、クエリのためだけに保持されます、新しいテーブルにさらに完了した活動が移動します。  
  
 ![](../core/media/ebiz-prog-bam-data-maint-fig8.gif "ebiz_prog_bam_data_maint_fig8")  
BAM のパーティション交換  
  
 パーティションは、オンライン時間帯の外部完全には、BAM アーカイブして、それを削除します。 BAM には、ユーザーからこのような複雑さを最小限に抑えるには、フォームのパーティション分割されたビューも保持されます。  
  
```  
SELECT * FROM Active   
UNION ALL   
SELECT * FROM Completed   
UNION ALL  
  
```  
  
 BAM に自動的に再作成このビューを作成またはパーティションを削除するたびにします。  
  
 BAM のパーティション分割については、次に注意してください。  
  
-   パーティション ビューの名前は**bam _\<ActivityName\>_AllInstances**します。 このビューは、直接クエリでは、ものではありませんが、BAM の構成のトラブルシューティングを行う際に役立つ可能性があります。 このビューの上部に作成するビジネス ユーザーの各カテゴリの特定のビューからデータを照会する必要があります。 詳細については、次を参照してください。[インスタンス データのクエリを実行する](../core/querying-instance-data.md)します。  
  
-   値を変更することにより、オンライン時間帯を設定する**OnlineWindowTimeUnit**と**OnlineWindowLength**テーブルの現在のアクティビティのレコードの**bam_Metadata_Activities**プライマリ インポート データベースにします。  
  
-   DTS パッケージ、 **bam_dm _\<ActivityName\>** アーカイブや削除、パーティション分割を実行します。 このパッケージが実行されるたびに、別のパーティションを切り捨てます、外部のオンライン時間帯にあるすべてのパーティションのアーカイブおよび削除します。  
  
-   アーカイブ データベースを構成しない場合、BAM はアーカイブしないで、期限切れのアクティビティ データを削除します。  
  
## <a name="see-also"></a>参照  
 [BAM 動的インフラストラクチャ](../core/bam-dynamic-infrastructure.md)