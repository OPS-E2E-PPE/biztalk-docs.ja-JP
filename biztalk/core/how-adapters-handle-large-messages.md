---
title: "アダプターがサイズの大きいメッセージを処理する方法 |Microsoft ドキュメント"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: c48671fd-b6cf-4507-92b4-35a4cd135714
caps.latest.revision: "15"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: fccfd1e988dc1395f14d6eb92a980ede184d0e0f
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
---
# <a name="how-adapters-handle-large-messages"></a><span data-ttu-id="4a8bb-102">アダプターがサイズの大きいメッセージを処理する方法</span><span class="sxs-lookup"><span data-stu-id="4a8bb-102">How Adapters Handle Large Messages</span></span>
<span data-ttu-id="4a8bb-103">BizTalk メッセージング エンジンでは、サイズが非常に大きいメッセージを処理でき、メッセージの最大サイズに制限はありません。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-103">The BizTalk Messaging Engine can process very large messages and imposes no restriction on the maximum size of a message.</span></span> <span data-ttu-id="4a8bb-104">ただし、最適なパフォーマンスとリソース管理を維持するにはメッセージ サイズの制限を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-104">However, you should consider limits to message size to maintain optimum performance and resource management.</span></span> <span data-ttu-id="4a8bb-105">メッセージ サイズが大きくなると、1 秒あたりの処理メッセージ数は減少します。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-105">As message size increases the number of messages processed per second decreases.</span></span> <span data-ttu-id="4a8bb-106">シナリオを設計し容量を計画するときには、[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] で処理される平均的なメッセージ サイズ、メッセージの種類、およびメッセージの数を検討してください。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-106">Consider the average message size, message type, and number of messages being processed by [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] when designing your scenario and planning for capacity.</span></span>  
  
## <a name="stream-based-processing"></a><span data-ttu-id="4a8bb-107">ストリーム ベースの処理</span><span class="sxs-lookup"><span data-stu-id="4a8bb-107">Stream-Based Processing</span></span>  
 <span data-ttu-id="4a8bb-108">アダプターの開発時にサイズの大きなメッセージの処理を考慮することは重要です。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-108">It is important to keep large message handling in mind when developing adapters.</span></span> <span data-ttu-id="4a8bb-109">サイズに関係なくデータ ストリーム全体をメモリに読み込むことは、BizTalk Server の処理が停止する可能性があるのでお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-109">Loading the entire data stream into memory regardless of its size is strongly discouraged because this could potentially stop the BizTalk Server process.</span></span> <span data-ttu-id="4a8bb-110">BizTalk メッセージング エンジンで処理されるメッセージのサイズと数によっては、仮想メモリが不足し問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-110">Depending on the size and number of messages that the engine is processing at any given time, low virtual memory could become a problem.</span></span> <span data-ttu-id="4a8bb-111">メッセージは全体をメモリに読み込むのではなく、次のようにストリーム方式で処理してください。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-111">Instead, messages should be processed in a streaming fashion as follows:</span></span>  
  
-   <span data-ttu-id="4a8bb-112">**メッセージを受信します。**</span><span class="sxs-lookup"><span data-stu-id="4a8bb-112">**Inbound messages.**</span></span> <span data-ttu-id="4a8bb-113">受信メッセージの場合、受信アダプターではネットワーク ストリームを BizTalk メッセージに関連付け、ストリームの "抽出" は BizTalk メッセージング エンジンで行います。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-113">For inbound messages the network stream is attached to the BizTalk message by the receive adapter leaving the "pulling" of the stream to the BizTalk Messaging Engine.</span></span>  
  
-   <span data-ttu-id="4a8bb-114">**送信メッセージ。**</span><span class="sxs-lookup"><span data-stu-id="4a8bb-114">**Outbound messages.**</span></span> <span data-ttu-id="4a8bb-115">送信メッセージの場合、ストリームの抽出はアダプターで行います。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-115">For outbound messages the adapter is responsible for pulling the stream.</span></span> <span data-ttu-id="4a8bb-116">この方法により、メッセージ ボックス データベースから送信パイプラインを介して効率的にストリームが抽出されます。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-116">This effectively pulls the stream from the MessageBox database and though the send pipeline.</span></span> <span data-ttu-id="4a8bb-117">さらに、アダプターから外部にストリーム方式でデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-117">The adapter should send the data over the wire in a streaming fashion.</span></span>  
  
 <span data-ttu-id="4a8bb-118">次の図に、メッセージング エンジンの受信側におけるストリーム ベースの処理を示します。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-118">The following figure shows stream-based processing on the receive side of the Messaging Engine.</span></span>  
  
 ![](../core/media/streambasedprocessing.gif "Streambasedprocessing")  
  
 <span data-ttu-id="4a8bb-119">アダプターでは、メッセージング エンジンにメッセージを送信するときに、データ ストリームを BizTalk メッセージに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-119">When an adapter submits a message to the engine it should attach its data stream to the BizTalk message.</span></span> <span data-ttu-id="4a8bb-120">一部のアダプターでは、これはネットワーク ストリームの実装となります。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-120">For some adapters this may mean implementing a network stream.</span></span> <span data-ttu-id="4a8bb-121">アダプターからメッセージが送信されると、メッセージング エンジンでは受信パイプラインを実行します。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-121">When the message is submitted, the engine executes the receive pipeline.</span></span> <span data-ttu-id="4a8bb-122">パイプラインの実行中、データの変更を必要とするパイプライン コンポーネントによってメッセージが複製され、新しいメッセージのストリームが前のメッセージのストリームに結合されます。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-122">During pipeline execution, the pipeline components that want to change the data clone the message, wiring up the stream from the new message to the stream on the previous message.</span></span> <span data-ttu-id="4a8bb-123">パイプラインの実行後、メッセージング エンジンでパイプラインからメッセージを取り出し、そのメッセージのストリームを繰り返し読み込みます。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-123">After the pipeline has been executed, the Messaging Engine takes a message out of the pipeline and executes a loop reading the stream on that message.</span></span> <span data-ttu-id="4a8bb-124">つまり、前のストリームの読み込みを呼び出し、その読み込みによってさらに前のストリームの読み込みを呼び出すという方法で、ネットワーク ストリームまでさかのぼります。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-124">This reading of the stream invokes a read on the previous stream, which in turn invokes a read on the previous stream, and so on back to the network stream.</span></span> <span data-ttu-id="4a8bb-125">メッセージング エンジンでは読み込んだデータを定期的にメッセージ ボックスにフラッシュし、フラット メモリ モデルを維持します。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-125">The engine periodically flushes the data to the MessageBox to maintain a flat memory model.</span></span>  
  
 <span data-ttu-id="4a8bb-126">**トラブルシューティングのヒント:**送信側では、アダプターがストリームの読み取りを行う。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-126">**Troubleshooting Tip:** On the send side, the adapter is responsible for reading the stream.</span></span> <span data-ttu-id="4a8bb-127">送信パイプラインによって昇格または書き込みが行われるメッセージ コンテキスト プロパティを、送信アダプターが読み込む場合、これらのプロパティはストリーム全体が読み込まれるまで書き込まれません。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-127">If the send adapter wants to read any message context properties that are promoted or written in the send pipeline, these properties may not be written until the entire stream is read.</span></span> <span data-ttu-id="4a8bb-128">ストリームが完全に読み込まれて初めて、アダプターではすべてのパイプライン コンポーネントの実行が完了したことを確認できます。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-128">Only when the stream has been completely read can the adapter be sure that all of the pipeline components have finished executing.</span></span>  
  
## <a name="locating-a-specific-byte-in-the-stream"></a><span data-ttu-id="4a8bb-129">ストリーム内の特定バイトの指定</span><span class="sxs-lookup"><span data-stu-id="4a8bb-129">Locating a Specific Byte in the Stream</span></span>  
 <span data-ttu-id="4a8bb-130">シナリオによっては、エラーによって中断されるメッセージを処理するために、アダプターが、ストリームを先頭方向に向かって検索する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-130">There are scenarios in which an adapter may need to locate the stream back to the beginning to handle failed messages that need to be suspended.</span></span> <span data-ttu-id="4a8bb-131">この例として、チャンク エンコードを使用してデータを受信し、送信請求 - 応答の組み合わせで応答メッセージを送信する HTTP アダプターがあります。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-131">An example of this is an HTTP adapter that is receiving data using chunked encoding to submit the response message in a solicit-response pair.</span></span>  
  
 <span data-ttu-id="4a8bb-132">ただし、多くのシナリオではデータ ストリームを追跡できません。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-132">However, in many scenarios you may not be able to trace the data stream.</span></span> <span data-ttu-id="4a8bb-133">たとえば、チャンク エンコードを使用してデータを受信する HTTP アダプターの場合、</span><span class="sxs-lookup"><span data-stu-id="4a8bb-133">For example, consider an HTTP adapter receiving data using chunked encoding.</span></span> <span data-ttu-id="4a8bb-134">エラーが発生したメッセージを検出できるようデータ ストリームを設計するには、アダプターでデータを読み込むたびにメモリまたはディスクにキャッシュする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-134">For the data stream to be designed so you can find the messages that failed, the adapter would need to cache the data as it is read, either in memory or onto disk.</span></span> <span data-ttu-id="4a8bb-135">これは明らかに最適な処理でなく、余分なリソースを必要とします。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-135">Clearly this is not optimal and requires additional resources.</span></span> <span data-ttu-id="4a8bb-136">また、追加設定なしで使用できるパイプライン コンポーネントの多くは順方向専用のストリーミング方式で動作します。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-136">Further, many of the out-of-the-box pipeline components operate in a forward-only streaming fashion.</span></span> <span data-ttu-id="4a8bb-137">このようなシナリオと呼ばれるヘルパー クラスが使用 SDK の BaseAdapter **VirtualStream**です。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-137">For these scenarios the BaseAdapter in the SDK uses a helper class called **VirtualStream**.</span></span> <span data-ttu-id="4a8bb-138">この機能を含むファイルは VirtualStream.cs という名前で用意されています。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-138">The file that contains this functionality is named VirtualStream.cs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4a8bb-139">VirtualStream.cs ファイルは、パイプラインの SDK サンプルの 2 つの場所にある — \samples\pipelines\arbitraryxpathpropertyhandler および \samples\pipelines\schemaresolvercomponent\schemaresolverflatfiledasm です。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-139">The VirtualStream.cs file is located in two locations under the Pipelines SDK Samples—SDK\Samples\Pipelines\ArbitraryXPathPropertyHandler and SDK\Samples\Pipelines\SchemaResolverComponent\SchemaResolverFlatFileDasm.</span></span>  
  
 <span data-ttu-id="4a8bb-140">仮想ストリームは、ストリーム内のデータをしきい値までメモリ ストリームにキャッシュし、しきい値を超えた分を安全なディスク上の場所にオーバーフローさせるという概念に基づいています。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-140">The idea behind a virtual stream is that the data in the stream is cached in a memory stream until it reaches a threshold, over which the data is overflowed to a secure location on disk.</span></span> <span data-ttu-id="4a8bb-141">ストリームが閉じられると、ディスク上のオーバーフロー ファイルは自動的に削除されます。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-141">After the stream is closed the disk file is automatically deleted.</span></span> <span data-ttu-id="4a8bb-142">順方向専用のストリームはこの方法で設計できます。</span><span class="sxs-lookup"><span data-stu-id="4a8bb-142">Forward-only streams can be designed in this way.</span></span>