---
title: アダプターによるサイズの大きいメッセージの処理 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: c48671fd-b6cf-4507-92b4-35a4cd135714
caps.latest.revision: 15
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 131d757e1df910b33d92bbc7b02a576edad8efcd
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65344246"
---
# <a name="how-adapters-handle-large-messages"></a><span data-ttu-id="3e978-102">アダプターがサイズの大きいメッセージを処理する方法</span><span class="sxs-lookup"><span data-stu-id="3e978-102">How Adapters Handle Large Messages</span></span>
<span data-ttu-id="3e978-103">BizTalk メッセージング エンジンは、非常に大きなメッセージを処理できるし、メッセージの最大サイズに制限はありません。</span><span class="sxs-lookup"><span data-stu-id="3e978-103">The BizTalk Messaging Engine can process very large messages and imposes no restriction on the maximum size of a message.</span></span> <span data-ttu-id="3e978-104">ただし、最適なパフォーマンスとリソース管理を維持するためにメッセージのサイズに制限を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3e978-104">However, you should consider limits to message size to maintain optimum performance and resource management.</span></span> <span data-ttu-id="3e978-105">メッセージとしては、サイズは、2 つ目の減少ごとに処理されたメッセージの数を増加します。</span><span class="sxs-lookup"><span data-stu-id="3e978-105">As message size increases the number of messages processed per second decreases.</span></span> <span data-ttu-id="3e978-106">メッセージの平均サイズ、メッセージの種類とによって処理されるメッセージの数を検討してください[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]ときに、シナリオを設計し、容量を計画します。</span><span class="sxs-lookup"><span data-stu-id="3e978-106">Consider the average message size, message type, and number of messages being processed by [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] when designing your scenario and planning for capacity.</span></span>  
  
## <a name="stream-based-processing"></a><span data-ttu-id="3e978-107">Stream ベースの処理</span><span class="sxs-lookup"><span data-stu-id="3e978-107">Stream-Based Processing</span></span>  
 <span data-ttu-id="3e978-108">留意するサイズの大きいメッセージの処理のアダプターを開発する際に重要です。</span><span class="sxs-lookup"><span data-stu-id="3e978-108">It is important to keep large message handling in mind when developing adapters.</span></span> <span data-ttu-id="3e978-109">サイズに関係なくメモリへのデータ ストリーム全体の読み込みはこれ、BizTalk Server プロセスを停止する可能性があります可能性があるためにお勧めします。</span><span class="sxs-lookup"><span data-stu-id="3e978-109">Loading the entire data stream into memory regardless of its size is strongly discouraged because this could potentially stop the BizTalk Server process.</span></span> <span data-ttu-id="3e978-110">サイズと、エンジンは、特定の時点で処理されているメッセージの数、に応じて仮想メモリの不足が問題になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3e978-110">Depending on the size and number of messages that the engine is processing at any given time, low virtual memory could become a problem.</span></span> <span data-ttu-id="3e978-111">代わりに、メッセージがするように処理ストリーミング方式で。</span><span class="sxs-lookup"><span data-stu-id="3e978-111">Instead, messages should be processed in a streaming fashion as follows:</span></span>  
  
- <span data-ttu-id="3e978-112">**メッセージを受信します。**</span><span class="sxs-lookup"><span data-stu-id="3e978-112">**Inbound messages.**</span></span> <span data-ttu-id="3e978-113">受信メッセージのネットワーク ストリームは、「抽出」のストリームを BizTalk メッセージング エンジンに、受信アダプターによって、BizTalk メッセージにアタッチされます。</span><span class="sxs-lookup"><span data-stu-id="3e978-113">For inbound messages the network stream is attached to the BizTalk message by the receive adapter leaving the "pulling" of the stream to the BizTalk Messaging Engine.</span></span>  
  
- <span data-ttu-id="3e978-114">**送信メッセージ。**</span><span class="sxs-lookup"><span data-stu-id="3e978-114">**Outbound messages.**</span></span> <span data-ttu-id="3e978-115">送信メッセージの場合、アダプタは、ストリームの抽出責任を負います。</span><span class="sxs-lookup"><span data-stu-id="3e978-115">For outbound messages the adapter is responsible for pulling the stream.</span></span> <span data-ttu-id="3e978-116">メッセージ ボックス データベースからストリームを効果的にはこれを送信パイプラインを介してします。</span><span class="sxs-lookup"><span data-stu-id="3e978-116">This effectively pulls the stream from the MessageBox database and though the send pipeline.</span></span> <span data-ttu-id="3e978-117">アダプターでは、ストリーミング方式でネットワーク経由でデータを送信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3e978-117">The adapter should send the data over the wire in a streaming fashion.</span></span>  
  
  <span data-ttu-id="3e978-118">次の図は、ストリーム ベースのメッセージング エンジンの受信側で処理を示します。</span><span class="sxs-lookup"><span data-stu-id="3e978-118">The following figure shows stream-based processing on the receive side of the Messaging Engine.</span></span>  
  
  <span data-ttu-id="3e978-119">![](../core/media/streambasedprocessing.gif "Streambasedprocessing")</span><span class="sxs-lookup"><span data-stu-id="3e978-119">![](../core/media/streambasedprocessing.gif "Streambasedprocessing")</span></span>  
  
  <span data-ttu-id="3e978-120">アダプターからエンジンにメッセージを送信するときをデータ ストリームを BizTalk メッセージにアタッチします。</span><span class="sxs-lookup"><span data-stu-id="3e978-120">When an adapter submits a message to the engine it should attach its data stream to the BizTalk message.</span></span> <span data-ttu-id="3e978-121">一部のアダプターのネットワーク ストリームの実装があります。</span><span class="sxs-lookup"><span data-stu-id="3e978-121">For some adapters this may mean implementing a network stream.</span></span> <span data-ttu-id="3e978-122">メッセージが送信されたときに、エンジンは、受信パイプラインを実行します。</span><span class="sxs-lookup"><span data-stu-id="3e978-122">When the message is submitted, the engine executes the receive pipeline.</span></span> <span data-ttu-id="3e978-123">パイプラインの実行中は、データを変更するパイプライン コンポーネントは、メッセージは、前のメッセージのストリームに、新しいメッセージのストリームを配線を複製します。</span><span class="sxs-lookup"><span data-stu-id="3e978-123">During pipeline execution, the pipeline components that want to change the data clone the message, wiring up the stream from the new message to the stream on the previous message.</span></span> <span data-ttu-id="3e978-124">パイプラインが実行された後、メッセージング エンジンは、パイプラインからのメッセージを取得し、そのメッセージのストリームを読み取るループを実行します。</span><span class="sxs-lookup"><span data-stu-id="3e978-124">After the pipeline has been executed, the Messaging Engine takes a message out of the pipeline and executes a loop reading the stream on that message.</span></span> <span data-ttu-id="3e978-125">この読み取り、ストリームのでは、さらにネットワーク ストリームに戻る で、前のストリームで読み取りを呼び出す前のストリームの読み取りを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="3e978-125">This reading of the stream invokes a read on the previous stream, which in turn invokes a read on the previous stream, and so on back to the network stream.</span></span> <span data-ttu-id="3e978-126">エンジンは、フラット メモリ モデルを維持するために、メッセージ ボックスに、データを定期的にフラッシュします。</span><span class="sxs-lookup"><span data-stu-id="3e978-126">The engine periodically flushes the data to the MessageBox to maintain a flat memory model.</span></span>  
  
  <span data-ttu-id="3e978-127">**トラブルシューティングのヒント。** 送信側では、アダプタは、ストリームの読み取りを行うです。</span><span class="sxs-lookup"><span data-stu-id="3e978-127">**Troubleshooting Tip:** On the send side, the adapter is responsible for reading the stream.</span></span> <span data-ttu-id="3e978-128">送信アダプターがメッセージの昇格または送信パイプラインで記述されるコンテキスト プロパティを読み取るには、ストリーム全体が読み取られるまでこれらのプロパティは書き込まれません。</span><span class="sxs-lookup"><span data-stu-id="3e978-128">If the send adapter wants to read any message context properties that are promoted or written in the send pipeline, these properties may not be written until the entire stream is read.</span></span> <span data-ttu-id="3e978-129">ストリームが完全に読み取られた場合にのみ、アダプターできます実行が完了のパイプライン コンポーネントをすべて確認してください。</span><span class="sxs-lookup"><span data-stu-id="3e978-129">Only when the stream has been completely read can the adapter be sure that all of the pipeline components have finished executing.</span></span>  
  
## <a name="locating-a-specific-byte-in-the-stream"></a><span data-ttu-id="3e978-130">特定のバイト数を Stream で検索します。</span><span class="sxs-lookup"><span data-stu-id="3e978-130">Locating a Specific Byte in the Stream</span></span>  
 <span data-ttu-id="3e978-131">アダプターが中断する必要がある失敗したメッセージを処理するために先頭に戻り、ストリームを検索する必要がありますシナリオがあります。</span><span class="sxs-lookup"><span data-stu-id="3e978-131">There are scenarios in which an adapter may need to locate the stream back to the beginning to handle failed messages that need to be suspended.</span></span> <span data-ttu-id="3e978-132">この例では、チャンク エンコードを使用して、送信請求-応答の組み合わせで応答メッセージを送信するデータを受信する HTTP アダプターです。</span><span class="sxs-lookup"><span data-stu-id="3e978-132">An example of this is an HTTP adapter that is receiving data using chunked encoding to submit the response message in a solicit-response pair.</span></span>  
  
 <span data-ttu-id="3e978-133">ただし、多くのシナリオでないことができます、データ ストリームをトレースします。</span><span class="sxs-lookup"><span data-stu-id="3e978-133">However, in many scenarios you may not be able to trace the data stream.</span></span> <span data-ttu-id="3e978-134">たとえば、チャンク エンコードを使用してデータを受信する HTTP アダプターがあるとします。</span><span class="sxs-lookup"><span data-stu-id="3e978-134">For example, consider an HTTP adapter receiving data using chunked encoding.</span></span> <span data-ttu-id="3e978-135">アダプターがデータ ストリームの失敗したメッセージを検索できるように設計するには、読み取られると、メモリまたはディスクにデータをキャッシュする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3e978-135">For the data stream to be designed so you can find the messages that failed, the adapter would need to cache the data as it is read, either in memory or onto disk.</span></span> <span data-ttu-id="3e978-136">明らかにこれが最適でないと、その他のリソースが必要です。</span><span class="sxs-lookup"><span data-stu-id="3e978-136">Clearly this is not optimal and requires additional resources.</span></span> <span data-ttu-id="3e978-137">さらに、ボックスのパイプライン コンポーネントの多くは順方向専用のストリーミング方式で動作します。</span><span class="sxs-lookup"><span data-stu-id="3e978-137">Further, many of the out-of-the-box pipeline components operate in a forward-only streaming fashion.</span></span> <span data-ttu-id="3e978-138">SDK の BaseAdapter をこれらのシナリオと呼ばれるヘルパー クラスを使用して**VirtualStream**します。</span><span class="sxs-lookup"><span data-stu-id="3e978-138">For these scenarios the BaseAdapter in the SDK uses a helper class called **VirtualStream**.</span></span> <span data-ttu-id="3e978-139">この機能を含むファイルは VirtualStream.cs という名前です。</span><span class="sxs-lookup"><span data-stu-id="3e978-139">The file that contains this functionality is named VirtualStream.cs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e978-140">VirtualStream.cs ファイルは、パイプラインの SDK サンプルの 2 つの場所にある — \samples\pipelines\arbitraryxpathpropertyhandler および \samples\pipelines\schemaresolvercomponent\schemaresolverflatfiledasm します。</span><span class="sxs-lookup"><span data-stu-id="3e978-140">The VirtualStream.cs file is located in two locations under the Pipelines SDK Samples—SDK\Samples\Pipelines\ArbitraryXPathPropertyHandler and SDK\Samples\Pipelines\SchemaResolverComponent\SchemaResolverFlatFileDasm.</span></span>  
  
 <span data-ttu-id="3e978-141">仮想ストリームの背後にある考え方では、ディスク上のセキュリティで保護された場所にデータをオーバーフローするしきい値に達するまで、メモリ ストリームに、ストリーム内のデータをキャッシュすることです。</span><span class="sxs-lookup"><span data-stu-id="3e978-141">The idea behind a virtual stream is that the data in the stream is cached in a memory stream until it reaches a threshold, over which the data is overflowed to a secure location on disk.</span></span> <span data-ttu-id="3e978-142">ストリームが閉じた後、ディスク ファイルが自動的に削除します。</span><span class="sxs-lookup"><span data-stu-id="3e978-142">After the stream is closed the disk file is automatically deleted.</span></span> <span data-ttu-id="3e978-143">この方法では、順方向専用ストリームを設計できます。</span><span class="sxs-lookup"><span data-stu-id="3e978-143">Forward-only streams can be designed in this way.</span></span>