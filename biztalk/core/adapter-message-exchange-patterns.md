---
title: "アダプターのメッセージ交換パターン |Microsoft ドキュメント"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 54a3fc8f-33d0-4b7e-ad4c-b00912dc3328
caps.latest.revision: "14"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: f42368d8687bbed4cbce60243a3b8528364b5fda
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
---
# <a name="adapter-message-exchange-patterns"></a>アダプターのメッセージ交換パターン
BizTalk アダプター フレームワークは、多くの強力なメッセージング シナリオでアダプターが使用できるメッセージ交換パターンの豊富なセットをサポートします。  
  
## <a name="one-way-asynchronous"></a>一方向 (非同期)  
 ここでの主な概念は、メッセージが一方向に流れるということです。  
  
 このメッセージ交換パターンでは、メッセージがアダプターを経由して [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] に一方向に流れます。 メッセージング エンジンは、メッセージ ボックス データベースにメッセージを公開します。 オーケストレーションにこの種類のメッセージに対するアクティブなサブスクリプションがある場合は、メッセージはそのオーケストレーションにルーティングされます。  
  
 メッセージの処理の後に、オーケストレーションは、メッセージが特定のエンドポイントに送信されるアダプターにルーティングされる前に、メッセージをメッセージ ボックス データベースに公開します。  
  
 エンジンにメッセージが送信されるときに、応答は発生しません。 送信側では、メッセージが送信されるときに、応答は発生しません。 これは、通常、非同期メッセージングと呼ばれており、すべてのメッセージング シナリオでエンジンによってさまざまな形で使用される基本的なビルド ブロックです。  
  
## <a name="request-response-style-protocols-sync-on-async"></a>要求 - 応答形式のプロトコル (sync-on-async)  
 要求 - 応答シナリオは、要求メッセージの受信、その処理、および応答メッセージの送信で構成されています。 これは、基になる [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] アーキテクチャがスケーラビリティ上の理由で非同期なので、非同期での同期 (sync-on-async) とも呼ばれます。 ただし、BizTalk メッセージング エンジンのアーキテクチャによって、これらの非同期の交換の上位で同期メッセージ交換パターンを公開できます。 これを行うために、エンジンは、同期インターフェイスを公開するために多数の非同期メッセージ交換をまとめてリンクすることによって、スケール アウトされたアーキテクチャにわたって要求メッセージおよび応答メッセージの関連付けの複雑なタスクを処理します。  
  
 たとえば、インベントリは、BizTalk SOAP を SOAP 呼び出しを行うことがありますをチェックする Web ページには、アダプターが表示されます。 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]一連の情報を集約し、1 つの SOAP 応答で返す Web サービスを統制します。 クライアントから見ると、これは同期 SOAP 呼び出しのように見えますが、実際にはエンジンによって多数の非同期メッセージ交換が結合されています。  
  
## <a name="solicit-response-style-protocols"></a>送信請求 - 応答形式のプロトコル  
 このシナリオは、送信請求メッセージの送信によって開始され、応答メッセージの受信によって完了します。 これは、送信される最初のメッセージがエンドポイントに対する応答メッセージの送信請求であるため、送信請求 - 応答と呼ばれます。 このメッセージ交換パターンを使用するシナリオには、送信 HTTP 呼び出し (応答の送信請求) の作成および応答に対する待機を行うオーケストレーションが含まれることがあります。  
  
## <a name="request-multiresponse"></a>要求 - 複数応答  
 このシナリオは、要求 - 応答シナリオに似ています。 ただし、このシナリオでは、指定した要求に対して複数の応答を返すことができます。 API によってタイムアウト値を指定でき、タイムアウト期間の間に受信されたすべての応答は受信アダプターに返されます。  
  
## <a name="loop-back"></a>ループバック  
 このシナリオは、要求 - 応答シナリオに似ています。 要求メッセージは通常どおり公開されますが、エンジンによって、要求メッセージを公開したアダプター インスタンスと同じアダプター インスタンスに応答メッセージが確実にルーティングされるようになります。 要求メッセージはメッセージ ボックス データベースに公開されるため、追跡インフラストラクチャによって、要求メッセージと応答メッセージの両方が確実に追跡されるようになります。 これは、メッセージを処理している送信パイプラインを呼び出し、すぐに出力メッセージを取得し、後続の処理のためにアダプターに返送する場合にも適した方法です。  
  
 このシナリオの例としては、メッセージに対する確認メッセージを要求するクライアントが挙げられます。 受信メッセージはメッセージ ボックス データベースに公開されます。 このメッセージと確認メッセージの両方は、同じバッチでアダプターに返されます。 この場合、受信メッセージは、クライアントに返されている 1 つのインスタンス、および通常の方法で処理されているもう 1 つのインスタンスを使用して、コピーされます。 この特定のシナリオでは、カスタム XML 逆アセンブラーも記述する必要があります。  
  
## <a name="see-also"></a>参照  
 [アダプター フレームワークとは何ですか。](../core/what-is-the-adapter-framework.md)