---
title: アダプターのメッセージ交換パターン |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 54a3fc8f-33d0-4b7e-ad4c-b00912dc3328
caps.latest.revision: 14
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: e15afa09234b046b0cd4388a03e5d4fc92480eaf
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65361381"
---
# <a name="adapter-message-exchange-patterns"></a>アダプターのメッセージ交換パターン
BizTalk アダプター フレームワークでは、多くの強力なメッセージング シナリオでアダプターを使用できるメッセージ交換パターンの豊富なセットをサポートしています。  
  
## <a name="one-way-asynchronous"></a>一方向 (非同期)  
 ここで重要な概念は、メッセージが一方向に流れることです。  
  
 このメッセージ交換パターンでメッセージ フローに一方向[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]アダプターを経由します。 メッセージング エンジンは、メッセージ ボックス データベースにメッセージを発行します。 オーケストレーションにメッセージをその型のアクティブなサブスクリプションがある場合、メッセージは、そのオーケストレーションにルーティングされます。  
  
 メッセージの処理後に前に、特定のエンドポイントに送信するのには、アダプターにルーティングされます、オーケストレーションはメッセージ ボックス データベースにメッセージを発行します。  
  
 エンジンにメッセージが送信されると、応答は発生しません。 送信側でメッセージを送信すると、応答は発生しません。 非同期メッセージングと呼ばれる通常とはさまざまな方法ですべてのエンジンによって使用される基本的なビルディング ブロック メッセージング シナリオ。  
  
## <a name="request-response-style-protocols-sync-on-async"></a>要求-応答形式のプロトコル (同期で非同期)  
 要求-応答シナリオでは、要求メッセージの受信、処理、および応答メッセージを送信するので構成されます。 それも呼びます同期-非同期 (同期での非同期) ため、基になる[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]アーキテクチャがスケーラビリティ上の理由から非同期です。 ただし、BizTalk メッセージング エンジンのアーキテクチャでは、これらの非同期の交換の上に、同期メッセージ交換パターンを公開することを使用できます。 これを行うには、エンジンは、さまざまな同期インターフェイスを公開する非同期メッセージ交換をリンクして、スケール アウト アーキテクチャの間での要求および応答メッセージを関連付けることの複雑なタスクを処理します。  
  
 たとえば、BizTalk SOAP を SOAP 呼び出しを行う在庫を確認する Web ページには、アダプターが表示されます。 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 一連の情報を集約し、1 つの SOAP 応答で返す Web サービスを調整します。 クライアントにこの同期の SOAP 呼び出しに見えますが、実際に見えます同時の非同期メッセージ交換の数に、エンジン。  
  
## <a name="solicit-response-style-protocols"></a>送信請求-応答形式のプロトコル  
 このシナリオは、送信請求メッセージを送信することによって開始され、応答メッセージを受信することによって完了します。 呼びますに送信請求-応答送信される最初のメッセージが応答メッセージのエンドポイントを要求するためです。 このメッセージ交換パターンを使用するシナリオは、オーケストレーション、送信 HTTP 呼び出し (応答の送信請求) を行い、応答の待機中になる場合があります。  
  
## <a name="request-multiresponse"></a>要求 Multiresponse  
 このシナリオでは、要求-応答シナリオに似ています。 ただし、このシナリオでは、複数の応答は特定の要求に対して返される可能性があります。 Api を指定するタイムアウト値を使用して、タイムアウト期間内に受信したすべての応答は、受信アダプターに返されます。  
  
## <a name="loop-back"></a>ループバック  
 このシナリオでは、要求-応答シナリオに似ています。 要求メッセージは通常どおり、パブリッシュされていますが、エンジンは、応答メッセージは、同じアダプターにルーティングされていることにより、インスタンス、公開された要求メッセージ。 要求メッセージをメッセージ ボックス データベースに発行ため、追跡インフラストラクチャは、要求と応答のメッセージを追跡することを確認します。 これは、また、メッセージの送信パイプライン処理を起動し、すぐに、出力メッセージの送信に戻る後続の処理用のアダプターのことをお勧めです。  
  
 このシナリオの例は、メッセージの受信確認を要求するクライアントです。 受信メッセージは、メッセージ ボックス データベースに公開されます。 同じバッチでアダプターには、このメッセージと受信確認の両方が返されます。 この場合、受信メッセージは、クライアントと、その他の処理されている通常の方法で返される 1 つのインスタンスにコピーされます。 この特定のシナリオでは、カスタム XML 逆アセンブラーを書き込む必要もあります。  
  
## <a name="see-also"></a>参照  
 [アダプター フレームワークについて](../core/what-is-the-adapter-framework.md)