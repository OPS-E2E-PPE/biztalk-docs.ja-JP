---
title: ボトルネックを調査する方法 |Microsoft ドキュメント
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 7ca22d07-d5fe-4dfb-8b52-3be3a95b0d6f
caps.latest.revision: 4
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: a6a3cf4630bf3269516537439ed58b464589cf26
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
ms.locfileid: "22254898"
---
# <a name="how-to-investigate-bottlenecks"></a><span data-ttu-id="5dfb1-102">ボトルネックを調査する方法</span><span class="sxs-lookup"><span data-stu-id="5dfb1-102">How to Investigate Bottlenecks</span></span>
<span data-ttu-id="5dfb1-103">このトピックでは、ボトルネックを調査するための推奨プロセスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-103">This topic describes a recommended process for how to investigate bottlenecks.</span></span>  
  
## <a name="what-is-the-source-of-the-problem"></a><span data-ttu-id="5dfb1-104">問題の原因について</span><span class="sxs-lookup"><span data-stu-id="5dfb1-104">What is the Source of the Problem?</span></span>  
 <span data-ttu-id="5dfb1-105">問題の原因は、ハードウェアに関連している場合もあれば、ソフトウェアに関連している場合もあります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-105">The source of the problem could be hardware or software related.</span></span> <span data-ttu-id="5dfb1-106">リソースが十分に活用されていない場合は、一般に、システムのどこかにボトルネックがあると考えられます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-106">When resources are underutilized it is usually an indication of a bottleneck somewhere in the system.</span></span> <span data-ttu-id="5dfb1-107">ボトルネックは、ハードウェアの制限、ソフトウェアの非効率的な構成、またはその両方が原因となって発生します。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-107">Bottlenecks can be caused either due to hardware limitations or due to inefficient software configurations or both.</span></span>  
  
 <span data-ttu-id="5dfb1-108">ボトルネックの特定では、あるボトルネックを緩和すると次のボトルネックが見つかることもまれではなく、作業を積み重ねが必要になります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-108">Identifying bottlenecks is an incremental process whereby alleviating one bottleneck can lead to the discovery of the next one.</span></span> <span data-ttu-id="5dfb1-109">こうしたボトルネックの特定と緩和について科学的に説明することがこのトピックの目的です。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-109">The science of identifying and alleviating these bottlenecks is the objective of this topic.</span></span> <span data-ttu-id="5dfb1-110">システムは、短期間なら最大限の性能を発揮できます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-110">It is possible for a system to perform at peaks for short periods of time.</span></span> <span data-ttu-id="5dfb1-111">しかし、スループットを維持するには、そのシステムの最も遅いコンポーネントの速度でしか処理できなくなる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-111">However, for sustainable throughput a system can only process as fast as its slowest performing component.</span></span>  
  
## <a name="using-a-serial-approach"></a><span data-ttu-id="5dfb1-112">連続的アプローチの使用</span><span class="sxs-lookup"><span data-stu-id="5dfb1-112">Using a Serial Approach</span></span>  
 <span data-ttu-id="5dfb1-113">ボトルネックは、システムのエンドポイント (入り口/出口) で発生することも、その間のどこか (オーケストレーション/データベース) で発生することもあります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-113">Bottlenecks can occur at the endpoints (entry/exit) of the system or somewhere in the middle (orchestration/database).</span></span> <span data-ttu-id="5dfb1-114">ボトルネックの場所を切り分けることができれば、原因を特定するための体系的なアプローチを開始できます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-114">After the location of the bottleneck has been isolated a structured approach can be undertaken to identify the source.</span></span> <span data-ttu-id="5dfb1-115">ボトルネックを緩和できたら、再度パフォーマンスを測定して、システムのどこか別の場所で新たなボトルネックが発生していないかどうかを確認することが重要です。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-115">After the bottlenecks have been alleviated it is essential to measure performance again to ensure that a new bottleneck has not been introduced elsewhere in the system further down the line.</span></span>  
  
 <span data-ttu-id="5dfb1-116">ボトルネックの特定と修正のプロセスは、一度に 1 つのパラメーターのみを変更して、その 1 つの変更の影響を確認するためにパフォーマンスを測定するという、連続的な方法で行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-116">The process of identifying and fixing bottlenecks should be done in a serial manner whereby only one parameter at a time should be varied and then performance measured to verify the impact of that single change.</span></span> <span data-ttu-id="5dfb1-117">一度に複数のパラメーターを変更すると、変更の効果がわからなくなってしまう可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-117">Varying more than one parameter at a time could conceal the effect of the change.</span></span>  
  
 <span data-ttu-id="5dfb1-118">たとえば、パラメーター 1 を変更するとパフォーマンスが改善するのに、同時にパラメーター 2 を変更するとマイナスの効果が生じ、パラメーター 1 の変更の効果が帳消しになる場合が考えられます。この場合、最終的な効果はゼロになりますが、</span><span class="sxs-lookup"><span data-stu-id="5dfb1-118">For example, changing parameter 1 could improve performance however, changing parameter 2 in conjunction with changing parameter 1 could have a detrimental effect negating the benefits of changing parameter 1 thus leading to a net zero effect.</span></span> <span data-ttu-id="5dfb1-119">その結果、パラメーター 1 を変更した効果が偽陰性、パラメーター 2 を変更した効果が偽陽性になってしまいます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-119">However, this results in a false negative on the effect of varying parameter 1 and a false positive on the effect of varying parameter 2.</span></span>  
  
## <a name="testing-consistency"></a><span data-ttu-id="5dfb1-120">テストの一貫性</span><span class="sxs-lookup"><span data-stu-id="5dfb1-120">Testing Consistency</span></span>  
 <span data-ttu-id="5dfb1-121">設定を変更したら、その変更の効果を検証するためにパフォーマンス特性を測定することが重要です。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-121">Measuring performance characteristics after changing settings is imperative to validate the effect of the change.</span></span>  
  
-   <span data-ttu-id="5dfb1-122">ハードウェア: ことが重要に使用するさまざまなハードウェアとの一貫性のあるハードウェアが一貫性のない動作の例: 結果誤るを表示できますが、ラップトップを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-122">Hardware: It is important to use consistent hardware as varying the hardware can display inconsistent behavior producing misleading results e.g. do not use a laptop.</span></span>  
  
-   <span data-ttu-id="5dfb1-123">テスト実行の継続時間: ことも重要です結果が実際に維持可能なことを確認する最低限の期間を固定およびピーク時だけでなくパフォーマンスを測定します。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-123">Test Run Duration: It is also important to measure performance for a fixed minimum period to ensure that the results are indeed sustainable and not simply peaks.</span></span> <span data-ttu-id="5dfb1-124">テストを長時間実行するのにはもう 1 つの理由があります。それは、システムの最初のウォームアップ期間/準備期間が終わった状態でテストできるようにするためです。これにより、すべてのキャッシュにデータが格納され、データベース テーブルが予想の数に到達し、制限が作動してスループットが制御された状態 (あらかじめ定義されたしきい値に到達した状態) でテストを実行できます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-124">Another reason to run tests for longer periods is to ensure that the system has gone through the initial warm/ramp up period where all caches are populated, database tables have reached expected counts and throttling is given sufficient time to kick in and regulate throughput once predefined thresholds are hit.</span></span> <span data-ttu-id="5dfb1-125">このアプローチは、維持可能な最大スループットを特定するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-125">This approach will help discover optimal sustainable throughput.</span></span>  
  
-   <span data-ttu-id="5dfb1-126">テスト パラメーター: も変わらないテストのテストのテスト実行のパラメーターの実行を強制できます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-126">Test Parameters: It is also imperative to not vary test parameters from test run to test run.</span></span> <span data-ttu-id="5dfb1-127">たとえば、マップの複雑さやドキュメントのサイズを変更すると、スループットや待機時間の結果が変わってしまう可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-127">For example, varying map complexity and/or document sizes can produce different throughput and latency results.</span></span>  
  
-   <span data-ttu-id="5dfb1-128">クリーンな状態: テストが完了することが重要クリーンアップが次のテストを実行する前にすべての状態を実行します。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-128">Clean State: Once a test is complete it is important to cleanup all state before running the next test run.</span></span> <span data-ttu-id="5dfb1-129">たとえば、データベースに蓄積された履歴データが実行時のスループットに影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-129">For example, historical data can buildup in the database impacting runtime throughput.</span></span> <span data-ttu-id="5dfb1-130">サービス インスタンスを再利用すると、メモリ、データベース接続、スレッドなどのキャッシュされたリソースを解放できます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-130">Recycling the service instances help to release cached resources like memory, database connections and threads.</span></span>  
  
## <a name="expectations-throughput-versus-latency"></a><span data-ttu-id="5dfb1-131">期待: スループットと待機時間</span><span class="sxs-lookup"><span data-stu-id="5dfb1-131">Expectations: Throughput versus Latency</span></span>  
 <span data-ttu-id="5dfb1-132">展開されたシステムにある程度のスループットや待機時間を予測することは正当です。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-132">It is reasonable to expect a certain amount of throughput and/or latency from the deployed system.</span></span> <span data-ttu-id="5dfb1-133">高いスループットと短い待機時間の両方を実現しようとするのは、同時に 2 つの別の方向に向かおうとするようなものですが、</span><span class="sxs-lookup"><span data-stu-id="5dfb1-133">Attempting to have both high throughput & low latency is like pulling in two different directions.</span></span> <span data-ttu-id="5dfb1-134">現実として、最大限のスループットと妥当な待機時間を予測することはできます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-134">However it is realistic to expect optimal throughput with reasonable latency.</span></span> <span data-ttu-id="5dfb1-135">スループットが高まるとシステムのストレスが増加して (CPU 消費、ディスク入出力の競合、メモリ不足、ロックの競合が増加するなど)、待機時間にマイナスの影響が及ぶ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-135">As throughput improves increased stress (higher CPU consumption, higher disk-IO contention, memory pressure, greater lock contention) is placed on the system which can have a negative impact on latency.</span></span> <span data-ttu-id="5dfb1-136">システムの最適処理能力を見極めるためには、すべてのボトルネックを特定し、それらを解消することが重要です。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-136">To discover optimal capacity of a system it is imperative to identify and alleviate any and all bottlenecks.</span></span>  
  
 <span data-ttu-id="5dfb1-137">ボトルネックは、クリーンアップされずにデータベースに残っている前のデータ (完了したインスタンス) によって発生することがあります。その場合、パフォーマンスが低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-137">Bottlenecks can be caused by legacy data (completed instances) residing in the database not cleaned out. When this occurs performance can degrade.</span></span> <span data-ttu-id="5dfb1-138">この問題は、システムがデータを削除するのに十分な時間を確保することによって解消できます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-138">Giving the system sufficient time to drain can help alleviate the problem.</span></span> <span data-ttu-id="5dfb1-139">ただし、バックログが蓄積された原因を特定して、その問題を解決することが重要です。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-139">However, discovering the cause of the backlog buildup and helping alleviate the issue is important.</span></span>  
  
 <span data-ttu-id="5dfb1-140">バックログの原因を特定するには、履歴データを分析し、パフォーマンス モニター カウンターを監視することが重要です (使用パターンを特定してバックログの原因を診断するため)。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-140">To discover the cause of the backlog, it is important to analyze historical data, monitor Performance Monitor counters (to discover usage patterns, and diagnose the source of the backlog).</span></span> <span data-ttu-id="5dfb1-141">バックログの蓄積は、大量のデータを毎晩バッチ方式で処理するような場合によく見られる状況です。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-141">This is a common situation where large volumes of data are processed in a batched manner on a nightly basis.</span></span> <span data-ttu-id="5dfb1-142">システムの性能とバックログからの回復能力を知ることは、負荷が集中した状態を処理するためのハードウェアの要件や、スループットの予想外のピークが生じた場合に対処するにはシステム内にどの程度の余地があればよいのかを見積もるうえで役に立ちます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-142">Discovering the capacity of the system and its ability to recover from a backlog can be useful in estimating hardware requirements for handling overdrive scenarios and the amount of buffer room to accommodate within a system to handle unforeseen spikes in throughput.</span></span>  
  
 <span data-ttu-id="5dfb1-143">維持可能な最大スループットを得られるようにシステムをチューニングするには、展開するアプリケーション、システムの長所と短所、および特定のシナリオの使用パターンについての深い理解が必要です。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-143">Tuning the system for optimal sustainable throughput requires an in depth understanding of the application being deployed, the strengths and weaknesses of the system and usage patterns of the specific scenario.</span></span> <span data-ttu-id="5dfb1-144">ボトルネックを特定し、維持可能な最大スループットを確実に予測するためには、実稼働環境で使用されるものに近いトポロジで徹底的なテストを行うしかありません。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-144">The only way to discover bottlenecks and predict optimal sustainable throughput with certainty is through thorough testing on a topology that closely matches what will be used in production.</span></span>  
  
 <span data-ttu-id="5dfb1-145">このセクションの他のトピックでは、そのトポロジを定義するためのプロセスを紹介し、ボトルネックを緩和するにはどうすればよいか、さらには、そもそもボトルネックが発生しないようにするにはどうすればよいかを説明します。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-145">Other topics in this section guides you through the process of defining that topology, and provides guidance on how to alleviate bottlenecks and hopefully help to avoid bottlenecks in the first place.</span></span>  
  
## <a name="scaling"></a><span data-ttu-id="5dfb1-146">スケーリング</span><span class="sxs-lookup"><span data-stu-id="5dfb1-146">Scaling</span></span>  
 <span data-ttu-id="5dfb1-147">ボトルネックは、展開されたトポロジのさまざまな段階で発生します。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-147">Bottlenecks can occur at various stages of the deployed topology.</span></span> <span data-ttu-id="5dfb1-148">ハードウェアをアップグレードすることによって対処できるボトルネックもあります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-148">Some bottlenecks can be addressed by upgrading hardware.</span></span> <span data-ttu-id="5dfb1-149">ハードウェアのアップグレードには、スケール アップ (CPU、メモリ、キャッシュなどの追加) とスケール アウト (サーバーの追加) があります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-149">Hardware can be upgraded either by scaling-up (more CPU’s, memory or cache) or by scaling-out (additional servers).</span></span> <span data-ttu-id="5dfb1-150">どちらを利用するかは、発生したボトルネックの種類と、構成するアプリケーションによって決まります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-150">The decision to scale up/out depends on the type of bottleneck encountered and the application being configured.</span></span> <span data-ttu-id="5dfb1-151">以下は、発生したボトルネックに基づいてハードウェア展開トポロジを変更する方法についてのガイダンスです。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-151">The following will help with guidance on how to change hardware deployment topologies based on bottlenecks encountered.</span></span> <span data-ttu-id="5dfb1-152">スケール アップ/スケール アウトのメリットを得るにはアプリケーションを一から作り直す必要があります。例:</span><span class="sxs-lookup"><span data-stu-id="5dfb1-152">An application needs to be built from the ground up to be capable of taking advantage of scaling up/out. For example:</span></span>  
  
-   <span data-ttu-id="5dfb1-153">アプリケーションがシリアル化されていて、1 つのスレッドの実行に依存している場合は、CPU やメモリを追加してサーバーをスケール アップしても問題は解消されません。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-153">Scaling up a server with additional CPU’s and/or memory may not help alleviate the problem if the application is serialized and dependent on a single thread of execution.</span></span>  
  
-   <span data-ttu-id="5dfb1-154">サーバーを追加しても拡張不可能な共通リソースの競合が増加するだけである場合は、サーバーを追加してシステムをスケール アウトしても役に立ちません。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-154">Scaling out a system with additional servers may not help if the additional servers simply add contention on a common resource that cannot be scaled.</span></span> <span data-ttu-id="5dfb1-155">ただし、スケール アウトにはまた別のメリットもあります。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-155">However, scaling-out provides additional benefits.</span></span> <span data-ttu-id="5dfb1-156">クアッド プロセッサのサーバーを 1 つ展開する代わりにデュアル プロセッサのサーバーを 2 つ展開すると、追加のスループットを処理するための拡張と可用性の高いトポロジの実現という両方の目的に対応する冗長サーバーを実現できます。</span><span class="sxs-lookup"><span data-stu-id="5dfb1-156">Deploying two dual-proc servers instead of one quad-proc server helps provide a redundant server that serves the dual purpose of scaling to handle additional throughput and provides a highly available topology.</span></span>