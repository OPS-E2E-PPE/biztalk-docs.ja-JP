---
title: ルール エンジンを使用する場合のパフォーマンスに関する考慮事項 |Microsoft ドキュメント
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 9e9020c2-5152-40f6-940b-d4ce4081f069
caps.latest.revision: 7
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: c24a1c6ffb278d257e16c192e5fc7d827df70e24
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/20/2017
ms.locfileid: "22266506"
---
# <a name="performance-considerations-when-using-the-rule-engine"></a>ルール エンジン使用時のパフォーマンスに関する考慮事項
このトピックでは、各種のシナリオで構成パラメーターやチューニング パラメーターにさまざまな値を指定した場合のルール エンジンのパフォーマンスについて説明します。  
  
## <a name="fact-types"></a>ファクトの種類  
 ルール エンジンでは、XML およびデータベースのファクトをアクセスするよりも、.NET のファクトをアクセス時間がかかりません。 ポリシーで使用するファクトを .NET のファクト、XML のファクト、またはデータベースのファクトの中から選択できる場合は、パフォーマンスを高めるために .NET のファクトを使用することを検討してください。  
  
## <a name="data-table-vs-data-connection-binding"></a>データ テーブルとします。データ接続バインド  
 データ セットのサイズが小さい場合 (約 10 行未満)、 **TypedDataTable**バインド パフォーマンスが向上よりも、 **DataConnection**バインドします。 データ セットが大きい場合よりも大きい値 (約 10 行に等しい)、 **DataConnection**バインド パフォーマンスが向上よりも、 **TypedDataTable**バインドします。 そのためを使用するかどうかを決定する必要があります、 **DataConnection**バインドまたは**TypedDataTable**データ セットの推定サイズに基づいて、バインドします。  
  
## <a name="fact-retrievers"></a>ファクト取得コンポーネント  
 ファクト取得コンポーネントを記述することができます: 標準メソッドを実装して、通常長期的な装置と、ポリシーが実行される前に、ルール エンジンにファクトを緩やかに変化するために使用できるオブジェクト。 エンジンはこれらのファクトをキャッシュして、複数の実行サイクルで使用します。 静的なファクトやほぼ静的なファクトをルール エンジンの起動時に毎回送信するのではなく、初回にファクトを送信した後は必要時にのみメモリ内のファクトを更新するファクト取得コンポーネントを作成することをお勧めします。  
  
## <a name="rule-priority"></a>ルールの優先度  
 いずれかの側の範囲はルールの優先度設定**0**、高い優先順位を持つ大きな数字を使用します。 優先度の高い順にアクションが実行されます。 ポリシーが使用して順行連鎖の動作を実装するときに**Assert/update**チェーンの呼び出しは、優先順位設定を使用して最適化できます。 たとえばを**Rule2**によって設定されている値に依存している**Rule1**です。 提供**Rule1**優先順位が高いことを意味**Rule2**にした場合のみ実行されます**Rule1**が起動し、値を更新します。 逆に場合、 **Rule2**は高い優先順位を指定するには、そのことができますに 1 回発生して、後にもう一度**Rule1**が起動し、ファクトを更新する**Rule2**条件で使用します。 正しい結果が生成されるかどうかは場合によって異なりますが、1 回だけでなく 2 回実行されることで、パフォーマンスに影響が及ぶことは明らかです。  
  
## <a name="update-calls"></a>Update 呼び出し  
 **更新**関数は、ファクトをルール エンジンの作業メモリ内に存在して、更新されたファクトを再評価する条件で使用するすべてのルールを更新します。 **更新**関数呼び出しを多数のルールは、ファクトの更新によってを再評価する必要がある場合に特に高価なことができます。 状況によっては、ルールが再評価されないようにすることができます。 たとえば、次の規則があるとします。  
  
 **Rule1:**  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 **Rule2:**  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 ポリシーの使用の残りのルール**StatusObj.Flag**条件。 したがって、**更新**で呼び出されると、 **StatusObj**オブジェクトのすべてのルールが再評価されます。 どのような値、**量**フィールドは、以外のすべてのルール**Rule1**と**Rule2**を 2 回評価される前に 1 回、**更新**呼び出しと後に 1 回、**更新**呼び出します。  
  
 値を設定する代わりに、**フラグ**フィールドを**false** 、ポリシーを呼び出すし、のみを使用し、前に**Rule1**フラグを設定するためのポリシーでします。 この場合、**更新**場合にのみの値、**量**フィールドが 5 より大きいと**更新**量が 5 未満の場合は呼び出されません。 そのため、すべてのルールを除く**Rule1**と**Rule2**が評価される場合にのみ 2 回の値、**量**フィールドが 5 より大きい。  
  
## <a name="use-of-logical-or-operators"></a>論理 OR 演算子の使用  
 論理を実行するために、ルール エンジンが最適化された**AND**演算子とその再構築、解析されたルールは選言標準形でこれを**または**操作は、最上位レベルにのみ使用します。 ますます多くの論理を使用して**または**演算子の条件で順列が追加、ルール エンジンの分析ネットワークを展開し、ルールを正規化するルール エンジンに長い時間がかかる場合があります。 次の一覧は、この問題を回避する手段を示しています。  
  
-   ルールを選言標準形であることを変更、**または**演算子は、最上位レベルにのみです。 ビジネス ルール作成ツールで選言標準形のルールを開発することは困難なことがあります。 プログラムでルールを作成することもできます。  
  
-   実行するヘルパー コンポーネントを開発、**または**操作とブール値を返すし、ルールのコンポーネントを使用します。  
  
-   ルールを複数のルールに分割し、そのルールによって、以前実行されたルールで設定されたフラグをチェックするか、次の例に示すように、以前実行されたルールでアサートされたオブジェクトを使用する。  
  
    -   ルール 1: 場合 (、= = 1 または 3 を = =)、b = true  
  
         ルール 2: 場合 (b = = true)、.  
  
    -   ルール 1: 場合 (、= = 1 または 3 を = =) (新しい c()) をアサート  
  
         ルール 2: 場合 (c.flag = = true)、.  
  
## <a name="caching-settings"></a>キャッシュの設定  
 ルール エンジンは 2 つのキャッシュを使用します。 1 つは更新サービス内にあり、もう 1 つは各 BizTalk プロセス内にあります。 ポリシーが最初に使用されるときに、BizTalk プロセスは更新サービスにポリシー情報を要求します。 更新サービスは、ルール エンジン データベースからポリシー情報を取得してキャッシュし、BizTalk プロセスにその情報を返します。 BizTalk プロセスは、この情報を基にポリシー オブジェクトを作成し、関連するルール エンジン インスタンスがポリシーの実行を完了した時点でそのポリシー オブジェクトをキャッシュに格納します。 同じポリシーが再び呼び出されたときに、キャッシュ内にポリシー オブジェクトがあれば、BizTalk プロセスはそれを再利用します。  
  
 同様に、BizTalk プロセスがポリシーに関する情報を更新サービスに要求すると、更新サービスはまずそのキャッシュ内でポリシー情報を検索します。 また更新サービスは、データベース内でポリシーが更新されていないかを 60 秒 (1 分)ごとにチェックします。 更新があった場合、更新サービスは更新された情報を取得してキャッシュします。  
  
 これらのキャッシュに関連するルール エンジンの 3 つのチューニング パラメーターがある: **CacheEntries**、 **CacheTimeout**、および**PollingInterval**です。 これらのパラメーターの値は、レジストリまたは構成ファイルで指定できます。  
  
 値**CacheEntries**キャッシュ内のエントリの最大数です。 既定値の**CacheEntries** 32 です。 値を大きくことも、 **CacheEntries**パラメーターを場合によってはパフォーマンスが向上します。 たとえば、40 個のポリシーを繰り返し使用するとします。 ここでの値を増やしたい場合があります**CacheEntries**パフォーマンスを向上させるために 40 です。 この設定により、更新サービスは最大 40 個のポリシーの詳細をメモリにキャッシュできるようになります。 また、BizTalk サービスが最大 40 個のポリシー インスタンスをメモリにキャッシュできるようになります。 BizTalk サービスのキャッシュに、同じポリシーのインスタンスを複数格納できます。  
  
 値**CacheTimeout**更新サービス キャッシュを期限切れのエントリに対して、時間 (秒) になっています。 言い換えると、 **CacheTimeout**値は、ポリシーのキャッシュ エントリが保持される期間キャッシュへの参照がない場合を示します。 既定値の**CacheTimeout**は 3600 秒 (1 時間)。 つまり、1 時間以内に参照されなかったキャッシュ エントリは削除されます。 場合によってを増やしたい場合があります、 **CacheTimeout**パフォーマンスを改善する値。 たとえば、ポリシーが 2 時間おきに呼び出されるとします。 値を増やすことで、ポリシーの実行のパフォーマンスが向上する可能性があります、 **CacheTimeout**パラメーターが 2 つの時間よりも大きい値です。  
  
 **PollingInterval**ルール エンジンのパラメーターは、更新サービスが、ルール エンジン データベースでの更新をチェックする間隔を秒単位で時間を定義します。 既定値、 **PollingInterval**パラメーターは、60 秒 (1 分) です。 ポリシーがまったく、またはほとんど更新されないことがわかっている場合は、この値を大きくすることでパフォーマンスが向上します。  
  
## <a name="sideeffects-property"></a>SideEffects プロパティ  
 **ClassMemberBinding**、 **DatabaseColumnBinding**、および**XmlDocumentFieldBinding**クラスという名前のプロパティがある**SideEffects**. このプロパティは、バインドされるフィールド、メンバー、または列の値をキャッシュするかどうかを決定します。 既定値、 **SideEffects**プロパティに、 **DatabaseColumnBinding**と**XmlDocumentFieldBinding**クラスは**false**. 既定値、 **SideEffects**プロパティに、 **ClassMemberBinding**クラスは**true**です。 したがって、XML ドキュメントのフィールドまたはデータベース テーブルの列がポリシー内で 2 回目以降にアクセスされたときには、その値がキャッシュから取得されます。 一方、.NET オブジェクトのメンバーが 2 回目以降にアクセスされたときには、値がキャッシュからではなく .NET オブジェクトから取得されます。 設定、 **SideEffects** .NET のプロパティ**ClassMemberBinding**に**false**からキャッシュから取得したフィールドの値であるために、パフォーマンスが向上します2 回目以降。 この設定は、プログラムでしか行うことができません。 ビジネス ルール作成ツールは公開しません、 **SideEffects**プロパティです。  
  
## <a name="instances-and-selectivity"></a>Instances と Selectivity  
 **XmlDocumentBinding**、 **ClassBinding**、および**DatabaseBinding**クラスは、次の 2 つのプロパティを持つ:**インスタンス**と**Selectivity**です。 値**インスタンス**作業メモリ内のクラスのインスタンスの予期される数です。 値**Selectivity**ルールの条件が正常に送信されるクラスのインスタンスの割合を指定します。 ルール エンジンは、これらの値を使用して、まず最小限のインスタンスが条件の評価に使用され、その後で残りのインスタンスが使用されるように、条件の評価を最適化します。 オブジェクトのインスタンスの数の知識があれば、設定、**インスタンス**プロパティにその値をパフォーマンスが向上します。 同様に、これらのオブジェクト、条件を渡すことの割合の知識があれば、設定、 **Selectivity**プロパティにその値をパフォーマンスが向上します。 これらのパラメーターの値は、プログラムでのみ設定できます。 ビジネス ルール作成ツールでは、これらのパラメーターが公開されません。