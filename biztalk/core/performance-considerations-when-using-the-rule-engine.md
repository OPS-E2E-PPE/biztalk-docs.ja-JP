---
title: ルール エンジン使用時のパフォーマンスに関する考慮事項 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 9e9020c2-5152-40f6-940b-d4ce4081f069
caps.latest.revision: 7
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 41501ad852fe30ba54245a26a10e22e42979a1f5
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65262893"
---
# <a name="performance-considerations-when-using-the-rule-engine"></a>ルール エンジン使用時のパフォーマンスに関する考慮事項
このトピックでは、構成のチューニング パラメーターに別の値を使用してさまざまなシナリオでのルール エンジンの実行について説明します。  
  
## <a name="fact-types"></a>ファクトの種類  
 ルール エンジンでは、XML とデータベースのファクトをアクセスするよりも、.NET のファクトをアクセス時間がかかりません。 .NET、XML、またはデータベース ファクトを使用して、ポリシーで選択した場合は、パフォーマンス向上のための .NET のファクトの使用を検討してください。  
  
## <a name="data-table-vs-data-connection-binding"></a>データ テーブルとします。データ接続バインド  
 データ セットのサイズが小さい場合 (約 10 個未満の行)、 **TypedDataTable**バインディングがパフォーマンスが向上しますよりも、 **DataConnection**バインドします。 データ セットが大きい場合 (より大きいまたは等しい約 10 行)、 **DataConnection**バインディングがパフォーマンスが向上しますよりも、 **TypedDataTable**バインドします。 そのため、使用するかどうかを決定する必要があります、 **DataConnection**バインドまたは**TypedDataTable**データ セットの推定サイズに基づいて、バインドします。  
  
## <a name="fact-retrievers"></a>ファクト取得コンポーネント  
 ファクト取得コンポーネントを記述することができます: 標準的なメソッドを実装し、長期的な提供し、ポリシーが実行される前に、ルール エンジンへのファクトを緩やかに変化するのにはオブジェクトです。 エンジンは、これらのファクトをキャッシュし、複数の実行サイクルでそれらを使用します。 静的やほぼ静的なファクトをルール エンジンの起動時に毎回送信、代わりには、最初に、ファクトを送信し、必要な場合にのみメモリ内のファクトを更新するファクト取得コンポーネントを作成する必要があります。  
  
## <a name="rule-priority"></a>ルールの優先順位  
 ルールの右辺でも左辺でも範囲の優先度設定**0**、大きい数値が高い優先順位とします。 アクションは、最も高い優先度から最も低い優先順位の順序で実行されます。 使用して、ポリシーが順行連鎖の動作を実装するときに**Assert/update**優先順位の設定を使用して呼び出しをチェーンを最適化することができます。 たとえば、たとえば次に示す**Rule2**によって設定される値に依存している**Rule1**。 提供**Rule1**優先度が高いことを意味**Rule2**にした場合のみ実行されます**Rule1**が起動し、値を更新します。 逆に場合、 **Rule2**がより高い優先度を指定するには、1 回起動して後にもう一度起動し、 **Rule1**が起動し、ファクトを更新する**Rule2**条件で使用します。 、正しい結果が生じる場合もありますが、1 回だけ発生させると、パフォーマンスに影響が明確に 2 回発生しません。  
  
## <a name="update-calls"></a>更新プログラムの呼び出し  
 **Update**関数は、ルール エンジンの作業メモリ内に存在して、すべてのルールを再評価する条件で、更新されたファクトを使用するファクトを更新します。 **Update**関数呼び出しを多数のルールは、ファクトの更新によって再評価する必要がある場合に特に高価なことができます。 ルールを再評価することを回避できる場合があります。 たとえば、次の規則があるとします。  
  
 **Rule1:**  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 **Rule2:**  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 ポリシーの使用の残りのルール**StatusObj.Flag**条件。 そのため、 **Update**で呼び出される、 **StatusObj**オブジェクトのすべてのルールが再評価されます。 任意の値、**量**フィールドは、以外のすべてのルール**Rule1**と**Rule2**が 2 回、評価前に 1 回、 **Update**呼び出しと後に 1 回、 **Update**呼び出します。  
  
 値を設定する代わりに、**フラグ**フィールドを**false**のみを使用してポリシーを呼び出す前に**Rule1**では、ポリシーのフラグを設定します。 この場合、 **Update**場合にのみの値、**量**フィールドが 5 より大きいと**Update**量が 5 未満の場合は呼び出されません。 そのため、すべてのルールを除く**Rule1**と**Rule2**評価される場合にのみ 2 回の値、**量**フィールドが 5 より大きい。  
  
## <a name="use-of-logical-or-operators"></a>演算子または論理の使用  
 論理を実行するために、ルール エンジンが最適化された**AND**演算子とそれに解析選言標準形ようにするルールを再構築します。**または**演算子が最上位のレベルでのみ使用します。 論理の増加を使用して**または**条件演算子は、順列が追加されてルール エンジンの分析ネットワークが拡大を作成し、ルールの正規化にルール エンジンの時間がかかる場合があります。 次の一覧には、この問題の回避策が含まれています。  
  
-   選言標準形である規則を変更する、**または**演算子が最上位のレベルでのみです。 ビジネス ルール作成ツールで選言標準形のルールを開発するは困難に注意してください。 プログラムによってルールを作成したい場合があります。  
  
-   実行するヘルパー コンポーネントを開発、**または**操作、ブール値を返すし、ルールのコンポーネントを使用します。  
  
-   規則であり、ルールを複数のルールに分割して、フラグは、以前に実行されたルールで設定または次の例に示すように、以前に実行されたルールでアサートされたオブジェクトを使用するを確認します。  
  
    -   規則 1:IF (、1 = = または 3 を = =)、b = true  
  
         規則 2: 場合 (b = true) し、.  
  
    -   規則 1:IF (、1 = = または 3 を = =) (新しい c()) ことをアサート  
  
         規則 2:IF (c.flag == true) THEN …  
  
## <a name="caching-settings"></a>キャッシュの設定  
 ルール エンジンは、2 つのキャッシュを使用します。 1 つ目は、更新サービスであり、各 BizTalk プロセス内の 2 つ目は。 ポリシーを使用すると、最初に、BizTalk プロセスは、Update サービスからのポリシー情報を要求します。 更新サービスは、ルール エンジン データベースからポリシー情報を取得、それをキャッシュし、BizTalk プロセスに、情報を返します。 BizTalk プロセスは、その情報に基づいて、ポリシー オブジェクトを作成し、関連付けられているルール エンジン インスタンスでは、ポリシーの実行が完了すると、ポリシー オブジェクトをキャッシュに格納します。 同じポリシーが再度呼び出されるがキャッシュにある場合、BizTalk プロセス ポリシー オブジェクトをキャッシュから再利用します。  
  
 同様に、BizTalk プロセスは、Update サービスからのポリシーに関する情報を要求している場合、更新サービスはまずそのキャッシュ内のポリシー情報を探します。 更新サービスも加えられていないかどうか、データベース内のポリシーの更新を参照してください。 には毎 60 秒 (1 分) を確認します。 すべての更新プログラムがある場合は、更新サービスが情報を取得し、更新された情報をキャッシュします。  
  
 これらのキャッシュに関連するルール エンジンは、次の 3 つのチューニング パラメーターは。**CacheEntries**、 **CacheTimeout**、および**PollingInterval**します。 レジストリまたは構成ファイルでは、これらのパラメーター値を指定できます。  
  
 値**CacheEntries**はキャッシュ内のエントリの最大数です。 既定値**CacheEntries** 32 です。 値を大きくことも、 **CacheEntries**場合によってはパフォーマンスを向上させるためにパラメーター。 たとえば、40 個のポリシーを繰り返し使用するいるとします。 この場合の値を大きくたい**CacheEntries**パフォーマンスを向上させるために 40。 メモリ内更新プログラム サービスを最大で 40 のポリシーのキャッシュの詳細をこのようにするとします。 最大メモリの 40 ポリシー インスタンスをキャッシュする BizTalk サービスがあります。 BizTalk サービスのキャッシュ内のポリシーの 1 つ以上のインスタンスである可能性があります。  
  
 値**CacheTimeout**の期限切れ、更新サービス キャッシュ エントリの時間 (秒) は、します。 つまり、 **CacheTimeout**値は、ポリシーのキャッシュ エントリが保持される期間キャッシュへの参照がない場合を示します。 既定値**CacheTimeout**は 3,600 秒 (1 時間) です。 つまり、キャッシュ エントリが 1 時間以内に参照されていない場合に削除されます。 場合によってを増やしたい場合があります、 **CacheTimeout**パフォーマンスを向上させる値。 たとえば、ポリシーが 2 時間ごとに呼び出されるとします。 値を増やすことで、ポリシーの実行のパフォーマンスが向上する可能性があります、 **CacheTimeout**パラメーターが 2 時間よりも大きい値です。  
  
 **PollingInterval**パラメーターをルール エンジン更新サービスが更新プログラムのルール エンジン データベースをチェックする間隔を秒単位で時間を定義します。 既定値、 **PollingInterval**パラメーターは、60 秒 (1 分)。 ポリシーがまったくは更新されないか、めったに更新されますがわかっている場合は、パフォーマンスを向上させるには、この値を増やす可能性があります。  
  
## <a name="sideeffects-property"></a>SideEffects プロパティ  
 **ClassMemberBinding**、 **DatabaseColumnBinding**、および**XmlDocumentFieldBinding**クラスという名前のプロパティがある**SideEffects**. このプロパティは、バインドされるフィールド、メンバー、または列の値がキャッシュされているかどうかを決定します。 既定値、 **SideEffects**プロパティ、 **DatabaseColumnBinding**と**XmlDocumentFieldBinding**クラスは**false**. 既定値、 **SideEffects**プロパティ、 **ClassMemberBinding**クラスは**true**します。 そのため、XML ドキュメントのフィールドまたはデータベース テーブルの列に 2 回目またはポリシー内で後でアクセス、その値がキャッシュから取得します。 ただし、2 回目またはそれ以降、.NET オブジェクトのメンバーがアクセスされるは、値とキャッシュではなく、.NET オブジェクトから取得されます。 設定、 **SideEffects**プロパティは、.NET の**ClassMemberBinding**に**false**フィールドの値がキャッシュから取得されるので、パフォーマンスが向上します2 回目以降。 できますのみこのプログラムで実行します。 ビジネス ルール作成ツールを公開しません、 **SideEffects**プロパティ。  
  
## <a name="instances-and-selectivity"></a>Instances と Selectivity  
 **XmlDocumentBinding**、 **ClassBinding**、および**DatabaseBinding**クラスがある 2 つのプロパティ。**インスタンス**と**選択度**します。 値**インスタンス**は作業メモリ内のクラスのインスタンスの予期される数です。 値**選択度**ルールの条件が正常に渡すクラスのインスタンスの割合を指定します。 ルール エンジンでは、これらの値を使ってように最小限のインスタンスが最初に条件の評価に使用され、残っているインスタンスを使用して、条件の評価を最適化します。 オブジェクトのインスタンスの数に関する予備知識があれば、設定、**インスタンス**プロパティの値をパフォーマンスが向上します。 同様に、これらのオブジェクトの条件を渡すことの割合の知識があれば、設定、**選択度**プロパティの値をパフォーマンスが向上します。 プログラムでのみこれらのパラメーター値を設定することができます。 ビジネス ルール作成ツールはそれらを公開しません。